// Game.cpp: implementation of the CGame class.

#include "CommonTypes.h"
#include "Game.h"
#include "AdminLevel.h"
#ifdef _WIN32
#include <direct.h>
#endif
#include "LoginServer.h"
#include "EntityManager.h"
#include "AccountSqliteStore.h"
#include "GameConfigSqliteStore.h"
#include "MapInfoSqliteStore.h"
#include "sqlite3.h"
#include "Packet/SharedPackets.h"
#include "CRC32.h"
#include "SharedCalculations.h"
#include "Item/ItemAttributes.h"
#include "ChatLog.h"
#include "ItemLog.h"
#include "GameChatCommand.h"

using namespace hb::item;

class CDebugWindow* DbgWnd;

extern void PutLogList(char* cMsg);
extern void PutLogListLevel(int level, const char* cMsg);
extern char G_cTxt[512];
extern char	G_cData50000[50000];

extern void PutLogFileList(char* cStr);
extern void PutLogEventFileList(char* cStr);
extern void PutHackLogFileList(char* cStr);
extern void PutPvPLogFileList(char* cStr);

// extern void PutDebugMsg(char * cStr);	// 2002-09-09 #2

extern FILE* pLogFile;
extern HWND	G_hWnd;

// Move location tables  auto-calculated from DEF_INITDATA_TILES_X/Y.
// Each direction lists the (X,Y) tile offsets revealed when the player
// moves one step in that direction, terminated by -1.
int _tmp_iMoveLocX[9][DEF_MOVELOC_MAX_ENTRIES];
int _tmp_iMoveLocY[9][DEF_MOVELOC_MAX_ENTRIES];

static void BuildMoveLocTables()
{
	const int MAX_X = DEF_INITDATA_TILES_X - 1;
	const int MAX_Y = DEF_INITDATA_TILES_Y - 1;

	// Zero-fill everything first
	memset(_tmp_iMoveLocX, 0, sizeof(_tmp_iMoveLocX));
	memset(_tmp_iMoveLocY, 0, sizeof(_tmp_iMoveLocY));

	// Helper: write an entry pair and advance the index
	auto put = [](int dir, int& idx, int x, int y) {
		_tmp_iMoveLocX[dir][idx] = x;
		_tmp_iMoveLocY[dir][idx] = y;
		idx++;
	};
	auto sentinel = [](int dir, int idx) {
		_tmp_iMoveLocX[dir][idx] = -1;
		_tmp_iMoveLocY[dir][idx] = -1;
	};

	int n;

	// Direction 0: unused
	sentinel(0, 0);

	// Direction 1 (North): top row, sweep X 0..MAX_X, Y=0
	n = 0;
	for(int x = 0; x <= MAX_X; x++) put(1, n, x, 0);
	sentinel(1, n);

	// Direction 2 (NE): top row X 0..MAX_X at Y=0, then right column Y=1..MAX_Y at X=MAX_X
	n = 0;
	for(int x = 0; x <= MAX_X; x++) put(2, n, x, 0);
	for(int y = 1; y <= MAX_Y; y++) put(2, n, MAX_X, y);
	sentinel(2, n);

	// Direction 3 (East): right column, sweep Y 0..MAX_Y, X=MAX_X
	n = 0;
	for(int y = 0; y <= MAX_Y; y++) put(3, n, MAX_X, y);
	sentinel(3, n);

	// Direction 4 (SE): right column Y 0..MAX_Y at X=MAX_X, then bottom row X=MAX_X-1..0 at Y=MAX_Y
	n = 0;
	for(int y = 0; y <= MAX_Y; y++) put(4, n, MAX_X, y);
	for(int x = MAX_X - 1; x >= 0; x--) put(4, n, x, MAX_Y);
	sentinel(4, n);

	// Direction 5 (South): bottom row, sweep X 0..MAX_X, Y=MAX_Y
	n = 0;
	for(int x = 0; x <= MAX_X; x++) put(5, n, x, MAX_Y);
	sentinel(5, n);

	// Direction 6 (SW): left column Y 0..MAX_Y at X=0, then bottom row X=1..MAX_X at Y=MAX_Y
	n = 0;
	for(int y = 0; y <= MAX_Y; y++) put(6, n, 0, y);
	for(int x = 1; x <= MAX_X; x++) put(6, n, x, MAX_Y);
	sentinel(6, n);

	// Direction 7 (West): left column, sweep Y 0..MAX_Y, X=0
	n = 0;
	for(int y = 0; y <= MAX_Y; y++) put(7, n, 0, y);
	sentinel(7, n);

	// Direction 8 (NW): top row X 0..MAX_X at Y=0, then left column Y=1..MAX_Y at X=0
	n = 0;
	for(int x = 0; x <= MAX_X; x++) put(8, n, x, 0);
	for(int y = 1; y <= MAX_Y; y++) put(8, n, 0, y);
	sentinel(8, n);
}


char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };

// Construction/Destruction

extern bool	G_bIsThread;
extern void ThreadProc(void* ch);

CGame::CGame(HWND hWnd)
{
	int x;

	BuildMoveLocTables();

	m_bIsGameStarted = false;
	m_hWnd = hWnd;
	_lsock = 0;
	g_login = new LoginServer;

	// Initialize configurable settings with defaults
	// Timing Settings (milliseconds)
	m_iClientTimeout = DEF_CLIENTTIMEOUT;
	m_iStaminaRegenInterval = DEF_SPUPTIME;
	m_iPoisonDamageInterval = DEF_POISONTIME;
	m_iHealthRegenInterval = DEF_HPUPTIME;
	m_iManaRegenInterval = DEF_MPUPTIME;
	m_iHungerConsumeInterval = DEF_HUNGERTIME;
	m_iSummonCreatureDuration = DEF_SUMMONTIME;
	m_iAutosaveInterval = DEF_AUTOSAVETIME;
	m_iLagProtectionInterval = DEF_RAGPROTECTIONTIME;

	// Character/Leveling Settings
	m_iBaseStatValue = 10;
	m_iCreationStatBonus = 4;
	m_iLevelupStatGain = DEF_TOTALLEVELUPPOINT;
	m_iMaxLevel = DEF_PLAYERMAXLEVEL;
	m_iMaxStatValue = 0; // Calculated after config load

	// Combat Settings
	m_iMinimumHitRatio = DEF_MINIMUMHITRATIO;
	m_iMaximumHitRatio = DEF_MAXIMUMHITRATIO;

	// Gameplay Settings
	m_iNighttimeDuration = DEF_NIGHTTIME;
	m_iStartingGuildRank = m_iStartingGuildRank;
	m_iGrandMagicManaConsumption = DEF_GMGMANACONSUMEUNIT;
	m_iMaxConstructionPoints = m_iMaxConstructionPoints;
	m_iMaxSummonPoints = DEF_MAXSUMMONPOINTS;
	m_iMaxWarContribution = m_iMaxWarContribution;
	m_iMaxBankItems = 200; // Default soft cap

	m_bIsDropTableAvailable = false;
	m_DropTables.clear();

	for(int i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = 0;

	for(int i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = 0;

	for(int i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = 0;

	for(int i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = 0;

	// Initialize Entity Manager (MUST be before any entity operations)
	m_pEntityManager = new CEntityManager();

	// Get reference to EntityManager's entity array for backward compatibility
	// This allows existing code to access entities via m_pNpcList
	m_pNpcList = m_pEntityManager->GetEntityArray();
	m_pEntityManager->SetMapList(m_pMapList, DEF_MAXMAPS);
	m_pEntityManager->SetGame(this);

	for(int i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = 0;

	for(int i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = 0;

	for(int i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = 0;

	for(int i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = 0;

	for(int i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = 0;

	for(int i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = 0;

	for(int i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = 0;

	for(int i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = 0;

	for(int i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		m_pPortionConfigList[i] = 0;
		m_pCraftingConfigList[i] = 0;// Crafting
	}

	//	/for(int i = 0; i < DEF_MAXTELEPORTTYPE; i++)
	//		m_pTeleportConfigList[i] = 0;

	for(int i = 0; i < hb::limits::MaxBuildItems; i++)
		m_pBuildItemList[i] = 0;

	// New 06/05/2004
	for(int i = 0; i < DEF_MAXCLIENTS; i++) {
		m_stPartyInfo[i].iTotalMembers = 0;
		for (x = 0; x < hb::limits::MaxPartyMembers; x++)
			m_stPartyInfo[i].iIndex[x] = 0;
	}

	m_iTotalClients = 0;
	m_iMaxClients = 0;
	m_iTotalMaps = 0;

	m_iTotalGameServerClients = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = false;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds = 0;
	m_stCityStatus[1].iWins = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds = 0;
	m_stCityStatus[2].iWins = 0;

	m_iAutoRebootingCount = 0;
	m_bEnemyKillMode = false;
	m_iEnemyKillAdjust = 1;
	m_sRaidTimeMonday = 0;
	m_sRaidTimeTuesday = 0;
	m_sRaidTimeWednesday = 0;
	m_sRaidTimeThursday = 0;
	m_sRaidTimeFriday = 0;
	m_sRaidTimeSaturday = 0;
	m_sRaidTimeSunday = 0;
	m_sCharPointLimit = 0;
	m_sSlateSuccessRate = 0;
	m_sForceRecallTime = 0;
	m_fPrimaryDropRate = 1.0f;    // 1.0 = normal (10% base), 1.5 = 150%, etc.
	m_fGoldDropRate = 1.0f;       // 1.0 = normal (30% base), 1.5 = 150%, etc.
	m_fSecondaryDropRate = 1.0f;  // 1.0 = normal (5% base), 1.5 = 150%, etc.

	//Show Debug Window
	//DbgWnd = new CDebugWindow();
	//DbgWnd->Startup();
	//DbgWnd->AddEventMsg("CGame Startup");
	// 2002-09-09 #1
	m_bReceivedItemList = false;

	for(int i = 0; i < DEF_MAXCLIENTLOGINSOCK; i++)
		_lclients[i] = nullptr;

	m_pPartyManager = new class PartyManager(this);

}

CGame::~CGame()
{
	//DbgWnd->Shutdown();
	//delete DbgWnd;

	for(int i = 0; i < DEF_MAXCLIENTLOGINSOCK; i++)
	{
		if (_lclients[i])
		{
			delete _lclients[i];
			_lclients[i] = nullptr;
		}
	}

	delete m_pPartyManager;

	// Cleanup Entity Manager
	if (m_pEntityManager != NULL) {
		delete m_pEntityManager;
		m_pEntityManager = NULL;
	}
}

bool CGame::bAcceptLogin(ASIOSocket* sock)
{
	if (m_bIsGameStarted == false)
	{
		PutLogList("Closed Connection, not initialized");
		goto CLOSE_ANYWAY;
	}

	for(int i = 0; i < DEF_MAXCLIENTLOGINSOCK; i++)
	{
		auto& p = _lclients[i];
		if (!p)
		{
			p = new LoginClient(G_pIOPool->GetContext());
			sock->bAccept(p->_sock);  // MODERNIZED: Removed WM_USER_BOT_ACCEPT message ID
			std::memset(p->_ip, 0, sizeof(p->_ip));
			p->_sock->iGetPeerAddress(p->_ip);
			return true;
		}
	}

CLOSE_ANYWAY:

	// MODERNIZED: Removed m_hWnd parameter
	auto pTmpSock = new ASIOSocket(G_pIOPool->GetContext(), DEF_SERVERSOCKETBLOCKLIMIT);
	sock->bAccept(pTmpSock);
	delete pTmpSock;

	return false;
}

bool CGame::bAccept(class ASIOSocket* pXSock)
{
	int iTotalip = 0, a;
	class ASIOSocket* pTmpSock;
	char cIPtoBan[21];
	FILE* pFile;

	if (m_bIsGameStarted == false)
		goto CLOSE_ANYWAY;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] == 0) {

			m_pClientList[i] = new class CClient(G_pIOPool->GetContext());
			bAddClientShortCut(i);
			m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime =
				m_pClientList[i]->m_dwHPTime = m_pClientList[i]->m_dwAutoSaveTime =
				m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime =
				m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->m_dwSpeedHackCheckTime =
				m_pClientList[i]->m_dwAfkActivityTime = GameClock::GetTimeMS();

			pXSock->bAccept(m_pClientList[i]->m_pXSock);

			std::memset(m_pClientList[i]->m_cIPaddress, 0, sizeof(m_pClientList[i]->m_cIPaddress));
			m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);

			a = i;

			for(int v = 0; v < DEF_MAXBANNED; v++)
			{
				if (strcmp(m_stBannedList[v].m_cBannedIPaddress, m_pClientList[i]->m_cIPaddress) == 0)
				{
					goto CLOSE_CONN;
				}
			}
			//centu: Anti-Downer
			for(int j = 0; j < DEF_MAXCLIENTS; j++) {
				if (m_pClientList[j] != 0) {
					if (strcmp(m_pClientList[j]->m_cIPaddress, m_pClientList[i]->m_cIPaddress) == 0) iTotalip++;
				}
			}
			if (iTotalip > 9) {
				std::memset(cIPtoBan, 0, sizeof(cIPtoBan));
				strcpy(cIPtoBan, m_pClientList[i]->m_cIPaddress);
				//opens cfg file
				pFile = fopen("GameConfigs\\BannedList.cfg", "a");
				//shows log
				std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> IP Banned: (%s)", i, cIPtoBan);
				PutLogList(G_cTxt);
				//modifys cfg file
				fprintf(pFile, "banned-ip = %s", cIPtoBan);
				fprintf(pFile, "\n");
				fclose(pFile);

				//updates BannedList.cfg on the server
				for(int x = 0; x < DEF_MAXBANNED; x++)
					if (strlen(m_stBannedList[x].m_cBannedIPaddress) == 0)
						strcpy(m_stBannedList[x].m_cBannedIPaddress, cIPtoBan);

				goto CLOSE_CONN;
			}

			std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Client Connected: (%s)", i, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);

			m_iTotalClients++;

			if (m_iTotalClients > m_iMaxClients) {
				m_iMaxClients = m_iTotalClients;
				//GetLocalTime(&m_MaxUserSysTime);
				//std::snprintf(cTxt, sizeof(cTxt), "Maximum Players: %d", m_iMaxClients);
				//PutLogFileList(cTxt);
			}

			// m_pClientList[iClientH]->m_bIsInitComplete   .
			return true;
		}

CLOSE_ANYWAY:

	pTmpSock = new class ASIOSocket(G_pIOPool->GetContext(), DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock);
	delete pTmpSock;

	return false;

CLOSE_CONN:
	delete m_pClientList[a];
	m_pClientList[a] = 0;
	RemoveClientShortCut(a);
	return false;
}

bool CGame::bAcceptLoginFromAsync(asio::ip::tcp::socket&& peer)
{
	if (m_bIsGameStarted == false) return false;

	for(int i = 0; i < DEF_MAXCLIENTLOGINSOCK; i++)
	{
		auto& p = _lclients[i];
		if (!p)
		{
			p = new LoginClient(G_pIOPool->GetContext());
			p->_sock->bAcceptFromSocket(std::move(peer));
			std::memset(p->_ip, 0, sizeof(p->_ip));
			p->_sock->iGetPeerAddress(p->_ip);
			return true;
		}
	}

	return false;
}

bool CGame::bAcceptFromAsync(asio::ip::tcp::socket&& peer)
{
	int iTotalip = 0, a;
	char cIPtoBan[21];
	FILE* pFile;

	if (m_bIsGameStarted == false) return false;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] == 0) {

			m_pClientList[i] = new class CClient(G_pIOPool->GetContext());
			bAddClientShortCut(i);
			m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime =
				m_pClientList[i]->m_dwHPTime = m_pClientList[i]->m_dwAutoSaveTime =
				m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime =
				m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->m_dwSpeedHackCheckTime =
				m_pClientList[i]->m_dwAfkActivityTime = GameClock::GetTimeMS();

			m_pClientList[i]->m_pXSock->bAcceptFromSocket(std::move(peer));

			std::memset(m_pClientList[i]->m_cIPaddress, 0, sizeof(m_pClientList[i]->m_cIPaddress));
			m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);

			a = i;

			for(int v = 0; v < DEF_MAXBANNED; v++)
			{
				if (strcmp(m_stBannedList[v].m_cBannedIPaddress, m_pClientList[i]->m_cIPaddress) == 0)
				{
					goto CLOSE_CONN_ASYNC;
				}
			}

			for(int j = 0; j < DEF_MAXCLIENTS; j++) {
				if (m_pClientList[j] != 0) {
					if (strcmp(m_pClientList[j]->m_cIPaddress, m_pClientList[i]->m_cIPaddress) == 0) iTotalip++;
				}
			}
			if (iTotalip > 9) {
				std::memset(cIPtoBan, 0, sizeof(cIPtoBan));
				strcpy(cIPtoBan, m_pClientList[i]->m_cIPaddress);
				pFile = fopen("GameConfigs\\BannedList.cfg", "a");
				std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> IP Banned: (%s)", i, cIPtoBan);
				PutLogList(G_cTxt);
				fprintf(pFile, "banned-ip = %s", cIPtoBan);
				fprintf(pFile, "\n");
				fclose(pFile);

				for(int x = 0; x < DEF_MAXBANNED; x++)
					if (strlen(m_stBannedList[x].m_cBannedIPaddress) == 0)
						strcpy(m_stBannedList[x].m_cBannedIPaddress, cIPtoBan);

				goto CLOSE_CONN_ASYNC;
			}

			std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Client Connected: (%s)", i, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);

			m_iTotalClients++;

			if (m_iTotalClients > m_iMaxClients) {
				m_iMaxClients = m_iTotalClients;
			}

			// Set up async callbacks and start async read
			m_pClientList[i]->m_pXSock->SetSocketIndex(i);
			{
				ASIOSocket* pSock = m_pClientList[i]->m_pXSock;
				m_pClientList[i]->m_pXSock->SetCallbacks(
					[this, pSock](int idx, const char* data, size_t size, char key) {
						// Fast-track ping: respond immediately from I/O thread for accurate latency
						if (size >= sizeof(hb::net::PacketCommandCheckConnection)) {
							const auto* hdr = reinterpret_cast<const hb::net::PacketHeader*>(data);
							if (hdr->msg_id == MSGID_COMMAND_CHECKCONNECTION) {
								const auto* ping = reinterpret_cast<const hb::net::PacketCommandCheckConnection*>(data);
								hb::net::PacketCommandCheckConnection resp{};
								resp.header.msg_id = MSGID_COMMAND_CHECKCONNECTION;
								resp.header.msg_type = DEF_MSGTYPE_CONFIRM;
								resp.time_ms = ping->time_ms;
								pSock->iSendMsg(reinterpret_cast<char*>(&resp), sizeof(resp));
								// Still queue it so MsgProcess updates m_dwTime and timeout tracking
							}
						}
						bPutMsgQuene(DEF_MSGFROM_CLIENT, (char*)data, size, idx, key);
					},
					[](int idx, int err) {
						extern ConcurrentQueue<SocketErrorEvent> G_errorQueue;
						G_errorQueue.Push(SocketErrorEvent{idx, err});
					}
				);
			}
			m_pClientList[i]->m_pXSock->StartAsyncRead();

			return true;
		}

	return false;

CLOSE_CONN_ASYNC:
	delete m_pClientList[a];
	m_pClientList[a] = 0;
	RemoveClientShortCut(a);
	return false;
}

// MODERNIZED: No longer uses window messages, directly polls socket
void CGame::OnClientSocketEvent(int iClientH)
{
	int iRet;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (iClientH <= 0) return;

	if (m_pClientList[iClientH] == 0) return;

	iRet = m_pClientList[iClientH]->m_pXSock->Poll();  // MODERNIZED: Poll() instead of iOnSocketEvent()

	switch (iRet) {
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnClientRead(iClientH);
		m_pClientList[iClientH]->m_dwTime = GameClock::GetTimeMS();
		break;

	case DEF_XSOCKEVENT_BLOCK:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "[WARN] Client %d Socket BLOCKED (send buffer full)", iClientH);
		PutLogList(G_cTxt);
		break;

	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Confirmcode notmatch!", iClientH);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, false, true);
		break;

	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Client Disconnected! MSGSIZETOOLARGE (%s)", iClientH, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, true, true);
		break;

	case DEF_XSOCKEVENT_SOCKETERROR:
		std::snprintf(G_cTxt, sizeof(G_cTxt),
			"<%d> Client Disconnected! SOCKETERROR (%s) WSA=%d LastMsg=0x%08X LastMsgAge=%dms LastMsgSize=%zu CharName=%s",
			iClientH, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_pXSock->m_WSAErr,
			m_pClientList[iClientH]->m_dwLastMsgId,
			dwTime - m_pClientList[iClientH]->m_dwLastMsgTime,
			m_pClientList[iClientH]->m_dwLastMsgSize,
			m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, true, true);
		break;

	case DEF_XSOCKEVENT_SOCKETCLOSED:
		std::snprintf(G_cTxt, sizeof(G_cTxt),
			"<%d> Client Disconnected! SOCKETCLOSED (%s) WSA=%d TimeSinceLastPacket=%dms LastMsg=0x%08X LastMsgAge=%dms LastMsgSize=%zu CharName=%s",
			iClientH, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_pXSock->m_WSAErr,
			dwTime - m_pClientList[iClientH]->m_dwTime,
			m_pClientList[iClientH]->m_dwLastMsgId,
			dwTime - m_pClientList[iClientH]->m_dwLastMsgTime,
			m_pClientList[iClientH]->m_dwLastMsgSize,
			m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
		if ((dwTime - m_pClientList[iClientH]->m_dwLogoutHackCheck) < 1000) {
			try
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Logout Hack: (%s) Player: (%s) - disconnected within 10 seconds of most recent damage. Hack? Lag?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
			}
			catch (...)
			{
			}
		}

		DeleteClient(iClientH, true, true);
		break;

	case DEF_XSOCKEVENT_CRITICALERROR:
		std::snprintf(G_cTxt, sizeof(G_cTxt),
			"<%d> Client Disconnected! CRITICALERROR (%s) WSA=%d LastMsg=0x%08X LastMsgAge=%dms LastMsgSize=%zu CharName=%s",
			iClientH, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_pXSock->m_WSAErr,
			m_pClientList[iClientH]->m_dwLastMsgId,
			dwTime - m_pClientList[iClientH]->m_dwLastMsgTime,
			m_pClientList[iClientH]->m_dwLastMsgSize,
			m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, true, true);
		break;
	}
}

bool CGame::bInit()
{
	SYSTEMTIME SysTime;
	uint32_t dwTime = GameClock::GetTimeMS();

	//CMisc::Temp();

	PutLogListLevel(LOG_LEVEL_NOTICE, "Initializing game server...");

	for(int i = 0; i < DEF_MAXCLIENTS + 1; i++)
		m_iClientShortCut[i] = 0;

	if (_lsock != 0)
		delete _lsock;

	for(int i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) delete m_pClientList[i];

	for(int i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) delete m_pNpcList[i];

	for(int i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) delete m_pMapList[i];

	for(int i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != 0) delete m_pItemConfigList[i];

	for(int i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != 0) delete m_pNpcConfigList[i];

	for(int i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != 0) delete m_pMagicConfigList[i];

	for(int i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != 0) delete m_pSkillConfigList[i];

	for(int i = 0; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != 0) delete m_pQuestConfigList[i];

	for(int i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != 0) delete m_pDynamicObjectList[i];

	for(int i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != 0) delete m_pDelayEventList[i];

	for(int i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != 0) delete m_pNoticeMsgList[i];

	for(int i = 0; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] != 0) delete m_pFish[i];

	for(int i = 0; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] != 0) delete m_pMineral[i];

	for(int i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		if (m_pPortionConfigList[i] != 0) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != 0) delete m_pCraftingConfigList[i];	// Crafting
	}

	//	for(int i = 0; i < DEF_MAXTELEPORTTYPE; i++)
	//	if (m_pTeleportConfigList[i] != 0) delete m_pTeleportConfigList[i];

	for(int i = 0; i < hb::limits::MaxBuildItems; i++)
		if (m_pBuildItemList[i] != 0) delete m_pBuildItemList[i];

	for(int i = 0; i < DEF_MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = 0;


	for(int i = 0; i < DEF_MAXSCHEDULE; i++) {
		m_stCrusadeWarSchedule[i].iDay = -1;
		m_stCrusadeWarSchedule[i].iHour = -1;
		m_stCrusadeWarSchedule[i].iMinute = -1;
	}

	for(int i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleStart[i].iDay = -1;
		m_stApocalypseScheduleStart[i].iHour = -1;
		m_stApocalypseScheduleStart[i].iMinute = -1;
	}

	for(int i = 0; i < DEF_MAXHELDENIAN; i++) {
		m_stHeldenianSchedule[i].iDay = -1;
		m_stHeldenianSchedule[i].StartiHour = -1;
		m_stHeldenianSchedule[i].StartiMinute = -1;
		m_stHeldenianSchedule[i].EndiHour = -1;
		m_stHeldenianSchedule[i].EndiMinute = -1;
	}

	for(int i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleEnd[i].iDay = -1;
		m_stApocalypseScheduleEnd[i].iHour = -1;
		m_stApocalypseScheduleEnd[i].iMinute = -1;
	}

	m_iNpcConstructionPoint[1] = 100;
	m_iNpcConstructionPoint[2] = 100;
	m_iNpcConstructionPoint[3] = 100;
	m_iNpcConstructionPoint[4] = 100;
	m_iNpcConstructionPoint[5] = 100;
	m_iNpcConstructionPoint[6] = 100;

	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000;
	m_iNpcConstructionPoint[47] = 3000;
	m_iNpcConstructionPoint[51] = 1500; // Catapult

	m_bIsGameStarted = false;

	_lsock = 0;

	for(int i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = 0;

	for(int i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = 0;

	for(int i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = 0;

	for(int i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = 0;

	for(int i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = 0;

	for(int i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = 0;

	for(int i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = 0;

	for(int i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = 0;

	for(int i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = 0;

	for(int i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = 0;

	for(int i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = 0;

	for(int i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = 0;

	for(int i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = 0;

	for(int i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		m_pPortionConfigList[i] = 0;
		m_pCraftingConfigList[i] = 0;	// Crafting
	}

	//	for(int i = 0; i < DEF_MAXTELEPORTTYPE; i++)
	//		m_pTeleportConfigList[i] = 0;

	for(int i = 0; i < hb::limits::MaxBuildItems; i++)
		m_pBuildItemList[i] = 0;

	for(int i = 0; i < hb::limits::MaxCrusadeStructures; i++) {
		std::memset(m_stCrusadeStructures[i].cMapName, 0, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = 0;
		m_stCrusadeStructures[i].dX = 0;
		m_stCrusadeStructures[i].dY = 0;
	}

	for(int i = 0; i < DEF_MAXBANNED; i++) {
		std::memset(m_stBannedList[i].m_cBannedIPaddress, 0, sizeof(m_stBannedList[i].m_cBannedIPaddress));
	}

	for(int i = 0; i < DEF_MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = 0;

	for(int i = 0; i < hb::limits::MaxCrusadeStructures; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = 0;
		m_stMiddleCrusadeStructureInfo[i].cSide = 0;
		m_stMiddleCrusadeStructureInfo[i].sX = 0;
		m_stMiddleCrusadeStructureInfo[i].sY = 0;
	}
	m_iTotalMiddleCrusadeStructures = 0;

	m_pNoticementData = 0;

	m_iTotalClients = 0;
	m_iMaxClients = 0;
	m_iTotalMaps = 0;

	m_iTotalGameServerClients = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = false;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex = -1;
	m_iElvineMapIndex = -1;
	m_iGodHMapIndex = -1;
	m_iBTFieldMapIndex = -1;

	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds = 0;
	m_stCityStatus[1].iWins = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds = 0;
	m_stCityStatus[2].iWins = 0;

	m_iStrategicStatus = 0;

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;

	m_iAresdenMana = 0;
	m_iElvineMana = 0;

	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 =
		m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;

	m_bIsSpecialEventTime = false;

	GetLocalTime(&SysTime);
	m_dwCanFightzoneReserveTime = dwTime - ((SysTime.wHour % 2) * 60 * 60 + SysTime.wMinute * 60) * 1000;

	for(int i = 0; i < DEF_MAXFIGHTZONE; i++)
		m_iFightZoneReserve[i] = 0;

	m_iFightzoneNoForceRecall = 0;

	for(int i = 1; i < 1000; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);
		//testcode
		//std::snprintf(G_cTxt, sizeof(G_cTxt), "Level:%d --- Exp:%d", i, m_iLevelExpTable[i]);
		//PutLogFileList(G_cTxt);
	}

	m_iLevelExp20 = m_iLevelExpTable[20];

	sqlite3* configDb = nullptr;
	std::string configDbPath;
	bool configDbCreated = false;
	PutLogListLevel(LOG_LEVEL_NOTICE, "Validating GameConfigs.db...");
	bool configDbReady = EnsureGameConfigDatabase(&configDb, configDbPath, &configDbCreated);
	if (!configDbReady) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! GameConfigs.db unavailable.");
		return false;
	}
	if (configDbCreated) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! GameConfigs.db missing configuration data.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	if (!HasGameConfigRows(configDb, "realmlist") || !HasGameConfigRows(configDb, "active_maps") ||
		!LoadRealmConfig(configDb, this)) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Program configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	if (!HasGameConfigRows(configDb, "settings") || !LoadSettingsConfig(configDb, this)) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Settings configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	// Calculate m_iMaxStatValue after settings are loaded
	// Formula: base + creation + (levelup * max_level) + angelic_max(16)
	m_iMaxStatValue = m_iBaseStatValue + m_iCreationStatBonus + (m_iLevelupStatGain * m_iMaxLevel) + 16;
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Max stat value calculated: %d", m_iMaxStatValue);
	PutLogList(G_cTxt);

	if (!LoadBannedListConfig(configDb, this)) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Banned list unavailable in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	if (!LoadAdminConfig(configDb, this)) {
		PutLogList("(!) Warning: Could not load admin config from GameConfigs.db. Admin list empty.");
	}
	else {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Loaded %d admin(s) from GameConfigs.db.", m_iAdminCount);
		PutLogList(G_cTxt);
	}

	if (!LoadCommandPermissions(configDb, this)) {
		PutLogList("(!) Warning: Could not load command permissions from GameConfigs.db.");
	}
	else if (!m_commandPermissions.empty()) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Loaded %d command permission override(s) from GameConfigs.db.", (int)m_commandPermissions.size());
		PutLogList(G_cTxt);
	}

	srand((unsigned)time(0));

	_lsock = new class ASIOSocket(G_pIOPool->GetContext(), DEF_SERVERSOCKETBLOCKLIMIT);
	_lsock->bConnect(m_cLoginListenIP, m_iLoginListenPort);
	_lsock->bInitBufferSize(DEF_MSGBUFFERSIZE);

	m_bF1pressed = m_bF4pressed = m_bF12pressed = m_bF5pressed = false;

	m_bOnExitProcess = false;

	for(int i = 0; i <= 100; i++) {
		m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}

	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= m_iNighttimeDuration)
		m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	bReadNotifyMsgListFile("GameConfigs\\notice.txt");
	m_dwNoticeTime = dwTime;

	m_pNoticementData = 0;
	m_dwNoticementDataSize = 0;

	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;

	m_iCrusadeCount = 0;
	m_bIsCrusadeMode = false;
	m_bIsApocalypseMode = false;
	m_dwCrusadeGUID = 0;
	m_iCrusadeWinnerSide = 0;
	m_iLastCrusadeWinner = 0;
	m_sLastHeldenianWinner = 0;
	m_sLastCrusadeDate = -1;
	m_iFinalShutdownCount = 0;
	m_bIsCrusadeWarStarter = false;
	m_bIsApocalypseStarter = false;
	m_iLatestCrusadeDayOfWeek = -1;

	m_bHeldenianInitiated = false;
	m_cHeldenianType = false;
	m_bIsHeldenianMode = false;
	m_bHeldenianRunning = false;
	m_iHeldenianAresdenLeftTower = 0;
	m_cHeldenianModeType = -1;
	m_sLastHeldenianWinner = -1;
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;

	int dwMsgSize = 0;
	m_bIsItemAvailable = false;
	if (HasGameConfigRows(configDb, "items")) {
		m_bIsItemAvailable = LoadItemConfigs(configDb, m_pItemConfigList, DEF_MAXITEMTYPES);
	}
	if (!m_bIsItemAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Item configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsBuildItemAvailable = false;
	if (HasGameConfigRows(configDb, "builditem_configs")) {
		m_bIsBuildItemAvailable = LoadBuildItemConfigs(configDb, this);
	}
	if (!m_bIsBuildItemAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! BuildItem configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsNpcAvailable = false;
	if (HasGameConfigRows(configDb, "npc_configs")) {
		m_bIsNpcAvailable = LoadNpcConfigs(configDb, this);
	}
	if (!m_bIsNpcAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! NPC configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsDropTableAvailable = false;
	if (HasGameConfigRows(configDb, "drop_tables") && HasGameConfigRows(configDb, "drop_entries")) {
		m_bIsDropTableAvailable = LoadDropTables(configDb, this);
	}
	if (!m_bIsDropTableAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Drop tables missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	{
		int missingDrops = 0;
		for(int i = 0; i < DEF_MAXNPCTYPES; i++) {
			const CNpc* npc = m_pNpcConfigList[i];
			if (npc == nullptr) {
				continue;
			}
			if (npc->m_iDropTableId == 0 &&
				(npc->m_iExpDiceMax > 0 || npc->m_iGoldDiceMax > 0)) {
				char logMsg[256] = {};
				std::snprintf(logMsg, sizeof(logMsg),
					"NPC missing drop table: %s (exp %u-%u, gold %u-%u)",
					npc->m_cNpcName,
					static_cast<unsigned int>(npc->m_iExpDiceMin),
					static_cast<unsigned int>(npc->m_iExpDiceMax),
					static_cast<unsigned int>(npc->m_iGoldDiceMin),
					static_cast<unsigned int>(npc->m_iGoldDiceMax));
				PutLogListLevel(LOG_LEVEL_WARNING, logMsg);
				missingDrops++;
			}
		}
		if (missingDrops > 0) {
			char logMsg[128] = {};
			std::snprintf(logMsg, sizeof(logMsg), "NPCs missing drop tables: %d", missingDrops);
			PutLogListLevel(LOG_LEVEL_WARNING, logMsg);
		}
	}

	// Load shop configurations (optional - server works without shops)
	m_bIsShopDataAvailable = false;
	if (HasGameConfigRows(configDb, "npc_shop_mapping") || HasGameConfigRows(configDb, "shop_items")) {
		LoadShopConfigs(configDb, this);
	}
	if (!m_bIsShopDataAvailable) {
		PutLogList("(!) Shop data not configured - NPCs will not have shop inventories.");
	}

	m_bIsMagicAvailable = false;
	if (HasGameConfigRows(configDb, "magic_configs")) {
		m_bIsMagicAvailable = LoadMagicConfigs(configDb, this);
	}
	if (!m_bIsMagicAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Magic configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsSkillAvailable = false;
	if (HasGameConfigRows(configDb, "skill_configs")) {
		m_bIsSkillAvailable = LoadSkillConfigs(configDb, this);
	}
	if (!m_bIsSkillAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Skill configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	ComputeConfigHashes();

	m_bIsQuestAvailable = false;
	if (HasGameConfigRows(configDb, "quest_configs")) {
		m_bIsQuestAvailable = LoadQuestConfigs(configDb, this);
	}
	if (!m_bIsQuestAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Quest configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	m_bIsPortionAvailable = false;
	if (HasGameConfigRows(configDb, "potion_configs") || HasGameConfigRows(configDb, "crafting_configs")) {
		m_bIsPortionAvailable = LoadPortionConfigs(configDb, this);
	}
	if (!m_bIsPortionAvailable) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Potion/Crafting configs missing in GameConfigs.db.");
		CloseGameConfigDatabase(configDb);
		return false;
	}

	CloseGameConfigDatabase(configDb);

	return true;
}

void CGame::OnClientRead(int iClientH)
{
	char* pData, cKey;
	size_t  dwMsgSize;

	if (m_pClientList[iClientH] == 0) return;

	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey); // v1.4

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
		pData, sizeof(hb::net::PacketHeader));
	if (header) {
		m_pClientList[iClientH]->m_dwLastMsgId = header->msg_id;
		m_pClientList[iClientH]->m_dwLastMsgTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_dwLastMsgSize = dwMsgSize;

		// Fast-track ping responses: bypass the message queue (which only drains every 300ms)
		// so latency measurement reflects actual round-trip time
		if (header->msg_id == MSGID_COMMAND_CHECKCONNECTION) {
			CheckConnectionHandler(iClientH, pData);
			return;
		}
	}

	if (bPutMsgQuene(DEF_MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}


void CGame::ClientMotionHandler(int iClientH, char* pData)
{
	uint32_t dwClientTime;
	uint16_t wCommand, wTargetObjectID = 0;
	short sX, sY, dX, dY, wType;
	char cDir;
	int   iRet, iTemp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	const auto* base = hb::net::PacketCast<hb::net::PacketCommandMotionBase>(
		pData, sizeof(hb::net::PacketCommandMotionBase));
	if (!base) return;
	wCommand = base->header.msg_type;
	sX = base->x;
	sY = base->y;
	cDir = static_cast<char>(base->dir);
	dX = base->dx;
	dY = base->dy;
	wType = base->type;

	if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) { // v1.4
		const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandMotionAttack>(
			pData, sizeof(hb::net::PacketCommandMotionAttack));
		if (!pkt) return;
		wTargetObjectID = pkt->target_id;
		dwClientTime = pkt->time_ms;
	}
	else {
		const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandMotionSimple>(
			pData, sizeof(hb::net::PacketCommandMotionSimple));
		if (!pkt) return;
		dwClientTime = pkt->time_ms;
	}

	switch (wCommand) {
	case DEF_OBJECTSTOP:
		iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTSTOP, 0, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTRUN:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 1);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTRUN, 0, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		// v2.171
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 2);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		// v2.171
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTDAMAGEMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[iClientH]->m_iLastDamage, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		break;

	case DEF_OBJECTATTACKMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
		if ((iRet == 1) && (m_pClientList[iClientH] != 0)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACKMOVE, 0, 0, 0);
			iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, dwClientTime, false, true); // v1.4
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, 0, 0, 1); // v1.4
		// v2.171
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTATTACK:
		_CheckAttackType(iClientH, &wType);
		iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID, dwClientTime); // v1.4
		if (iRet == 1) {
			if (wType >= 20) {
				m_pClientList[iClientH]->m_iSuperAttackLeft--;
				if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		// v2.171
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTGETITEM:
		iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTGETITEM, 0, 0, 0);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTMAGIC:
		iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			m_pClientList[iClientH]->m_bMagicPauseTime = true;
			iTemp = 10;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMAGIC, dX, iTemp, 0);
			m_pClientList[iClientH]->m_iSpellCount++;
			bCheckClientMagicFrequency(iClientH, dwClientTime);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	default:
		break;
	}
}

int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType)
{
	char moveMapData[3000];
	class CTile* pTile;
	DWORD dwTime;
	WORD  wObjectID;
	short dX, dY, sDOtype, pTopItem;
	int   iRet, iSize, iDamage;
	bool  bRet, bIsBlocked = false;
	hb::net::PacketWriter writer;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	//locobans
	dwTime = timeGetTime();
	/*m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	if (cMoveType == 2) {
		if (m_pClientList[iClientH]->m_iRecentWalkTime > dwTime) {
			m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
			if (m_pClientList[iClientH]->m_sV1 < 1) {
				if (m_pClientList[iClientH]->m_iRecentWalkTime < dwTime) {
					m_pClientList[iClientH]->m_sV1++;
				}
				else {
					bIsBlocked = true;
					m_pClientList[iClientH]->m_sV1 = 0;
				}
			}
		m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
		}
		if (bIsBlocked == false) m_pClientList[iClientH]->m_iMoveMsgRecvCount++;
		if (m_pClientList[iClientH]->m_iMoveMsgRecvCount >= 3) {
			if (m_pClientList[iClientH]->m_dwMoveLAT != 0) {
				if ((dwTime - m_pClientList[iClientH]->m_dwMoveLAT) < (590)) {
					//wsprintf(G_cTxt, "3.51 Walk Speeder: (%s) Player: (%s) walk difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwMoveLAT);
					//PutHackLogFileList(G_cTxt);
					bIsBlocked = true;
				}
			}
			m_pClientList[iClientH]->m_dwMoveLAT = dwTime;
			m_pClientList[iClientH]->m_iMoveMsgRecvCount = 0;
		}
	}
	else if (cMoveType == 1) {
		if (m_pClientList[iClientH]->m_iRecentRunTime > dwTime) {
			m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
			if (m_pClientList[iClientH]->m_sV1 < 1) {
				if (m_pClientList[iClientH]->m_iRecentRunTime < dwTime) {
					m_pClientList[iClientH]->m_sV1++;
				}
				else {
					bIsBlocked = true;
					m_pClientList[iClientH]->m_sV1 = 0;
				}
			}
		m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
		}
		if (bIsBlocked == false) m_pClientList[iClientH]->m_iRunMsgRecvCount++;
		if (m_pClientList[iClientH]->m_iRunMsgRecvCount >= 3) {
			if (m_pClientList[iClientH]->m_dwRunLAT != 0) {
				if ((dwTime - m_pClientList[iClientH]->m_dwRunLAT) < (290)) {
					//wsprintf(G_cTxt, "3.51 Run Speeder: (%s) Player: (%s) run difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwRunLAT);
					//PutHackLogFileList(G_cTxt);
					bIsBlocked = true;
				}
			}
			m_pClientList[iClientH]->m_dwRunLAT	= dwTime;
			m_pClientList[iClientH]->m_iRunMsgRecvCount = 0;
		}
	}*/

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	pTopItem = 0;
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype, &pTopItem);

	if (m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0)
		bRet = false;

	if ((bRet) && (bIsBlocked == false)) {
		if (m_pClientList[iClientH]->m_iQuest != 0) _bCheckIsQuestCompleted(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		m_pClientList[iClientH]->m_sX = dX;
		m_pClientList[iClientH]->m_sY = dY;
		m_pClientList[iClientH]->m_cDir = cDir;

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH,
			DEF_OWNERTYPE_PLAYER,
			dX, dY);

		if (sDOtype == DEF_DYNAMICOBJECT_SPIKE) {
			if ((m_pClientList[iClientH]->m_bIsNeutral) && (!m_pClientList[iClientH]->m_appearance.bIsWalking)) {

			}
			else {
				iDamage = iDice(2, 4);

				m_pClientList[iClientH]->m_iHP -= iDamage;
			}
		}

		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;

		writer.Reset();
		auto* pkt = writer.Append<hb::net::PacketResponseMotionMoveConfirm>();
		pkt->header.msg_id = MSGID_RESPONSE_MOTION;
		pkt->header.msg_type = DEF_OBJECTMOVE_CONFIRM;
		pkt->x = static_cast<std::int16_t>(dX - DEF_VIEWCENTER_X);
		pkt->y = static_cast<std::int16_t>(dY - DEF_VIEWCENTER_Y);
		pkt->dir = static_cast<std::uint8_t>(cDir);
		pkt->stamina_cost = 0;
		if (cMoveType == 1) {
			if (m_pClientList[iClientH]->m_iSP > 0) {
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					pkt->stamina_cost = 1;
				}
			}
		}

		pTile = (class CTile*)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + dX + dY * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		pkt->occupy_status = static_cast<std::uint8_t>(pTile->m_iOccupyStatus);
		pkt->hp = m_pClientList[iClientH]->m_iHP;

		iSize = iComposeMoveMapData((short)(dX - DEF_VIEWCENTER_X), (short)(dY - DEF_VIEWCENTER_Y), iClientH, cDir, moveMapData);
		writer.AppendBytes(moveMapData, static_cast<std::size_t>(iSize));

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
	}
	else {
		m_pClientList[iClientH]->m_bIsMoveBlocked = true;

		m_pClientList[iClientH]->m_dwAttackLAT = 0;

		wObjectID = (WORD)iClientH;
		writer.Reset();
		auto* pkt = writer.Append<hb::net::PacketResponseMotionMoveReject>();
		pkt->header.msg_id = MSGID_RESPONSE_MOTION;
		pkt->header.msg_type = DEF_OBJECTMOVE_REJECT;
		pkt->object_id = static_cast<std::uint16_t>(wObjectID);
		pkt->x = m_pClientList[wObjectID]->m_sX;
		pkt->y = m_pClientList[wObjectID]->m_sY;
		pkt->type = m_pClientList[wObjectID]->m_sType;
		pkt->dir = static_cast<std::uint8_t>(m_pClientList[wObjectID]->m_cDir);
		std::memcpy(pkt->name, m_pClientList[wObjectID]->m_cCharName, sizeof(pkt->name));
		pkt->appearance = m_pClientList[wObjectID]->m_appearance;
		{
			auto pktStatus = m_pClientList[wObjectID]->m_status;
			pktStatus.bPK = (m_pClientList[wObjectID]->m_iPKCount != 0) ? 1 : 0;
			pktStatus.bCitizen = (m_pClientList[wObjectID]->m_cSide != 0) ? 1 : 0;
			pktStatus.bAresden = (m_pClientList[wObjectID]->m_cSide == 1) ? 1 : 0;
			pktStatus.bHunter = m_pClientList[wObjectID]->m_bIsPlayerCivil ? 1 : 0;
			pktStatus.iRelationship = GetPlayerRelationship(wObjectID, iClientH);
			pkt->status = pktStatus;
		}
		pkt->padding = 0;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
		// locobans
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		return 0;
	}

	return 1;
}

void CGame::RequestInitPlayerHandler(int iClientH, char* pData, char cKey)
{
	
	char cCharName[DEF_CHARNAME], cAccountName[DEF_ACCOUNT_NAME], cAccountPassword[DEF_ACCOUNT_PASS], cTxt[120];
	bool bIsObserverMode;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete) return;


	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestInitPlayer>(
		pData, sizeof(hb::net::PacketRequestInitPlayer));
	if (!req) return;

	memcpy(cCharName, req->player, DEF_CHARNAME - 1);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cCharName, DEF_CHARNAME - 1);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, DEF_CHARNAME - 1);

	//testcode
	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char 0!");

	memcpy(cAccountName, req->account, DEF_ACCOUNT_NAME - 1);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountName, DEF_ACCOUNT_NAME - 1);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, DEF_ACCOUNT_NAME - 1);

	// Lowercase account name to match how it was stored during account creation
	for (int ci = 0; ci < 10 && cAccountName[ci] != '\0'; ci++)
		cAccountName[ci] = static_cast<char>(::tolower(static_cast<unsigned char>(cAccountName[ci])));

	memcpy(cAccountPassword, req->password, DEF_ACCOUNT_PASS - 1);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountPassword, DEF_ACCOUNT_PASS - 1);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, DEF_ACCOUNT_PASS - 1);

	bIsObserverMode = (req->is_observer != 0);

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (iClientH != i) && (_strnicmp(m_pClientList[i]->m_cAccountName, cAccountName, DEF_ACCOUNT_NAME - 1) == 0)) {
			if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {
				wsprintf(G_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
				PutLogList(G_cTxt);
				//PutLogFileList(G_cTxt);
				DeleteClient(i, true, true, false);
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, DEF_CHARNAME - 1);
				memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, DEF_ACCOUNT_NAME - 1);
				memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, DEF_ACCOUNT_PASS - 1);

				DeleteClient(iClientH, false, false, false);
				return;
			}
		}

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (iClientH != i) && (_strnicmp(m_pClientList[i]->m_cCharName, cCharName, DEF_CHARNAME - 1) == 0)) {
			if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) {
				wsprintf(G_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
				PutLogList(G_cTxt);
				//PutLogFileList(G_cTxt);
				DeleteClient(i, true, true, false);
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, DEF_CHARNAME - 1);
				memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, DEF_ACCOUNT_NAME - 1);
				memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, DEF_ACCOUNT_PASS - 1);

				DeleteClient(iClientH, false, false);
				return;
			}
		}

	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, DEF_CHARNAME - 1);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, DEF_ACCOUNT_NAME - 1);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, DEF_ACCOUNT_PASS - 1);

	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;

	// Admin validation
	m_pClientList[iClientH]->m_iAdminIndex = -1;
	m_pClientList[iClientH]->m_iAdminLevel = 0;
	m_pClientList[iClientH]->m_bIsGMMode = false;
	int iAdminIdx = FindAdminByAccount(cAccountName);
	if (iAdminIdx != -1 && _stricmp(m_stAdminList[iAdminIdx].m_cCharName, cCharName) == 0)
	{
		if (strcmp(m_stAdminList[iAdminIdx].m_cApprovedIP, "0.0.0.0") == 0)
		{
			strncpy(m_stAdminList[iAdminIdx].m_cApprovedIP, m_pClientList[iClientH]->m_cIPaddress, 20);
			m_stAdminList[iAdminIdx].m_cApprovedIP[20] = '\0';
			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Admin IP auto-set for account %s to %s", cAccountName, m_pClientList[iClientH]->m_cIPaddress);
			PutLogList(G_cTxt);

			sqlite3* configDb = nullptr;
			std::string dbPath;
			if (EnsureGameConfigDatabase(&configDb, dbPath, nullptr))
			{
				SaveAdminConfig(configDb, this);
				CloseGameConfigDatabase(configDb);
			}

			m_pClientList[iClientH]->m_iAdminIndex = iAdminIdx;
			m_pClientList[iClientH]->m_iAdminLevel = m_stAdminList[iAdminIdx].m_iAdminLevel;
		}
		else if (strcmp(m_stAdminList[iAdminIdx].m_cApprovedIP, m_pClientList[iClientH]->m_cIPaddress) == 0)
		{
			m_pClientList[iClientH]->m_iAdminIndex = iAdminIdx;
			m_pClientList[iClientH]->m_iAdminLevel = m_stAdminList[iAdminIdx].m_iAdminLevel;
		}
		else
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) SECURITY: Admin IP mismatch for account %s (expected %s, got %s)",
				cAccountName, m_stAdminList[iAdminIdx].m_cApprovedIP, m_pClientList[iClientH]->m_cIPaddress);
			PutLogList(G_cTxt);
			DeleteClient(iClientH, false, false, false);
			return;
		}
	}

	InitPlayerData(iClientH, 0, 0); //bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
}

// 05/22/2004 - Hypnotoad - sends client to proper location after dieing
void CGame::RequestInitDataHandler(int iClientH, char* pData, char cKey, size_t dwMsgSize)
{
	char cPlayerName[DEF_CHARNAME], cTxt[120];
	int sSummonPoints;
	int iTotalItemA, iTotalItemB, iSize, iRet, iStats;
	SYSTEMTIME SysTime;
	hb::net::PacketWriter writer;
	char initMapData[DEF_MSGBUFFERSIZE + 1];

	if (m_pClientList[iClientH] == 0) return;

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestInitPlayer>(
		pData, sizeof(hb::net::PacketRequestInitPlayer));
	if (!req) {
		return;
	}

	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, req->player, DEF_CHARNAME - 1);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cPlayerName, DEF_CHARNAME - 1);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cTxt, DEF_CHARNAME - 1);

	if (_strnicmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, DEF_CHARNAME - 1) != 0) {
		DeleteClient(iClientH, false, true);
		return;
	}

	// Send configs FIRST so the client has item/magic/skill definitions
	// before receiving player data that references them.
	uint32_t clientItemHash = 0, clientMagicHash = 0, clientSkillHash = 0;
	if (dwMsgSize >= sizeof(hb::net::PacketRequestInitDataEx)) {
		const auto* exReq = reinterpret_cast<const hb::net::PacketRequestInitDataEx*>(pData);
		clientItemHash = exReq->itemConfigHash;
		clientMagicHash = exReq->magicConfigHash;
		clientSkillHash = exReq->skillConfigHash;
	}

	bool bItemCacheValid  = (clientItemHash != 0 && clientItemHash == m_dwConfigHash[0]);
	bool bMagicCacheValid = (clientMagicHash != 0 && clientMagicHash == m_dwConfigHash[1]);
	bool bSkillCacheValid = (clientSkillHash != 0 && clientSkillHash == m_dwConfigHash[2]);

	{
		hb::net::PacketResponseConfigCacheStatus cacheStatus{};
		cacheStatus.header.msg_id = MSGID_RESPONSE_CONFIGCACHESTATUS;
		cacheStatus.header.msg_type = DEF_MSGTYPE_CONFIRM;
		cacheStatus.itemCacheValid = bItemCacheValid ? 1 : 0;
		cacheStatus.magicCacheValid = bMagicCacheValid ? 1 : 0;
		cacheStatus.skillCacheValid = bSkillCacheValid ? 1 : 0;
		m_pClientList[iClientH]->m_pXSock->iSendMsg(
			reinterpret_cast<char*>(&cacheStatus), sizeof(cacheStatus));
	}

	if (!bItemCacheValid)  bSendClientItemConfigs(iClientH);
	if (!bMagicCacheValid) bSendClientMagicConfigs(iClientH);
	if (!bSkillCacheValid) bSendClientSkillConfigs(iClientH);

	// Now send player data (configs are guaranteed loaded on client)
	writer.Reset();
	auto* char_pkt = writer.Append<hb::net::PacketResponsePlayerCharacterContents>();
	char_pkt->header.msg_id = MSGID_PLAYERCHARACTERCONTENTS;
	char_pkt->header.msg_type = DEF_MSGTYPE_CONFIRM;
	char_pkt->hp = m_pClientList[iClientH]->m_iHP;
	char_pkt->mp = m_pClientList[iClientH]->m_iMP;
	char_pkt->sp = m_pClientList[iClientH]->m_iSP;
	char_pkt->ac = m_pClientList[iClientH]->m_iDefenseRatio;
	char_pkt->thac0 = m_pClientList[iClientH]->m_iHitRatio;
	char_pkt->level = m_pClientList[iClientH]->m_iLevel;
	char_pkt->str = m_pClientList[iClientH]->m_iStr;
	char_pkt->intel = m_pClientList[iClientH]->m_iInt;
	char_pkt->vit = m_pClientList[iClientH]->m_iVit;
	char_pkt->dex = m_pClientList[iClientH]->m_iDex;
	char_pkt->mag = m_pClientList[iClientH]->m_iMag;
	char_pkt->chr = m_pClientList[iClientH]->m_iCharisma;

	iStats = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma);

	m_pClientList[iClientH]->m_iLU_Pool = (m_pClientList[iClientH]->m_iLevel - 1) * 3 - (iStats - 70);
	char_pkt->lu_point = static_cast<std::uint16_t>(m_pClientList[iClientH]->m_iLU_Pool);
	char_pkt->lu_unused[0] = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_cVar);
	char_pkt->lu_unused[1] = 0;
	char_pkt->lu_unused[2] = 0;
	char_pkt->lu_unused[3] = 0;
	char_pkt->lu_unused[4] = 0;
	char_pkt->exp = m_pClientList[iClientH]->m_iExp;
	char_pkt->enemy_kills = m_pClientList[iClientH]->m_iEnemyKillCount;
	char_pkt->pk_count = m_pClientList[iClientH]->m_iPKCount;
	char_pkt->reward_gold = m_pClientList[iClientH]->m_iRewardGold;
	std::memcpy(char_pkt->location, m_pClientList[iClientH]->m_cLocation, sizeof(char_pkt->location));
	std::memcpy(char_pkt->guild_name, m_pClientList[iClientH]->m_cGuildName, sizeof(char_pkt->guild_name));
	char_pkt->guild_rank = m_pClientList[iClientH]->m_iGuildRank;
	char_pkt->super_attack_left = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_iSuperAttackLeft);
	char_pkt->fightzone_number = m_pClientList[iClientH]->m_iFightzoneNumber;
	char_pkt->max_stats = m_iMaxStatValue;
	char_pkt->max_level = m_iMaxLevel;
	char_pkt->max_bank_items = m_iMaxBankItems;

	//hbest
	m_pClientList[iClientH]->isForceSet = false;
	m_pClientList[iClientH]->m_iPartyID = 0;
	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
	m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}

	writer.Reset();
	auto* item_header = writer.Append<hb::net::PacketResponseItemListHeader>();
	item_header->header.msg_id = MSGID_PLAYERITEMLISTCONTENTS;
	item_header->header.msg_type = DEF_MSGTYPE_CONFIRM;

	iTotalItemA = 0;
	for(int i = 0; i < hb::limits::MaxItems; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0)
			iTotalItemA++;

	item_header->item_count = static_cast<std::uint8_t>(iTotalItemA);

	for(int i = 0; i < iTotalItemA; i++) {
		// ### ERROR POINT!!!
		if (m_pClientList[iClientH]->m_pItemList[i] == 0) {
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, false, true);
			return;
		}
		auto* entry = writer.Append<hb::net::PacketResponseItemListEntry>();
		std::memcpy(entry->name, m_pClientList[iClientH]->m_pItemList[i]->m_cName, sizeof(entry->name));
		entry->count = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		entry->item_type = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		entry->equip_pos = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		entry->is_equipped = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_bIsItemEquipped[i]);
		entry->level_limit = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		entry->gender_limit = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		entry->cur_lifespan = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		entry->weight = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		entry->sprite = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		entry->sprite_frame = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		entry->item_color = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor;
		entry->spec_value2 = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2);
		entry->attribute = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		entry->item_id = m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum;
		entry->max_lifespan = m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan;
	}

	iTotalItemB = 0;
	for(int i = 0; i < hb::limits::MaxBankItems; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != 0)
			iTotalItemB++;

	auto* bank_header = writer.Append<hb::net::PacketResponseBankItemListHeader>();
	bank_header->bank_item_count = static_cast<std::uint16_t>(iTotalItemB);

	for(int i = 0; i < iTotalItemB; i++) {
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, false, true);
			return;
		}
		auto* entry = writer.Append<hb::net::PacketResponseBankItemEntry>();
		std::memcpy(entry->name, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, sizeof(entry->name));
		entry->count = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		entry->item_type = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		entry->equip_pos = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		entry->level_limit = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		entry->gender_limit = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		entry->cur_lifespan = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		entry->weight = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		entry->sprite = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		entry->sprite_frame = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		entry->item_color = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor;
		entry->spec_value2 = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2);
		entry->attribute = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		entry->item_id = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sIDnum;
		entry->max_lifespan = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wMaxLifeSpan;
	}

	auto* mastery = writer.Append<hb::net::PacketResponseMasteryData>();
	std::memcpy(mastery->magic_mastery, m_pClientList[iClientH]->m_cMagicMastery, DEF_MAXMAGICTYPE);
	std::memcpy(mastery->skill_mastery, m_pClientList[iClientH]->m_cSkillMastery, DEF_MAXSKILLTYPE);

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}

	// Send item positions right after item list so positions are applied
	// while items are still freshly initialized
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMPOSLIST, 0, 0, 0, 0);

	writer.Reset();
	auto* init_header = writer.Append<hb::net::PacketResponseInitDataHeader>();
	init_header->header.msg_id = MSGID_RESPONSE_INITDATA;
	init_header->header.msg_type = DEF_MSGTYPE_CONFIRM;

	if (m_pClientList[iClientH]->m_bIsObserverMode == false)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	init_header->player_object_id = static_cast<std::int16_t>(iClientH);
	init_header->pivot_x = static_cast<std::int16_t>(m_pClientList[iClientH]->m_sX - DEF_PLAYER_PIVOT_OFFSET_X);
	init_header->pivot_y = static_cast<std::int16_t>(m_pClientList[iClientH]->m_sY - DEF_PLAYER_PIVOT_OFFSET_Y);
	init_header->player_type = m_pClientList[iClientH]->m_sType;
	init_header->appearance = m_pClientList[iClientH]->m_appearance;
	init_header->status = m_pClientList[iClientH]->m_status;
	std::memcpy(init_header->map_name, m_pClientList[iClientH]->m_cMapName, sizeof(init_header->map_name));
	std::memcpy(init_header->cur_location, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sizeof(init_header->cur_location));

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)
		init_header->sprite_alpha = 1;
	else init_header->sprite_alpha = m_cDayOrNight;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)
		init_header->weather_status = 0;
	else init_header->weather_status = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;

	init_header->contribution = m_pClientList[iClientH]->m_iContribution;

	if (m_pClientList[iClientH]->m_bIsObserverMode == false) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH,
			DEF_OWNERTYPE_PLAYER,
			m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY);
	}

	init_header->observer_mode = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_bIsObserverMode);
	init_header->rating = m_pClientList[iClientH]->m_iRating;
	init_header->hp = m_pClientList[iClientH]->m_iHP;
	init_header->discount = 0;

	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - DEF_VIEWCENTER_X, m_pClientList[iClientH]->m_sY - DEF_VIEWCENTER_Y, iClientH, initMapData);
	writer.AppendBytes(initMapData, static_cast<std::size_t>(iSize));

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);

	// v2.13 
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		) {

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = true;
		// v2.17 2002-7-15
		SetForceRecallTime(iClientH);
	}
	// v2.13 
	else if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		) {

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = true;

		// v2.17 2002-7-15
		SetForceRecallTime(iClientH);
	}
	else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) ||
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
		) {
		m_pClientList[iClientH]->m_bIsWarLocation = true;
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

		// v2.17 2002-7-15 
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 5;
		}
		else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20 * 5) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * 5;
		}

	}
	else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) &&
		(m_iFightzoneNoForceRecall == 0) ) {

		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = true;

		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 60 * 20 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 2 * 20;
	}
	else
	{
		m_pClientList[iClientH]->m_bIsWarLocation = false;
		// v1.42
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		// 06/11/2004
		SetForceRecallTime(iClientH);
	}

	// v2.17 2002-7-15
	//hbest...
	if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) && (m_pClientList[iClientH]->m_bIsWarLocation) && IsEnemyZone(iClientH)) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FORCERECALLTIME, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, 0, 0, 0);
		//wsprintf(G_cTxt,"(!) Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		//PutLogList(G_cTxt) ;
	}

	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 0) {
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = 0;
	}

	// No entering enemy shops
	int iMapside, iMapside2;

	iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	if (iMapside > 3) iMapside2 = iMapside - 2;
	else iMapside2 = iMapside;
	m_pClientList[iClientH]->m_bIsInsideOwnTown = false;
	if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
		if ((iMapside <= 2)) {
			if (m_pClientList[iClientH]->m_cSide != 0) {
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = true;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				m_pClientList[iClientH]->m_bIsInsideOwnTown = true;
			}
		}
	}
	else {
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone &&
			m_iFightzoneNoForceRecall == false) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = true;
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 60 * 20 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 2 * 20;
		}
		else {
			if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0 ||
				memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0) {
				m_pClientList[iClientH]->m_bIsWarLocation = true;
				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
					m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
				else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
					m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
			}
		}
	}

	/*if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) &&
		(m_pClientList[iClientH]->m_bIsWarLocation )) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FORCERECALLTIME, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, 0, 0, 0);
	}*/

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SAFEATTACKMODE, 0, 0, 0, 0);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, 0, 0, 0);

	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, 0);
	}

	// Crusade 
	if (m_bIsCrusadeMode) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);
		}
		m_pClientList[iClientH]->m_cVar = 1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, 0);
	}
	else if (m_bIsHeldenianMode) {
		sSummonPoints = m_pClientList[iClientH]->m_iCharisma * 300;
		if (sSummonPoints > m_iMaxSummonPoints) sSummonPoints = m_iMaxSummonPoints;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == 0) {
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
		}
		else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) {
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
		}
		m_pClientList[iClientH]->m_cVar = 2;
		if (m_bIsHeldenianMode) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, 0, 0, 0, 0);
			if (m_bHeldenianInitiated == false) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0);
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, 0);
			UpdateHeldenianStatus();
		}
	}
	else if ((m_pClientList[iClientH]->m_cVar == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
		m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
	}
	else {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_pClientList[iClientH]->m_cVar == 1) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);
			}
		}
		else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, 0, 0, 0, -1);
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	if (m_bIsHeldenianMode) SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0, 0);
	if (m_bHeldenianInitiated) SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0, 0);

	// Crusade
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, 0);
	//Fix Sprite Bug
	//			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
	//Gizon point lefT???
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

	if ((m_bIsApocalypseMode) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsApocalypseMap)) {
		RequestTeleportHandler(iClientH, "1   ");
	}

	if (m_bIsApocalypseMode) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, 0, 0, 0, 0, 0);
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, 0, 0, 0);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);

	RequestNoticementHandler(iClientH); // send noticement when log in
}

bool CGame::bSendClientItemConfigs(int iClientH)
{
	if (m_pClientList[iClientH] == 0) {
		return false;
	}

	// Calculate how many items per packet - keep packets small (~7KB) for reliable delivery
	constexpr size_t maxPacketSize = 7000;
	constexpr size_t headerSize = sizeof(hb::net::PacketItemConfigHeader);
	constexpr size_t entrySize = sizeof(hb::net::PacketItemConfigEntry);
	constexpr size_t maxEntriesPerPacket = (maxPacketSize - headerSize) / entrySize;

	// First count total items
	int totalItems = 0;
	for(int i = 0; i < DEF_MAXITEMTYPES; i++) {
		if (m_pItemConfigList[i] != 0) {
			totalItems++;
		}
	}

	// Send items in packets
	int itemsSent = 0;
	int packetIndex = 0;

	while (itemsSent < totalItems) {
		// Build packet
		std::memset(G_cData50000, 0, sizeof(G_cData50000));

		auto* pktHeader = reinterpret_cast<hb::net::PacketItemConfigHeader*>(G_cData50000);
		pktHeader->header.msg_id = MSGID_ITEMCONFIGURATIONCONTENTS;
		pktHeader->header.msg_type = DEF_MSGTYPE_CONFIRM;
		pktHeader->totalItems = static_cast<uint16_t>(totalItems);
		pktHeader->packetIndex = static_cast<uint16_t>(packetIndex);

		auto* entries = reinterpret_cast<hb::net::PacketItemConfigEntry*>(G_cData50000 + headerSize);

		uint16_t entriesInPacket = 0;
		int configIndex = 0;
		int skipped = 0;

		// Find items for this packet
		for(int i = 0; i < DEF_MAXITEMTYPES && entriesInPacket < maxEntriesPerPacket; i++) {
			if (m_pItemConfigList[i] == 0) {
				continue;
			}

			// Skip items already sent in previous packets
			if (skipped < itemsSent) {
				skipped++;
				continue;
			}

			const CItem* item = m_pItemConfigList[i];
			auto& entry = entries[entriesInPacket];

			entry.itemId = item->m_sIDnum;
			std::memset(entry.name, 0, sizeof(entry.name));
			std::strncpy(entry.name, item->m_cName, sizeof(entry.name) - 1);
			entry.itemType = item->m_cItemType;
			entry.equipPos = item->m_cEquipPos;
			entry.effectType = item->m_sItemEffectType;
			entry.effectValue1 = item->m_sItemEffectValue1;
			entry.effectValue2 = item->m_sItemEffectValue2;
			entry.effectValue3 = item->m_sItemEffectValue3;
			entry.effectValue4 = item->m_sItemEffectValue4;
			entry.effectValue5 = item->m_sItemEffectValue5;
			entry.effectValue6 = item->m_sItemEffectValue6;
			entry.maxLifeSpan = item->m_wMaxLifeSpan;
			entry.specialEffect = item->m_sSpecialEffect;
			entry.sprite = item->m_sSprite;
			entry.spriteFrame = item->m_sSpriteFrame;
			entry.price = item->m_bIsForSale ? static_cast<int32_t>(item->m_wPrice) : -static_cast<int32_t>(item->m_wPrice);
			entry.weight = item->m_wWeight;
			entry.apprValue = item->m_cApprValue;
			entry.speed = item->m_cSpeed;
			entry.levelLimit = item->m_sLevelLimit;
			entry.genderLimit = item->m_cGenderLimit;
			entry.specialEffectValue1 = item->m_sSpecialEffectValue1;
			entry.specialEffectValue2 = item->m_sSpecialEffectValue2;
			entry.relatedSkill = item->m_sRelatedSkill;
			entry.category = item->m_cCategory;
			entry.itemColor = item->m_cItemColor;

			entriesInPacket++;
		}

		pktHeader->itemCount = entriesInPacket;
		size_t packetSize = headerSize + (entriesInPacket * entrySize);

		int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(G_cData50000, static_cast<int>(packetSize));
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			std::snprintf(G_cTxt, sizeof(G_cTxt),
				"Failed to send item configs: Client(%d) Packet(%d)",
				iClientH, packetIndex);
			PutLogList(G_cTxt);
			DeleteClient(iClientH, true, true);
			delete m_pClientList[iClientH];
			m_pClientList[iClientH] = 0;
			return false;
		}

		itemsSent += entriesInPacket;
		packetIndex++;
	}

	return true;
}

bool CGame::bSendClientMagicConfigs(int iClientH)
{
	if (m_pClientList[iClientH] == 0) {
		return false;
	}

	constexpr size_t maxPacketSize = 7000;
	constexpr size_t headerSize = sizeof(hb::net::PacketMagicConfigHeader);
	constexpr size_t entrySize = sizeof(hb::net::PacketMagicConfigEntry);
	constexpr size_t maxEntriesPerPacket = (maxPacketSize - headerSize) / entrySize;

	// Count total magics
	int totalMagics = 0;
	for(int i = 0; i < DEF_MAXMAGICTYPE; i++) {
		if (m_pMagicConfigList[i] != 0) {
			totalMagics++;
		}
	}

	// Send magics in packets
	int magicsSent = 0;
	int packetIndex = 0;

	while (magicsSent < totalMagics) {
		std::memset(G_cData50000, 0, sizeof(G_cData50000));

		auto* pktHeader = reinterpret_cast<hb::net::PacketMagicConfigHeader*>(G_cData50000);
		pktHeader->header.msg_id = MSGID_MAGICCONFIGURATIONCONTENTS;
		pktHeader->header.msg_type = DEF_MSGTYPE_CONFIRM;
		pktHeader->totalMagics = static_cast<uint16_t>(totalMagics);
		pktHeader->packetIndex = static_cast<uint16_t>(packetIndex);

		auto* entries = reinterpret_cast<hb::net::PacketMagicConfigEntry*>(G_cData50000 + headerSize);

		uint16_t entriesInPacket = 0;
		int skipped = 0;

		for(int i = 0; i < DEF_MAXMAGICTYPE && entriesInPacket < maxEntriesPerPacket; i++) {
			if (m_pMagicConfigList[i] == 0) {
				continue;
			}

			if (skipped < magicsSent) {
				skipped++;
				continue;
			}

			const CMagic* magic = m_pMagicConfigList[i];
			auto& entry = entries[entriesInPacket];

			entry.magicId = static_cast<int16_t>(i);
			std::memset(entry.name, 0, sizeof(entry.name));
			std::strncpy(entry.name, magic->m_cName, sizeof(entry.name) - 1);
			entry.manaCost = magic->m_sValue1;
			entry.intLimit = magic->m_sIntLimit;
			entry.goldCost = magic->m_iGoldCost;
			entry.isVisible = (magic->m_iGoldCost >= 0) ? 1 : 0;
			entry.magicType = magic->m_sType;
			entry.aoeRadiusX = magic->m_sValue2;
			entry.aoeRadiusY = magic->m_sValue3;
			entry.dynamicPattern = magic->m_sValue11;
			entry.dynamicRadius = magic->m_sValue12;

			entriesInPacket++;
		}

		pktHeader->magicCount = entriesInPacket;
		size_t packetSize = headerSize + (entriesInPacket * entrySize);

		int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(G_cData50000, static_cast<int>(packetSize));
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			std::snprintf(G_cTxt, sizeof(G_cTxt),
				"Failed to send magic configs: Client(%d) Packet(%d)",
				iClientH, packetIndex);
			PutLogList(G_cTxt);
			DeleteClient(iClientH, true, true);
			delete m_pClientList[iClientH];
			m_pClientList[iClientH] = 0;
			return false;
		}

		magicsSent += entriesInPacket;
		packetIndex++;
	}

	return true;
}

bool CGame::bSendClientSkillConfigs(int iClientH)
{
	if (m_pClientList[iClientH] == 0) {
		return false;
	}

	constexpr size_t maxPacketSize = 7000;
	constexpr size_t headerSize = sizeof(hb::net::PacketSkillConfigHeader);
	constexpr size_t entrySize = sizeof(hb::net::PacketSkillConfigEntry);
	constexpr size_t maxEntriesPerPacket = (maxPacketSize - headerSize) / entrySize;

	// Count total skills
	int totalSkills = 0;
	for(int i = 0; i < DEF_MAXSKILLTYPE; i++) {
		if (m_pSkillConfigList[i] != 0) {
			totalSkills++;
		}
	}

	// Send skills in packets
	int skillsSent = 0;
	int packetIndex = 0;

	while (skillsSent < totalSkills) {
		std::memset(G_cData50000, 0, sizeof(G_cData50000));

		auto* pktHeader = reinterpret_cast<hb::net::PacketSkillConfigHeader*>(G_cData50000);
		pktHeader->header.msg_id = MSGID_SKILLCONFIGURATIONCONTENTS;
		pktHeader->header.msg_type = DEF_MSGTYPE_CONFIRM;
		pktHeader->totalSkills = static_cast<uint16_t>(totalSkills);
		pktHeader->packetIndex = static_cast<uint16_t>(packetIndex);

		auto* entries = reinterpret_cast<hb::net::PacketSkillConfigEntry*>(G_cData50000 + headerSize);

		uint16_t entriesInPacket = 0;
		int skipped = 0;

		for(int i = 0; i < DEF_MAXSKILLTYPE && entriesInPacket < maxEntriesPerPacket; i++) {
			if (m_pSkillConfigList[i] == 0) {
				continue;
			}

			if (skipped < skillsSent) {
				skipped++;
				continue;
			}

			const CSkill* skill = m_pSkillConfigList[i];
			auto& entry = entries[entriesInPacket];

			entry.skillId = static_cast<int16_t>(i);
			std::memset(entry.name, 0, sizeof(entry.name));
			std::strncpy(entry.name, skill->m_cName, sizeof(entry.name) - 1);
			entry.isUseable = skill->m_bIsUseable ? 1 : 0;
			entry.useMethod = skill->m_cUseMethod;

			entriesInPacket++;
		}

		pktHeader->skillCount = entriesInPacket;
		size_t packetSize = headerSize + (entriesInPacket * entrySize);

		int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(G_cData50000, static_cast<int>(packetSize));
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			std::snprintf(G_cTxt, sizeof(G_cTxt),
				"Failed to send skill configs: Client(%d) Packet(%d)",
				iClientH, packetIndex);
			PutLogList(G_cTxt);
			DeleteClient(iClientH, true, true);
			delete m_pClientList[iClientH];
			m_pClientList[iClientH] = 0;
			return false;
		}

		skillsSent += entriesInPacket;
		packetIndex++;
	}

	return true;
}

void CGame::ComputeConfigHashes()
{
	// Compute CRC32 for item configs
	{
		constexpr size_t headerSize = sizeof(hb::net::PacketItemConfigHeader);
		constexpr size_t entrySize = sizeof(hb::net::PacketItemConfigEntry);
		constexpr size_t maxEntriesPerPacket = (7000 - headerSize) / entrySize;

		std::vector<uint8_t> allData;
		int totalItems = 0;
		for(int i = 0; i < DEF_MAXITEMTYPES; i++) {
			if (m_pItemConfigList[i] != 0) totalItems++;
		}

		int itemsSent = 0;
		int packetIndex = 0;
		while (itemsSent < totalItems) {
			char buf[7000]{};
			auto* pktHeader = reinterpret_cast<hb::net::PacketItemConfigHeader*>(buf);
			pktHeader->header.msg_id = MSGID_ITEMCONFIGURATIONCONTENTS;
			pktHeader->header.msg_type = DEF_MSGTYPE_CONFIRM;
			pktHeader->totalItems = static_cast<uint16_t>(totalItems);
			pktHeader->packetIndex = static_cast<uint16_t>(packetIndex);

			auto* entries = reinterpret_cast<hb::net::PacketItemConfigEntry*>(buf + headerSize);
			uint16_t entriesInPacket = 0;
			int skipped = 0;

			for(int i = 0; i < DEF_MAXITEMTYPES && entriesInPacket < maxEntriesPerPacket; i++) {
				if (m_pItemConfigList[i] == 0) continue;
				if (skipped < itemsSent) { skipped++; continue; }

				const CItem* item = m_pItemConfigList[i];
				auto& entry = entries[entriesInPacket];
				entry.itemId = item->m_sIDnum;
				std::memset(entry.name, 0, sizeof(entry.name));
				std::strncpy(entry.name, item->m_cName, sizeof(entry.name) - 1);
				entry.itemType = item->m_cItemType;
				entry.equipPos = item->m_cEquipPos;
				entry.effectType = item->m_sItemEffectType;
				entry.effectValue1 = item->m_sItemEffectValue1;
				entry.effectValue2 = item->m_sItemEffectValue2;
				entry.effectValue3 = item->m_sItemEffectValue3;
				entry.effectValue4 = item->m_sItemEffectValue4;
				entry.effectValue5 = item->m_sItemEffectValue5;
				entry.effectValue6 = item->m_sItemEffectValue6;
				entry.maxLifeSpan = item->m_wMaxLifeSpan;
				entry.specialEffect = item->m_sSpecialEffect;
				entry.sprite = item->m_sSprite;
				entry.spriteFrame = item->m_sSpriteFrame;
				entry.price = item->m_bIsForSale ? static_cast<int32_t>(item->m_wPrice) : -static_cast<int32_t>(item->m_wPrice);
				entry.weight = item->m_wWeight;
				entry.apprValue = item->m_cApprValue;
				entry.speed = item->m_cSpeed;
				entry.levelLimit = item->m_sLevelLimit;
				entry.genderLimit = item->m_cGenderLimit;
				entry.specialEffectValue1 = item->m_sSpecialEffectValue1;
				entry.specialEffectValue2 = item->m_sSpecialEffectValue2;
				entry.relatedSkill = item->m_sRelatedSkill;
				entry.category = item->m_cCategory;
				entry.itemColor = item->m_cItemColor;
				entriesInPacket++;
			}

			pktHeader->itemCount = entriesInPacket;
			size_t packetSize = headerSize + (entriesInPacket * entrySize);

			uint16_t len = static_cast<uint16_t>(packetSize);
			const uint8_t* lenBytes = reinterpret_cast<const uint8_t*>(&len);
			allData.push_back(lenBytes[0]);
			allData.push_back(lenBytes[1]);
			allData.insert(allData.end(), reinterpret_cast<uint8_t*>(buf), reinterpret_cast<uint8_t*>(buf) + packetSize);

			itemsSent += entriesInPacket;
			packetIndex++;
		}
		m_dwConfigHash[0] = allData.empty() ? 0 : hb_crc32(allData.data(), allData.size());
	}

	// Compute CRC32 for magic configs
	{
		constexpr size_t headerSize = sizeof(hb::net::PacketMagicConfigHeader);
		constexpr size_t entrySize = sizeof(hb::net::PacketMagicConfigEntry);
		constexpr size_t maxEntriesPerPacket = (7000 - headerSize) / entrySize;

		std::vector<uint8_t> allData;
		int totalMagics = 0;
		for(int i = 0; i < DEF_MAXMAGICTYPE; i++) {
			if (m_pMagicConfigList[i] != 0) totalMagics++;
		}

		int magicsSent = 0;
		int packetIndex = 0;
		while (magicsSent < totalMagics) {
			char buf[7000]{};
			auto* pktHeader = reinterpret_cast<hb::net::PacketMagicConfigHeader*>(buf);
			pktHeader->header.msg_id = MSGID_MAGICCONFIGURATIONCONTENTS;
			pktHeader->header.msg_type = DEF_MSGTYPE_CONFIRM;
			pktHeader->totalMagics = static_cast<uint16_t>(totalMagics);
			pktHeader->packetIndex = static_cast<uint16_t>(packetIndex);

			auto* entries = reinterpret_cast<hb::net::PacketMagicConfigEntry*>(buf + headerSize);
			uint16_t entriesInPacket = 0;
			int skipped = 0;

			for(int i = 0; i < DEF_MAXMAGICTYPE && entriesInPacket < maxEntriesPerPacket; i++) {
				if (m_pMagicConfigList[i] == 0) continue;
				if (skipped < magicsSent) { skipped++; continue; }

				const CMagic* magic = m_pMagicConfigList[i];
				auto& entry = entries[entriesInPacket];
				entry.magicId = static_cast<int16_t>(i);
				std::memset(entry.name, 0, sizeof(entry.name));
				std::strncpy(entry.name, magic->m_cName, sizeof(entry.name) - 1);
				entry.manaCost = magic->m_sValue1;
				entry.intLimit = magic->m_sIntLimit;
				entry.goldCost = magic->m_iGoldCost;
				entry.isVisible = (magic->m_iGoldCost >= 0) ? 1 : 0;
				entriesInPacket++;
			}

			pktHeader->magicCount = entriesInPacket;
			size_t packetSize = headerSize + (entriesInPacket * entrySize);

			uint16_t len = static_cast<uint16_t>(packetSize);
			const uint8_t* lenBytes = reinterpret_cast<const uint8_t*>(&len);
			allData.push_back(lenBytes[0]);
			allData.push_back(lenBytes[1]);
			allData.insert(allData.end(), reinterpret_cast<uint8_t*>(buf), reinterpret_cast<uint8_t*>(buf) + packetSize);

			magicsSent += entriesInPacket;
			packetIndex++;
		}
		m_dwConfigHash[1] = allData.empty() ? 0 : hb_crc32(allData.data(), allData.size());
	}

	// Compute CRC32 for skill configs
	{
		constexpr size_t headerSize = sizeof(hb::net::PacketSkillConfigHeader);
		constexpr size_t entrySize = sizeof(hb::net::PacketSkillConfigEntry);
		constexpr size_t maxEntriesPerPacket = (7000 - headerSize) / entrySize;

		std::vector<uint8_t> allData;
		int totalSkills = 0;
		for(int i = 0; i < DEF_MAXSKILLTYPE; i++) {
			if (m_pSkillConfigList[i] != 0) totalSkills++;
		}

		int skillsSent = 0;
		int packetIndex = 0;
		while (skillsSent < totalSkills) {
			char buf[7000]{};
			auto* pktHeader = reinterpret_cast<hb::net::PacketSkillConfigHeader*>(buf);
			pktHeader->header.msg_id = MSGID_SKILLCONFIGURATIONCONTENTS;
			pktHeader->header.msg_type = DEF_MSGTYPE_CONFIRM;
			pktHeader->totalSkills = static_cast<uint16_t>(totalSkills);
			pktHeader->packetIndex = static_cast<uint16_t>(packetIndex);

			auto* entries = reinterpret_cast<hb::net::PacketSkillConfigEntry*>(buf + headerSize);
			uint16_t entriesInPacket = 0;
			int skipped = 0;

			for(int i = 0; i < DEF_MAXSKILLTYPE && entriesInPacket < maxEntriesPerPacket; i++) {
				if (m_pSkillConfigList[i] == 0) continue;
				if (skipped < skillsSent) { skipped++; continue; }

				const CSkill* skill = m_pSkillConfigList[i];
				auto& entry = entries[entriesInPacket];
				entry.skillId = static_cast<int16_t>(i);
				std::memset(entry.name, 0, sizeof(entry.name));
				std::strncpy(entry.name, skill->m_cName, sizeof(entry.name) - 1);
				entry.isUseable = skill->m_bIsUseable ? 1 : 0;
				entry.useMethod = skill->m_cUseMethod;
				entriesInPacket++;
			}

			pktHeader->skillCount = entriesInPacket;
			size_t packetSize = headerSize + (entriesInPacket * entrySize);

			uint16_t len = static_cast<uint16_t>(packetSize);
			const uint8_t* lenBytes = reinterpret_cast<const uint8_t*>(&len);
			allData.push_back(lenBytes[0]);
			allData.push_back(lenBytes[1]);
			allData.insert(allData.end(), reinterpret_cast<uint8_t*>(buf), reinterpret_cast<uint8_t*>(buf) + packetSize);

			skillsSent += entriesInPacket;
			packetIndex++;
		}
		m_dwConfigHash[2] = allData.empty() ? 0 : hb_crc32(allData.data(), allData.size());
	}

	std::snprintf(G_cTxt, sizeof(G_cTxt), "Config hashes computed - Items: 0x%08X, Magic: 0x%08X, Skills: 0x%08X",
		m_dwConfigHash[0], m_dwConfigHash[1], m_dwConfigHash[2]);
	PutLogList(G_cTxt);
}

const DropTable* CGame::GetDropTable(int id) const
{
	if (id <= 0) {
		return nullptr;
	}
	auto it = m_DropTables.find(id);
	if (it == m_DropTables.end()) {
		return nullptr;
	}
	return &it->second;
}

int CGame::iComposeInitMapData(short sX, short sY, int iClientH, char* pData)
{
	int iSize, iTileExists;
	class CTile* pTile;
	unsigned char ucHeader;
	short* sp, * pTotal;
	uint16_t* wp;
	char* cp;
	uint32_t* dwp;

	if (m_pClientList[iClientH] == 0) return 0;

	pTotal = (short*)pData;
	cp = (char*)(pData + 2);

	iSize = 2;
	iTileExists = 0;

	for(int iy = 0; iy < DEF_INITDATA_TILES_Y; iy++)
		for(int ix = 0; ix < DEF_INITDATA_TILES_X; ix++) {

			if (((sX + ix) == 100) && ((sY + iy) == 100))
				sX = sX;

			pTile = (class CTile*)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + (sX + ix) + (sY + iy) * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

			//If player not same side and is invied (Beholder Hack)
			/*if ((m_pClientList[pTile->m_sOwner] != 0) && (pTile->m_sOwner != iClientH))
				if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
					(m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) &&
					(m_pClientList[pTile->m_sOwner]->m_status.bInvisibility)) {
					continue;
				}*/

			if ((pTile->m_sOwner != 0) || (pTile->m_sDeadOwner != 0) ||
				(pTile->m_pItem[0] != 0) || (pTile->m_sDynamicObjectType != 0)) {
				iTileExists++;
				sp = (short*)cp;
				*sp = ix;
				cp += 2;
				sp = (short*)cp;
				*sp = iy;
				cp += 2;
				iSize += 4;

				ucHeader = 0;
				if (pTile->m_sOwner != 0) {
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[pTile->m_sOwner] != 0) {
							// Skip admin-invisible players for lower/equal level viewers
							if (m_pClientList[pTile->m_sOwner]->m_bIsAdminInvisible &&
								pTile->m_sOwner != iClientH &&
								m_pClientList[iClientH]->m_iAdminLevel <= m_pClientList[pTile->m_sOwner]->m_iAdminLevel)
							{
								// Don't include this player in tile data
							}
							else
							{
								ucHeader = ucHeader | 0x01;
							}
						}
						else {
							// ###debugcode
							std::snprintf(G_cTxt, sizeof(G_cTxt), "Empty player handle: %d", pTile->m_sOwner);
							//PutLogFileList(G_cTxt);
							pTile->m_sOwner = 0;
						}
					}

					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sOwner] != 0) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = 0;
					}
				}
				if (pTile->m_sDeadOwner != 0) {
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = 0;
					}
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = 0;
					}
				}
				if (pTile->m_pItem[0] != 0)				ucHeader = ucHeader | 0x04;
				if (pTile->m_sDynamicObjectType != 0)    ucHeader = ucHeader | 0x08;
				*cp = ucHeader;
				cp++;
				iSize++;

				if ((ucHeader & 0x01) != 0) {
					switch (pTile->m_cOwnerClass) {
					case DEF_OWNERTYPE_PLAYER:
						// Object ID number(Player) : 1~10000
						sp = (short*)cp;
						*sp = pTile->m_sOwner;
						cp += 2;
						iSize += 2;
						// object type
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sOwner]->m_sType;
						cp += 2;
						iSize += 2;
						// dir
						*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
						cp++;
						iSize++;
						// Appearance
						std::memcpy(cp, &m_pClientList[pTile->m_sOwner]->m_appearance, sizeof(PlayerAppearance));
						cp += sizeof(PlayerAppearance);
						iSize += sizeof(PlayerAppearance);

						// Status
						{
							auto pktStatus = m_pClientList[pTile->m_sOwner]->m_status;
							pktStatus.bPK = (m_pClientList[pTile->m_sOwner]->m_iPKCount != 0) ? 1 : 0;
							pktStatus.bCitizen = (m_pClientList[pTile->m_sOwner]->m_cSide != 0) ? 1 : 0;
							pktStatus.bAresden = (m_pClientList[pTile->m_sOwner]->m_cSide == 1) ? 1 : 0;
							pktStatus.bHunter = m_pClientList[pTile->m_sOwner]->m_bIsPlayerCivil ? 1 : 0;
							pktStatus.iRelationship = GetPlayerRelationship(pTile->m_sOwner, iClientH);
							if (m_pClientList[pTile->m_sOwner]->m_bIsAdminInvisible) {
								pktStatus.bInvisibility = true;
								pktStatus.bGMMode = true;
							}
							std::memcpy(cp, &pktStatus, sizeof(PlayerStatus));
							cp += sizeof(PlayerStatus);
							iSize += sizeof(PlayerStatus);
						}
						// Name
						memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, DEF_CHARNAME - 1);
						cp += 10;
						iSize += 10;
						break;

					case DEF_OWNERTYPE_NPC:
						// Object ID number(NPC) : 10000~
						sp = (short*)cp;
						*sp = pTile->m_sOwner + 10000;
						cp += 2;
						iSize += 2;
						// object type
						sp = (short*)cp;
						*sp = m_pNpcList[pTile->m_sOwner]->m_sType;
						cp += 2;
						iSize += 2;
						// dir
						*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
						cp++;
						iSize++;
						// Appearance
						std::memcpy(cp, &m_pNpcList[pTile->m_sOwner]->m_appearance, sizeof(EntityAppearance));
						cp += sizeof(EntityAppearance);
						iSize += sizeof(EntityAppearance);
						// Status (with per-viewer NPC relationship)
						{
							auto npcStatus = m_pNpcList[pTile->m_sOwner]->m_status;
							npcStatus.iRelationship = m_pEntityManager->GetNpcRelationship(pTile->m_sOwner, iClientH);
							std::memcpy(cp, &npcStatus, sizeof(EntityStatus));
							cp += sizeof(EntityStatus);
							iSize += sizeof(EntityStatus);
						}
						// Name
						memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
						cp += 5;
						iSize += 5;
						break;
					}
				}

				if ((ucHeader & 0x02) != 0) {
					switch (pTile->m_cDeadOwnerClass) {
					case DEF_OWNERTYPE_PLAYER:
						// Object ID number : 1~10000
						sp = (short*)cp;
						*sp = pTile->m_sDeadOwner;
						cp += 2;
						iSize += 2;
						// object type
						sp = (short*)cp;
						*sp = m_pClientList[pTile->m_sDeadOwner]->m_sType;
						cp += 2;
						iSize += 2;
						// dir
						*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
						cp++;
						iSize++;
						// Appearance
						std::memcpy(cp, &m_pClientList[pTile->m_sDeadOwner]->m_appearance, sizeof(PlayerAppearance));
						cp += sizeof(PlayerAppearance);
						iSize += sizeof(PlayerAppearance);

						// Status
						{
							auto pktStatus = m_pClientList[pTile->m_sDeadOwner]->m_status;
							pktStatus.bPK = (m_pClientList[pTile->m_sDeadOwner]->m_iPKCount != 0) ? 1 : 0;
							pktStatus.bCitizen = (m_pClientList[pTile->m_sDeadOwner]->m_cSide != 0) ? 1 : 0;
							pktStatus.bAresden = (m_pClientList[pTile->m_sDeadOwner]->m_cSide == 1) ? 1 : 0;
							pktStatus.bHunter = m_pClientList[pTile->m_sDeadOwner]->m_bIsPlayerCivil ? 1 : 0;
							pktStatus.iRelationship = GetPlayerRelationship(pTile->m_sDeadOwner, iClientH);
							std::memcpy(cp, &pktStatus, sizeof(PlayerStatus));
							cp += sizeof(PlayerStatus);
							iSize += sizeof(PlayerStatus);
						}
						// Name
						memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, DEF_CHARNAME - 1);
						cp += 10;
						iSize += 10;
						break;

					case DEF_OWNERTYPE_NPC:
						// Object ID number : 10000	~
						sp = (short*)cp;
						*sp = pTile->m_sDeadOwner + 10000;
						cp += 2;
						iSize += 2;
						// object type
						sp = (short*)cp;
						*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sType;
						cp += 2;
						iSize += 2;
						// dir
						*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
						cp++;
						iSize++;
						// Appearance
						std::memcpy(cp, &m_pNpcList[pTile->m_sDeadOwner]->m_appearance, sizeof(EntityAppearance));
						cp += sizeof(EntityAppearance);
						iSize += sizeof(EntityAppearance);
						// Status (with per-viewer NPC relationship)
						{
							auto npcStatus = m_pNpcList[pTile->m_sDeadOwner]->m_status;
							npcStatus.iRelationship = m_pEntityManager->GetNpcRelationship(pTile->m_sDeadOwner, iClientH);
							std::memcpy(cp, &npcStatus, sizeof(EntityStatus));
							cp += sizeof(EntityStatus);
							iSize += sizeof(EntityStatus);
						}
						// Name
						memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
						cp += 5;
						iSize += 5;
						break;
					}
				}

				if (pTile->m_pItem[0] != 0) {
					// Centu - id num
					sp = (short*)cp;
					*sp = pTile->m_pItem[0]->m_sIDnum;
					cp += 2;
					iSize += 2;

					*cp = pTile->m_pItem[0]->m_cItemColor;
					cp++;
					iSize++;

					// Centu - attribute
					dwp = (uint32_t*)cp;
					*dwp = pTile->m_pItem[0]->m_dwAttribute;
					cp += 4;
					iSize += 4;
				}

				if (pTile->m_sDynamicObjectType != 0) {
					wp = (uint16_t*)cp;
					*wp = pTile->m_wDynamicObjectID;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = pTile->m_sDynamicObjectType;
					cp += 2;
					iSize += 2;
				}
			} // Big if
		} // while(1)

	*pTotal = iTileExists;
	return iSize;
}

void CGame::DeleteClient(int iClientH, bool bSave, bool bNotify, bool bCountLogout, bool bForceCloseConn)
{
	int iExH;
	char* cp, cData[120], cTmpMap[30];
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Char(%s)-Exit(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
			PutLogEventFileList(G_cTxt);
		}

		if (m_pClientList[iClientH]->m_bIsExchangeMode) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		if ((m_pClientList[iClientH]->m_iAllocatedFish != 0) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != 0))
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		if (bNotify)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, 0, 0, 0);

		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

		// Delete all summoned NPCs belonging to this player
		for (int i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != 0) {
				if ((m_pNpcList[i]->m_bIsSummoned) &&
					(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
					(m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER)) {
					m_pEntityManager->DeleteEntity(i);
				}
			}

		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iWhisperPlayerIndex == iClientH)) {
				m_pClientList[i]->m_iWhisperPlayerIndex = -1;
				SendNotifyMsg(0, i, DEF_NOTIFY_WHISPERMODEOFF, 0, 0, 0, m_pClientList[iClientH]->m_cCharName);
			}


		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
			m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY);

		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, 0);
	}

	if ((bSave) && (m_pClientList[iClientH]->m_bIsOnServerChange == false)) {

		if (m_pClientList[iClientH]->m_bIsKilled) {
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);

			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));

			if (m_pClientList[iClientH]->m_cSide == 0) {
				strcpy(m_pClientList[iClientH]->m_cMapName, "default");
			}
			else {
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
					if (m_bIsCrusadeMode) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
							m_pClientList[iClientH]->m_iLockedMapTime = 60 * 5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						}
					}

					if (strcmp(cTmpMap, "elvine") == 0) {
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60 * 3;
						memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					}
					else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
				}
				else {
					if (m_bIsCrusadeMode) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
							m_pClientList[iClientH]->m_iLockedMapTime = 60 * 5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
						}
					}
					if (strcmp(cTmpMap, "aresden") == 0) {
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60 * 3;
						memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);

					}
					else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
				}
			}
		}
		else if (bForceCloseConn) {
			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, "bisle", 5);
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
			strcpy(m_pClientList[iClientH]->m_cLockedMapName, "bisle");
			m_pClientList[iClientH]->m_iLockedMapTime = 10 * 60;
		}

		if (m_pClientList[iClientH]->m_bIsObserverMode) {
			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1, 2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1, 2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (m_pClientList[iClientH]->m_bIsInitComplete) {
			if (m_pClientList[iClientH]->m_iPartyID != 0) {
				std::memset(cData, 0, sizeof(cData));
				cp = (char*)cData;

				/*dwp = (uint32_t *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;*/

				wp = (uint16_t*)cp;
				*wp = 4;
				cp += 2;

				wp = (uint16_t*)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
				cp += 10;

				wp = (uint16_t*)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PartyOperation(cData);;
			}
			//if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == false) LocalSavePlayerData(iClientH);
		}
		g_login->LocalSavePlayerData(iClientH); //else bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
	}
	else {
		if (m_pClientList[iClientH]->m_bIsOnServerChange == false) {
			if (m_pClientList[iClientH]->m_iPartyID != 0) {
				std::memset(cData, 0, sizeof(cData));
				cp = (char*)cData;

				/*dwp = (uint32_t *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;*/

				wp = (uint16_t*)cp;
				*wp = 4;
				cp += 2;

				wp = (uint16_t*)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
				cp += 10;

				wp = (uint16_t*)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PartyOperation(cData);;
			}

			//bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}
		else {
			if (m_pClientList[iClientH]->m_iPartyID != 0) {
				std::memset(cData, 0, sizeof(cData));
				cp = (char*)cData;

				/*dwp = (uint32_t *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;*/

				wp = (uint16_t*)cp;
				*wp = 7;
				cp += 2;

				wp = (uint16_t*)cp;
				*wp = 0;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
				cp += 10;

				wp = (uint16_t*)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				PartyOperation(cData);;
			}

			//bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, false); 
		}
	}

	if (m_pClientList[iClientH]->m_iPartyID != 0) {
		for(int i = 0; i < hb::limits::MaxPartyMembers; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
				m_pClientList[iClientH]->m_iPartyID = 0;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
				std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d Out(Delete) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto DC_LOOPBREAK1;
			}
	DC_LOOPBREAK1:
		for(int i = 0; i < hb::limits::MaxPartyMembers - 1; i++)
			if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1] != 0)) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1];
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1] = 0;
			}
	}


	m_iTotalClients--;

	// Cancel async operations before freeing the socket
	if (m_pClientList[iClientH]->m_pXSock != 0)
		m_pClientList[iClientH]->m_pXSock->CancelAsync();

	delete m_pClientList[iClientH];
	m_pClientList[iClientH] = 0;

	RemoveClientShortCut(iClientH);
}


void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, uint32_t dwMsgID, uint16_t wMsgType, short sV1, short sV2, short sV3)
{
	int iRet, iShortCutIndex;
	bool bFlag;
	int sRange;
	short sX, sY;
	bool cOwnerSend;

	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) ||
		(wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		sRange = DEF_VIEWRANGE_BUFFER;
	else sRange = 0;

	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sOwnerH] == 0) return;

		sX = m_pClientList[sOwnerH]->m_sX;
		sY = m_pClientList[sOwnerH]->m_sY;

		switch (wMsgType) {
		case DEF_OBJECTNULLACTION:
		case DEF_OBJECTDAMAGE:
		case DEF_OBJECTDYING:
		case DEF_MSGTYPE_CONFIRM:
			cOwnerSend = true;
			break;
		default:
			cOwnerSend = false;
			break;
		}

		hb::net::PacketEventMotionPlayer base_all{};
		base_all.header.msg_id = dwMsgID;
		base_all.header.msg_type = wMsgType;
		base_all.object_id = static_cast<std::uint16_t>(sOwnerH);
		base_all.x = sX;
		base_all.y = sY;
		base_all.type = m_pClientList[sOwnerH]->m_sType;
		base_all.dir = static_cast<std::uint8_t>(m_pClientList[sOwnerH]->m_cDir);
		std::memcpy(base_all.name, m_pClientList[sOwnerH]->m_cCharName, sizeof(base_all.name));
		base_all.appearance = m_pClientList[sOwnerH]->m_appearance;
		base_all.status = m_pClientList[sOwnerH]->m_status;
		base_all.loc = 0;
		if (wMsgType == DEF_OBJECTNULLACTION) {
			base_all.loc = m_pClientList[sOwnerH]->m_bIsKilled ? 1 : 0;
		}

		hb::net::PacketEventMotionShort pkt_short{};
		pkt_short.header.msg_id = dwMsgID;
		pkt_short.header.msg_type = wMsgType;
		pkt_short.object_id = static_cast<std::uint16_t>(sOwnerH + 30000);
		pkt_short.dir = static_cast<std::uint8_t>(m_pClientList[sOwnerH]->m_cDir);
		pkt_short.v1 = static_cast<std::int16_t>(sV1);
		pkt_short.v2 = static_cast<std::uint8_t>(sV2);

		hb::net::PacketEventMotionMove pkt_move{};
		pkt_move.header.msg_id = dwMsgID;
		pkt_move.header.msg_type = wMsgType;
		pkt_move.object_id = static_cast<std::uint16_t>(sOwnerH + 30000);
		pkt_move.dir = static_cast<std::uint8_t>(m_pClientList[sOwnerH]->m_cDir);
		pkt_move.v1 = static_cast<std::uint8_t>(sV1);
		pkt_move.v2 = static_cast<std::uint8_t>(sV2);
		pkt_move.x = sX;
		pkt_move.y = sY;

		hb::net::PacketEventMotionAttack pkt_attack{};
		pkt_attack.header.msg_id = dwMsgID;
		pkt_attack.header.msg_type = wMsgType;
		pkt_attack.object_id = static_cast<std::uint16_t>(sOwnerH + 30000);
		pkt_attack.dir = static_cast<std::uint8_t>(m_pClientList[sOwnerH]->m_cDir);
		pkt_attack.v1 = static_cast<std::int8_t>(sV1 - sX);
		pkt_attack.v2 = static_cast<std::int8_t>(sV2 - sY);
		pkt_attack.v3 = static_cast<std::int16_t>(sV3);

		hb::net::PacketEventMotionDirOnly pkt_dir{};
		pkt_dir.header.msg_id = dwMsgID;
		pkt_dir.header.msg_type = wMsgType;
		pkt_dir.object_id = static_cast<std::uint16_t>(sOwnerH + 30000);
		pkt_dir.dir = static_cast<std::uint8_t>(m_pClientList[sOwnerH]->m_cDir);

		// Per-viewer status filtering is handled at packet build time

		const char cKey = static_cast<char>((rand() % 255) + 1);

		bFlag = true;
		iShortCutIndex = 0;

		while (bFlag) {
			int i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = false;

			if ((bFlag) && (m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete))
				if ((m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - DEF_VIEWRANGE_X - sRange) &&
					(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + DEF_VIEWRANGE_X + sRange) &&
					(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - DEF_VIEWRANGE_Y - sRange) &&
					(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + DEF_VIEWRANGE_Y + sRange)) {

					// Admin invisibility filtering: skip clients that shouldn't see this player
					if (m_pClientList[sOwnerH]->m_bIsAdminInvisible && i != sOwnerH &&
						m_pClientList[i]->m_iAdminLevel <= m_pClientList[sOwnerH]->m_iAdminLevel)
					{
						// Don't send any packet to this client
					}
					else
					{

					auto pkt_all = base_all;
					{
						auto viewerStatus = m_pClientList[sOwnerH]->m_status;
						viewerStatus.bPK = (m_pClientList[sOwnerH]->m_iPKCount != 0) ? 1 : 0;
						viewerStatus.bCitizen = (m_pClientList[sOwnerH]->m_cSide != 0) ? 1 : 0;
						viewerStatus.bAresden = (m_pClientList[sOwnerH]->m_cSide == 1) ? 1 : 0;
						viewerStatus.bHunter = m_pClientList[sOwnerH]->m_bIsPlayerCivil ? 1 : 0;
						viewerStatus.iRelationship = GetPlayerRelationship(sOwnerH, i);
						if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide && i != sOwnerH) {
							viewerStatus.bPoisoned = false;
							viewerStatus.bIllusion = false;
						}
						if (m_pClientList[sOwnerH]->m_bIsAdminInvisible) {
							viewerStatus.bInvisibility = true;
							viewerStatus.bGMMode = true;
						}
						pkt_all.status = viewerStatus;
					}

					auto send_packet = [&](const void* packet, std::size_t size) -> int {
						return m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(const_cast<void*>(packet)), static_cast<int>(size), cKey);
						};

					const bool is_near = (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - (DEF_VIEWCENTER_X - 1)) &&
						(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + (DEF_VIEWCENTER_X - 1)) &&
						(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - DEF_VIEWCENTER_Y) &&
						(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + DEF_VIEWCENTER_Y);

					if (is_near) {
						switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							if (cOwnerSend)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							if (cOwnerSend)
								iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							break;

						case DEF_OBJECTMAGIC:
						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							if (cOwnerSend)
								iRet = send_packet(&pkt_short, sizeof(pkt_short));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_short, sizeof(pkt_short));
							break;

						case DEF_OBJECTDYING:
							if (cOwnerSend)
								iRet = send_packet(&pkt_move, sizeof(pkt_move));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_move, sizeof(pkt_move));
							break;

						default:
							if (cOwnerSend)
								iRet = send_packet(&pkt_dir, sizeof(pkt_dir));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_dir, sizeof(pkt_dir));
							break;
						}
					}
					else {
						switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							if (cOwnerSend)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							if (cOwnerSend)
								iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							break;

						case DEF_OBJECTMAGIC:
						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							if (cOwnerSend)
								iRet = send_packet(&pkt_short, sizeof(pkt_short));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_short, sizeof(pkt_short));
							break;

						case DEF_OBJECTDYING:
							if (cOwnerSend)
								iRet = send_packet(&pkt_move, sizeof(pkt_move));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_move, sizeof(pkt_move));
							break;

						default:
							if (cOwnerSend)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							else if (i != sOwnerH)
								iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;
						}

						if ((iRet == DEF_XSOCKEVENT_QUENEFULL) || (iRet == DEF_XSOCKEVENT_SOCKETERROR) ||
							(iRet == DEF_XSOCKEVENT_SOCKETCLOSED) || (iRet == DEF_XSOCKEVENT_CRITICALERROR)) {
							static uint32_t s_dwLastNetWarn = 0;
							uint32_t dwNow = GameClock::GetTimeMS();
							if (dwNow - s_dwLastNetWarn > 5000) {
								std::snprintf(G_cTxt, sizeof(G_cTxt), "[NETWARN] SendEventToNearClient_TypeA: client=%d ret=%d ownerType=%d msgType=0x%X",
									i, iRet, cOwnerType, wMsgType);
								PutLogList(G_cTxt);
								s_dwLastNetWarn = dwNow;
							}
						}
					}
					} // end admin invis else
				}
		}
	}
	else {
		if (m_pNpcList[sOwnerH] == 0) return;

		sX = m_pNpcList[sOwnerH]->m_sX;
		sY = m_pNpcList[sOwnerH]->m_sY;

		hb::net::PacketEventMotionNpc base_all{};
		base_all.header.msg_id = dwMsgID;
		base_all.header.msg_type = wMsgType;
		base_all.object_id = static_cast<std::uint16_t>(sOwnerH + 10000);
		base_all.x = sX;
		base_all.y = sY;
		base_all.type = m_pNpcList[sOwnerH]->m_sType;
		base_all.dir = static_cast<std::uint8_t>(m_pNpcList[sOwnerH]->m_cDir);
		std::memcpy(base_all.name, m_pNpcList[sOwnerH]->m_cName, sizeof(base_all.name));
		base_all.appearance = m_pNpcList[sOwnerH]->m_appearance;
		base_all.status = m_pNpcList[sOwnerH]->m_status;
		base_all.loc = 0;
		if (wMsgType == DEF_OBJECTNULLACTION) {
			base_all.loc = m_pNpcList[sOwnerH]->m_bIsKilled ? 1 : 0;
		}

		hb::net::PacketEventMotionShort pkt_short{};
		pkt_short.header.msg_id = dwMsgID;
		pkt_short.header.msg_type = wMsgType;
		pkt_short.object_id = static_cast<std::uint16_t>(sOwnerH + 40000);
		pkt_short.dir = static_cast<std::uint8_t>(m_pNpcList[sOwnerH]->m_cDir);
		pkt_short.v1 = static_cast<std::int16_t>(sV1);
		pkt_short.v2 = static_cast<std::uint8_t>(sV2);

		hb::net::PacketEventMotionMove pkt_move{};
		pkt_move.header.msg_id = dwMsgID;
		pkt_move.header.msg_type = wMsgType;
		pkt_move.object_id = static_cast<std::uint16_t>(sOwnerH + 40000);
		pkt_move.dir = static_cast<std::uint8_t>(m_pNpcList[sOwnerH]->m_cDir);
		pkt_move.v1 = static_cast<std::uint8_t>(sV1);
		pkt_move.v2 = static_cast<std::uint8_t>(sV2);
		pkt_move.x = sX;
		pkt_move.y = sY;

		hb::net::PacketEventMotionAttack pkt_attack{};
		pkt_attack.header.msg_id = dwMsgID;
		pkt_attack.header.msg_type = wMsgType;
		pkt_attack.object_id = static_cast<std::uint16_t>(sOwnerH + 40000);
		pkt_attack.dir = static_cast<std::uint8_t>(m_pNpcList[sOwnerH]->m_cDir);
		pkt_attack.v1 = static_cast<std::int8_t>(sV1 - sX);
		pkt_attack.v2 = static_cast<std::int8_t>(sV2 - sY);
		pkt_attack.v3 = static_cast<std::int16_t>(sV3);

		hb::net::PacketEventMotionDirOnly pkt_dir{};
		pkt_dir.header.msg_id = dwMsgID;
		pkt_dir.header.msg_type = wMsgType;
		pkt_dir.object_id = static_cast<std::uint16_t>(sOwnerH + 40000);
		pkt_dir.dir = static_cast<std::uint8_t>(m_pNpcList[sOwnerH]->m_cDir);

		const char cKey = static_cast<char>((rand() % 255) + 1);

		bFlag = true;
		iShortCutIndex = 0;

		while (bFlag) {

			int i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = false;

			if ((bFlag) && (m_pClientList[i] != 0))

				if ((m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - DEF_VIEWRANGE_X - sRange) &&
					(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + DEF_VIEWRANGE_X + sRange) &&
					(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - DEF_VIEWRANGE_Y - sRange) &&
					(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + DEF_VIEWRANGE_Y + sRange)) {

					auto pkt_all = base_all;
					pkt_all.status.iRelationship = m_pEntityManager->GetNpcRelationship(sOwnerH, i);

					auto send_packet = [&](const void* packet, std::size_t size) -> int {
						return m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(const_cast<void*>(packet)), static_cast<int>(size), cKey);
						};

					const bool is_near = (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - (DEF_VIEWCENTER_X - 1)) &&
						(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + (DEF_VIEWCENTER_X - 1)) &&
						(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - DEF_VIEWCENTER_Y) &&
						(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + DEF_VIEWCENTER_Y);

					if (is_near) {
						switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						case DEF_OBJECTSTOP:
							iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						case DEF_OBJECTDYING:
							iRet = send_packet(&pkt_move, sizeof(pkt_move));
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = send_packet(&pkt_short, sizeof(pkt_short));
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							break;

						case DEF_OBJECTMOVE:
						case DEF_OBJECTRUN:
							// Send full position data to prevent desync for nearby players
							iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						default:
							iRet = send_packet(&pkt_dir, sizeof(pkt_dir));
							break;

						}

						if ((iRet == DEF_XSOCKEVENT_QUENEFULL) || (iRet == DEF_XSOCKEVENT_SOCKETERROR) ||
							(iRet == DEF_XSOCKEVENT_SOCKETCLOSED) || (iRet == DEF_XSOCKEVENT_CRITICALERROR)) {
							static uint32_t s_dwLastNetWarnNpc = 0;
							uint32_t dwNow = GameClock::GetTimeMS();
							if (dwNow - s_dwLastNetWarnNpc > 5000) {
								std::snprintf(G_cTxt, sizeof(G_cTxt), "[NETWARN] SendEventToNearClient_TypeA(NPC): client=%d ret=%d ownerType=%d msgType=0x%X",
									i, iRet, cOwnerType, wMsgType);
								PutLogList(G_cTxt);
								s_dwLastNetWarnNpc = dwNow;
							}
						}
					}
					else {
						switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						case DEF_OBJECTDYING:
							iRet = send_packet(&pkt_move, sizeof(pkt_move));
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = send_packet(&pkt_short, sizeof(pkt_short));
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = send_packet(&pkt_attack, sizeof(pkt_attack));
							break;

						default:
							iRet = send_packet(&pkt_all, sizeof(pkt_all));
							break;

						} //Switch

						if ((iRet == DEF_XSOCKEVENT_QUENEFULL) || (iRet == DEF_XSOCKEVENT_SOCKETERROR) ||
							(iRet == DEF_XSOCKEVENT_SOCKETCLOSED) || (iRet == DEF_XSOCKEVENT_CRITICALERROR)) {
							static uint32_t s_dwLastNetWarnNpcFar = 0;
							uint32_t dwNow = GameClock::GetTimeMS();
							if (dwNow - s_dwLastNetWarnNpcFar > 5000) {
								std::snprintf(G_cTxt, sizeof(G_cTxt), "[NETWARN] SendEventToNearClient_TypeA(NPC-far): client=%d ret=%d ownerType=%d msgType=0x%X",
									i, iRet, cOwnerType, wMsgType);
								PutLogList(G_cTxt);
								s_dwLastNetWarnNpcFar = dwNow;
							}
						}
					}
				}
		}
	} // else - NPC
}


int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char* pData)
{
	int ix, iy, iSize, iTileExists, iIndex;
	class CTile* pTile;
	unsigned char ucHeader;
	short* sp, * pTotal;
	uint16_t* wp;
	char* cp;
	uint32_t* dwp;

	if (m_pClientList[iClientH] == 0) return 0;

	pTotal = (short*)pData;
	cp = (char*)(pData + 2);

	iSize = 2;
	iTileExists = 0;

	iIndex = 0;

	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;

		iIndex++;

		pTile = (class CTile*)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + (sX + ix) + (sY + iy) * m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		//If player not same side and is invied (Beholder Hack)
		// there is another person on the tiles, and the owner is not the player
//xxxxxx
		/*if ((m_pClientList[pTile->m_sOwner] != 0) && (pTile->m_sOwner != iClientH))
			if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
				(m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) &&
				(m_pClientList[pTile->m_sOwner]->m_status.bInvisibility)) {
				continue;
			}*/

		if ((pTile->m_sOwner != 0) || (pTile->m_sDeadOwner != 0) ||
			(pTile->m_pItem[0] != 0) || (pTile->m_sDynamicObjectType != 0)) {

			iTileExists++;

			sp = (short*)cp;
			*sp = ix;
			cp += 2;
			sp = (short*)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;

			ucHeader = 0;

			if (pTile->m_sOwner != 0) {
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[pTile->m_sOwner] != 0) {
						// Skip admin-invisible players for lower/equal level viewers
						if (m_pClientList[pTile->m_sOwner]->m_bIsAdminInvisible &&
							pTile->m_sOwner != iClientH &&
							m_pClientList[iClientH]->m_iAdminLevel <= m_pClientList[pTile->m_sOwner]->m_iAdminLevel)
						{
							// Don't include this player in tile data
						}
						else
						{
							ucHeader = ucHeader | 0x01;
						}
					}
					else pTile->m_sOwner = 0;
				}
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
					if (m_pNpcList[pTile->m_sOwner] != 0) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = 0;
				}
			}
			if (pTile->m_sDeadOwner != 0) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[pTile->m_sDeadOwner] != 0)	ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = 0;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) {
					if (m_pNpcList[pTile->m_sDeadOwner] != 0) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = 0;
				}
			}

			if (pTile->m_pItem[0] != 0)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != 0)    ucHeader = ucHeader | 0x08;

			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					sp = (short*)cp;
					*sp = pTile->m_sOwner;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;

					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;

					// Appearance
					std::memcpy(cp, &m_pClientList[pTile->m_sOwner]->m_appearance, sizeof(PlayerAppearance));
					cp += sizeof(PlayerAppearance);
					iSize += sizeof(PlayerAppearance);

					{
						auto pktStatus = m_pClientList[pTile->m_sOwner]->m_status;
						pktStatus.bPK = (m_pClientList[pTile->m_sOwner]->m_iPKCount != 0) ? 1 : 0;
						pktStatus.bCitizen = (m_pClientList[pTile->m_sOwner]->m_cSide != 0) ? 1 : 0;
						pktStatus.bAresden = (m_pClientList[pTile->m_sOwner]->m_cSide == 1) ? 1 : 0;
						pktStatus.bHunter = m_pClientList[pTile->m_sOwner]->m_bIsPlayerCivil ? 1 : 0;
						pktStatus.iRelationship = GetPlayerRelationship(pTile->m_sOwner, iClientH);
						if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sOwner]->m_cSide && iClientH != pTile->m_sOwner) {
							pktStatus.bPoisoned = false;
							pktStatus.bIllusion = false;
						}
						if (m_pClientList[pTile->m_sOwner]->m_bIsAdminInvisible) {
							pktStatus.bInvisibility = true;
							pktStatus.bGMMode = true;
						}
						std::memcpy(cp, &pktStatus, sizeof(PlayerStatus));
						cp += sizeof(PlayerStatus);
						iSize += sizeof(PlayerStatus);
					}

					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, DEF_CHARNAME - 1);
					cp += 10;
					iSize += 10;
					break;

				case DEF_OWNERTYPE_NPC:
					sp = (short*)cp;
					*sp = pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;

					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;

					// NPC Appearance
					std::memcpy(cp, &m_pNpcList[pTile->m_sOwner]->m_appearance, sizeof(EntityAppearance));
					cp += sizeof(EntityAppearance);
					iSize += sizeof(EntityAppearance);

					{
						auto npcStatus = m_pNpcList[pTile->m_sOwner]->m_status;
						npcStatus.iRelationship = m_pEntityManager->GetNpcRelationship(pTile->m_sOwner, iClientH);
						std::memcpy(cp, &npcStatus, sizeof(EntityStatus));
						cp += sizeof(EntityStatus);
						iSize += sizeof(EntityStatus);
					}

					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp += 5;
					iSize += 5;
				}//end switch
			}// if ((ucHeader & 0x01) != 0)

			if ((ucHeader & 0x02) != 0) {
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:

					sp = (short*)cp;
					*sp = pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;

					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;

					// Appearance
					std::memcpy(cp, &m_pClientList[pTile->m_sDeadOwner]->m_appearance, sizeof(PlayerAppearance));
					cp += sizeof(PlayerAppearance);
					iSize += sizeof(PlayerAppearance);

					{
						auto pktStatus = m_pClientList[pTile->m_sDeadOwner]->m_status;
						pktStatus.bPK = (m_pClientList[pTile->m_sDeadOwner]->m_iPKCount != 0) ? 1 : 0;
						pktStatus.bCitizen = (m_pClientList[pTile->m_sDeadOwner]->m_cSide != 0) ? 1 : 0;
						pktStatus.bAresden = (m_pClientList[pTile->m_sDeadOwner]->m_cSide == 1) ? 1 : 0;
						pktStatus.bHunter = m_pClientList[pTile->m_sDeadOwner]->m_bIsPlayerCivil ? 1 : 0;
						pktStatus.iRelationship = GetPlayerRelationship(pTile->m_sDeadOwner, iClientH);
						if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sDeadOwner]->m_cSide && iClientH != pTile->m_sDeadOwner) {
							pktStatus.bPoisoned = false;
							pktStatus.bIllusion = false;
						}
						std::memcpy(cp, &pktStatus, sizeof(PlayerStatus));
						cp += sizeof(PlayerStatus);
						iSize += sizeof(PlayerStatus);
					}

					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, DEF_CHARNAME - 1);
					cp += 10;
					iSize += 10;
					break;

				case DEF_OWNERTYPE_NPC:
					sp = (short*)cp;
					*sp = pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;

					sp = (short*)cp;
					*sp = m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;

					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;

					// NPC Appearance
					std::memcpy(cp, &m_pNpcList[pTile->m_sDeadOwner]->m_appearance, sizeof(EntityAppearance));
					cp += sizeof(EntityAppearance);
					iSize += sizeof(EntityAppearance);

					{
						auto npcStatus = m_pNpcList[pTile->m_sDeadOwner]->m_status;
						npcStatus.iRelationship = m_pEntityManager->GetNpcRelationship(pTile->m_sDeadOwner, iClientH);
						std::memcpy(cp, &npcStatus, sizeof(EntityStatus));
						cp += sizeof(EntityStatus);
						iSize += sizeof(EntityStatus);
					}

					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp += 5;
					iSize += 5;
					break;
				}//End Switch
			}// if ((ucHeader & 0x02) != 0)

			if (pTile->m_pItem[0] != 0) {
				sp = (short*)cp;
				*sp = pTile->m_pItem[0]->m_sIDnum;
				cp += 2;
				iSize += 2;

				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;

				dwp = (uint32_t*)cp;
				*dwp = pTile->m_pItem[0]->m_dwAttribute;
				cp += 4;
				iSize += 4;
			}

			if (pTile->m_sDynamicObjectType != 0) {

				wp = (uint16_t*)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;

				sp = (short*)cp;
				*sp = pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			} //(pTile->m_sDynamicObjectType != 0)

		} //(pTile->m_sOwner != 0)
	} // end While(1)
	*pTotal = iTileExists;
	return iSize;
}

void CGame::CheckClientResponseTime()
{
	int iPlusTime, iMaxSuperAttack, iValue;
	uint32_t dwTime;
	short sItemIndex;
	static uint32_t s_dwLastIdleLog = 0;
	//locobans
	//int iMapside, iMapside2;
	//SYSTEMTIME SysTime;

	   /*
	   GetLocalTime(&SysTime);
	   switch (SysTime.wDayOfWeek) {
	   case 1:	iWarPeriod = 30; break;
	   case 2:	iWarPeriod = 30; break;
	   case 3:	iWarPeriod = 60; break;
	   case 4:	iWarPeriod = 60*2;  break;
	   case 5:	iWarPeriod = 60*5;  break;
	   case 6:	iWarPeriod = 60*10; break;
	   case 0:	iWarPeriod = 60*20; break;
	   }
	   */

	dwTime = GameClock::GetTimeMS();

	for(int i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {

			if ((dwTime - m_pClientList[i]->m_dwTime) > (uint32_t)m_iClientTimeout) {
				if (m_pClientList[i]->m_bIsInitComplete) {
					//Testcode
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Client Timeout: %s", m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);

					DeleteClient(i, true, true);
				}
				else if ((dwTime - m_pClientList[i]->m_dwTime) > (uint32_t)m_iClientTimeout) {
					DeleteClient(i, false, false);
				}
			}
			else if (m_pClientList[i]->m_bIsInitComplete) {
				uint32_t dwIdle = dwTime - m_pClientList[i]->m_dwTime;
				if (dwIdle > 5000 && (dwTime - m_pClientList[i]->m_dwLastMsgTime) > 5000 &&
					(dwTime - s_dwLastIdleLog) > 5000) {
					std::snprintf(G_cTxt, sizeof(G_cTxt),
						"[NET] IDLE slot=%d idle=%ums lastmsg=0x%08X lastage=%ums size=%zu char=%s ip=%s",
						i, dwIdle, m_pClientList[i]->m_dwLastMsgId,
						dwTime - m_pClientList[i]->m_dwLastMsgTime,
						m_pClientList[i]->m_dwLastMsgSize,
						m_pClientList[i]->m_cCharName,
						m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);
					s_dwLastIdleLog = dwTime;
				}

				// AFK detection: 3 minutes of no meaningful activity
				constexpr uint32_t AFK_TIMEOUT_MS = 180000;
				bool bWasAfk = m_pClientList[i]->m_status.bAfk;
				bool bNowAfk = (dwTime - m_pClientList[i]->m_dwAfkActivityTime) > AFK_TIMEOUT_MS;
				if (bWasAfk != bNowAfk) {
					m_pClientList[i]->m_status.bAfk = bNowAfk;
					SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER,
						MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
				}

				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;

				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > (uint32_t)m_iHungerConsumeInterval) && (m_pClientList[i]->m_bIsKilled == false)) {
					m_pClientList[i]->m_iHungerStatus--;
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;

					SendNotifyMsg(0, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, 0, 0, 0);
				}

				if (_bCheckCharacterData(i) == false) {
					DeleteClient(i, true, true);
					break;
				}

				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0))
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus) * 1000;
				else iPlusTime = 0;

				iPlusTime = abs(iPlusTime);

				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (uint32_t)(m_iHealthRegenInterval + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}

				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (uint32_t)(m_iManaRegenInterval + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}

				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (uint32_t)(m_iStaminaRegenInterval + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}

				if ((m_pClientList[i]->m_bIsPoisoned) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > (uint32_t)m_iPoisonDamageInterval)) {
					PoisonEffect(i, 0);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}

				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == false) &&
					((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (uint32_t)m_iAutosaveInterval)) {
					g_login->LocalSavePlayerData(i); //bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
					m_pClientList[i]->m_dwAutoSaveTime = dwTime;
				}

				// ExpStock
				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (uint32_t)DEF_EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
					CheckHeldenianResultCalculation(i);
				}

				// AutoExe
				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (uint32_t)DEF_AUTOEXPTIME) {
					iValue = (m_pClientList[i]->m_iLevel / 2);
					if (iValue <= 0) iValue = 1;
					uint32_t iValueDw = static_cast<uint32_t>(iValue);
					if (m_pClientList[i]->m_iAutoExpAmount < iValueDw) {
						if ((m_pClientList[i]->m_iExp + iValueDw) < m_iLevelExpTable[m_pClientList[i]->m_iLevel + 1]) {
							//m_pClientList[i]->m_iExpStock += iValue;
							GetExp(i, iValueDw, false);
							CalcExpStock(i);
						}
					}

					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}

				// v1.432
				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					SendNotifyMsg(0, i, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, 0);
					// New 25/05/2004
					// After the time up, add magic back
					sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
					if (sItemIndex != -1) {
						if ((m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
							if ((m_pClientList[i]->m_iInt + m_pClientList[i]->m_iAngelicInt) > 99 && (m_pClientList[i]->m_iMag + m_pClientList[i]->m_iAngelicMag) > 99) {
								m_pClientList[i]->m_cMagicMastery[94] = true;
								SendNotifyMsg(0, i, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
							}
						}
					}
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;

				// v1.432
				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled) {
					uint32_t elapsedSec = (dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime) / 1000;
					if (elapsedSec > static_cast<uint32_t>(m_pClientList[i]->m_iSpecialAbilityLastSec)) {
						SendNotifyMsg(0, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, 0, 0, 0);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = false;
						m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
						m_pClientList[i]->m_appearance.iEffectType = 0;
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}
				}

				//Crusade
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					m_pClientList[i]->m_iLockedMapTime = 0;
					std::memset(m_pClientList[i]->m_cLockedMapName, 0, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}

				// v2.04
				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;

				if ((m_pClientList[i]->m_bIsWarLocation) && IsEnemyZone(i)) {
					// Crusade
					if (m_bIsCrusadeMode == false)
						if (m_pClientList[i]->m_bIsInsideOwnTown == false)
							m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_dwWarBeginTime = dwTime;
						m_pClientList[i]->m_bIsWarLocation = false;

						SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
						RequestTeleportHandler(i, "1   ");
					}
				}

				if ((m_bIsHeldenianMode) && (m_pMapList[m_pClientList[i]->m_cMapIndex] != 0)) {
					if (bCheckHeldenianMap(i, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, true);
					}
					else {
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, false);
					}
				}

				if (m_pClientList[i] == 0) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) {
					// std::snprintf(G_cTxt, sizeof(G_cTxt), "(!)  (%s)  ", m_pClientList[i]->m_cCharName);
					//PutLogFileList(G_cTxt);
					DeleteClient(i, true, true);
				}
				else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				if (m_pClientList[i] == 0) break;
				//if (m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) {
				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == 0) break;
				//if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
				//	 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) ) {
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
					(m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					if (m_pClientList[i]->m_cSide == 1) {
						RequestTeleportHandler(i, "2   ", "aresden", -1, -1);
					}
					else if (m_pClientList[i]->m_cSide == 2) {
						RequestTeleportHandler(i, "2   ", "elvine", -1, -1);
					}
				}

				if (m_pClientList[i] == 0) break;
				if ((strcmp(m_pClientList[i]->m_cLocation, "elvine") != 0) &&
					(strcmp(m_pClientList[i]->m_cLocation, "elvhunter") != 0) &&
					(strcmp(m_pClientList[i]->m_cLocation, "arehunter") != 0) &&
					(strcmp(m_pClientList[i]->m_cLocation, "aresden") != 0) &&
					(m_pClientList[i]->m_iLevel >= 20)) {
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Traveller Hack: (%s) Player: (%s) is a traveller and is greater than level 19.", m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName);
					PutHackLogFileList(G_cTxt);
					DeleteClient(i, true, true);
				}

				if (m_pClientList[i] == 0) break;
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap) &&
					(m_bIsApocalypseMode == false))
				{
					RequestTeleportHandler(i, "1   ");
				}

				//(m_bIsCrusadeMode )
				/*
				if (m_pClientList[i] == 0) break;
				if (((memcmp(m_pClientList[i]->m_cLocation, "aresden",7) == 0) || (memcmp(m_pClientList[i]->m_cLocation, "elvine",6) == 0)) ) {
					iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName);
					if (iMapside > 3) iMapside2 = iMapside - 2;
					else iMapside2 = iMapside;

					if ((m_pClientList[i]->m_cSide != iMapside2) && (iMapside != 0)) {
						if ((iMapside <= 2)) {
							if (m_pClientList[i]->m_cSide != 0) {
								m_pClientList[i]->m_dwWarBeginTime = GameClock::GetTimeMS();
								m_pClientList[i]->m_bIsWarLocation = true;
								m_pClientList[i]->m_iTimeLeft_ForceRecall = 1;

								RequestTeleportHandler(i, "1   ");
								SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
							}
						}
					}
				}*/

				if (m_pClientList[i] == 0) break;
				if (((memcmp(m_pClientList[i]->m_cLocation, "arehunter", 9) == 0) || (memcmp(m_pClientList[i]->m_cLocation, "elvhunter", 9) == 0)) &&
					((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "2ndmiddle") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0))) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "1   ");
				}

				if (m_bIsApocalypseMode) {
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "abaddon", 7) == 0)
						SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEOPEN, 167, 169, 0, m_pClientList[i]->m_cMapName);
					else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0)
						SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEOPEN, 89, 31, 0, m_pClientList[i]->m_cMapName);
				}

				if (m_pClientList[i] == 0) break;
				if ((m_bIsApocalypseMode) &&
					(memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0) &&
					((m_pClientList[i]->m_sX == 89 && m_pClientList[i]->m_sY == 31) ||
						(m_pClientList[i]->m_sX == 89 && m_pClientList[i]->m_sY == 32) ||
						(m_pClientList[i]->m_sX == 90 && m_pClientList[i]->m_sY == 31) ||
						(m_pClientList[i]->m_sX == 90 && m_pClientList[i]->m_sY == 32))) {
					RequestTeleportHandler(i, "2   ", "druncncity", -1, -1);
				}

				if (m_pClientList[i] == 0) break;
				if ((memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) &&
					(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == 0) break;
				if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) &&
					(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "arefarm") == 0)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == 0) break;
				if ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0)
					&& (strcmp(m_pClientList[i]->m_cLocation, "NONE") == 0)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
					RequestTeleportHandler(i, "0   ");
				}

				if ((m_pClientList[i]->m_bInRecallImpossibleMap)) {
					m_pClientList[i]->m_iTimeLeft_ForceRecall--;
					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_bInRecallImpossibleMap = false;
						SendNotifyMsg(0, i, DEF_NOTIFY_TOBERECALLED, 0, 0, 0, 0);
						RequestTeleportHandler(i, "0   ");
					}
				}

				if (m_pClientList[i] == 0) break;
				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) {

					m_pClientList[i]->m_iSuperAttackCount = 0;
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;

					// v1.12
					SendNotifyMsg(0, i, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
				}

				// v1.42
				m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;

				// Crusade
				if (m_pClientList[i] == 0) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus) _SendMapStatus(i);

				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}


void CGame::ResponsePlayerDataHandler(char* pData, uint32_t dwSize)
{
	char* cp, cCharName[DEF_CHARNAME], cTxt[120];

	std::memset(cCharName, 0, sizeof(cCharName));
	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader));

	memcpy(cCharName, cp, DEF_CHARNAME - 1);
	cp += 10;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			if (_strnicmp(m_pClientList[i]->m_cCharName, cCharName, DEF_CHARNAME - 1) == 0) {
				switch (header->msg_type) {
				case DEF_LOGRESMSGTYPE_CONFIRM:
					InitPlayerData(i, pData, dwSize);
					break;

				case DEF_LOGRESMSGTYPE_REJECT:
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
					PutLogList(G_cTxt);
					//PutLogFileList(G_cTxt); // v1.4

					DeleteClient(i, false, false);
					break;

				default:
					break;
				}

				return;
			}
		}

	std::snprintf(cTxt, sizeof(cTxt), "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
	PutLogList(cTxt);
}

bool CGame::LoadPlayerDataFromDb(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return false;

	sqlite3* db = nullptr;
	std::string dbPath;
	if (!EnsureAccountDatabase(m_pClientList[iClientH]->m_cAccountName, &db, dbPath)) {
		return false;
	}

	AccountDbCharacterState state = {};
	if (!LoadCharacterState(db, m_pClientList[iClientH]->m_cCharName, state)) {
		CloseAccountDatabase(db);
		return false;
	}

	std::memset(m_pClientList[iClientH]->m_cProfile, 0, sizeof(m_pClientList[iClientH]->m_cProfile));
	std::snprintf(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile), "%s", state.profile);

	std::memset(m_pClientList[iClientH]->m_cLocation, 0, sizeof(m_pClientList[iClientH]->m_cLocation));
	std::snprintf(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation), "%s", state.location);

	std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
	std::snprintf(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName), "%s", state.guildName);
	m_pClientList[iClientH]->m_iGuildGUID = state.guildGuid;
	m_pClientList[iClientH]->m_iGuildRank = state.guildRank;

	std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
	std::snprintf(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName), "%s", state.mapName);
	m_pClientList[iClientH]->m_cMapIndex = -1;
	for(int i = 0; i < DEF_MAXMAPS; i++) {
		if ((m_pMapList[i] != 0) && (memcmp(m_pMapList[i]->m_cName, m_pClientList[iClientH]->m_cMapName, 10) == 0)) {
			m_pClientList[iClientH]->m_cMapIndex = (char)i;
			break;
		}
	}
	if (m_pClientList[iClientH]->m_cMapIndex == -1) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
		PutLogList(G_cTxt);
		CloseAccountDatabase(db);
		return false;
	}

	m_pClientList[iClientH]->m_sX = (short)state.mapX;
	m_pClientList[iClientH]->m_sY = (short)state.mapY;
	m_pClientList[iClientH]->m_iHP = state.hp;
	m_pClientList[iClientH]->m_iMP = state.mp;
	m_pClientList[iClientH]->m_iSP = state.sp;
	m_pClientList[iClientH]->m_iLevel = state.level;
	m_pClientList[iClientH]->m_iRating = state.rating;
	m_pClientList[iClientH]->m_iStr = state.str;
	m_pClientList[iClientH]->m_iInt = state.intl;
	m_pClientList[iClientH]->m_iVit = state.vit;
	m_pClientList[iClientH]->m_iDex = state.dex;
	m_pClientList[iClientH]->m_iMag = state.mag;
	m_pClientList[iClientH]->m_iCharisma = state.chr;
	m_pClientList[iClientH]->m_iLuck = state.luck;
	m_pClientList[iClientH]->m_iExp = state.exp;
	m_pClientList[iClientH]->m_iLU_Pool = state.luPool;
	m_pClientList[iClientH]->m_iEnemyKillCount = state.enemyKillCount;
	m_pClientList[iClientH]->m_iPKCount = state.pkCount;
	m_pClientList[iClientH]->m_iRewardGold = state.rewardGold;
	m_pClientList[iClientH]->m_iDownSkillIndex = state.downSkillIndex;
	m_pClientList[iClientH]->m_sCharIDnum1 = (short)state.idnum1;
	m_pClientList[iClientH]->m_sCharIDnum2 = (short)state.idnum2;
	m_pClientList[iClientH]->m_sCharIDnum3 = (short)state.idnum3;
	m_pClientList[iClientH]->m_cSex = (char)state.sex;
	m_pClientList[iClientH]->m_cSkin = (char)state.skin;
	m_pClientList[iClientH]->m_cHairStyle = (char)state.hairStyle;
	m_pClientList[iClientH]->m_cHairColor = (char)state.hairColor;
	m_pClientList[iClientH]->m_cUnderwear = (char)state.underwear;
	m_pClientList[iClientH]->m_iHungerStatus = state.hungerStatus;
	m_pClientList[iClientH]->m_iTimeLeft_Rating = state.timeleftRating;
	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = state.timeleftForceRecall;
	m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = state.timeleftFirmStaminar;
	m_pClientList[iClientH]->m_iPenaltyBlockYear = state.penaltyBlockYear;
	m_pClientList[iClientH]->m_iPenaltyBlockMonth = state.penaltyBlockMonth;
	m_pClientList[iClientH]->m_iPenaltyBlockDay = state.penaltyBlockDay;
	m_pClientList[iClientH]->m_iQuest = state.questNumber;
	m_pClientList[iClientH]->m_iQuestID = state.questId;
	m_pClientList[iClientH]->m_iCurQuestCount = state.currentQuestCount;
	m_pClientList[iClientH]->m_iQuestRewardType = state.questRewardType;
	m_pClientList[iClientH]->m_iQuestRewardAmount = state.questRewardAmount;
	m_pClientList[iClientH]->m_iContribution = state.contribution;
	m_pClientList[iClientH]->m_iWarContribution = state.warContribution;
	m_pClientList[iClientH]->m_bIsQuestCompleted = (state.questCompleted != 0);
	m_pClientList[iClientH]->m_iSpecialEventID = state.specialEventId;
	m_pClientList[iClientH]->m_iSuperAttackLeft = state.superAttackLeft;
	m_pClientList[iClientH]->m_iFightzoneNumber = state.fightzoneNumber;
	m_pClientList[iClientH]->m_iReserveTime = state.reserveTime;
	m_pClientList[iClientH]->m_iFightZoneTicketNumber = state.fightzoneTicketNumber;
	m_pClientList[iClientH]->m_iSpecialAbilityTime = state.specialAbilityTime;
	std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
	std::snprintf(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName), "%s", state.lockedMapName);
	m_pClientList[iClientH]->m_iLockedMapTime = state.lockedMapTime;
	m_pClientList[iClientH]->m_iCrusadeDuty = state.crusadeJob;
	m_pClientList[iClientH]->m_dwCrusadeGUID = state.crusadeGuid;
	m_pClientList[iClientH]->m_iConstructionPoint = state.constructPoint;
	m_pClientList[iClientH]->m_iDeadPenaltyTime = state.deadPenaltyTime;
	m_pClientList[iClientH]->m_iPartyID = state.partyId;
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = state.gizonItemUpgradeLeft;
	m_pClientList[iClientH]->m_appearance = state.appearance;

	for(int i = 0; i < hb::limits::MaxItems; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			delete m_pClientList[iClientH]->m_pItemList[i];
			m_pClientList[iClientH]->m_pItemList[i] = 0;
		}
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
		m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
	}

	for(int i = 0; i < hb::limits::MaxBankItems; i++) {
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != 0) {
			delete m_pClientList[iClientH]->m_pItemInBankList[i];
			m_pClientList[iClientH]->m_pItemInBankList[i] = 0;
		}
	}

	std::vector<AccountDbIndexedValue> positionsX;
	std::vector<AccountDbIndexedValue> positionsY;
	LoadCharacterItemPositions(db, m_pClientList[iClientH]->m_cCharName, positionsX, positionsY);
	for (size_t i = 0; i < positionsX.size(); i++) {
		int slot = positionsX[i].index;
		if (slot >= 0 && slot < hb::limits::MaxItems) {
			m_pClientList[iClientH]->m_ItemPosList[slot].x = positionsX[i].value;
			m_pClientList[iClientH]->m_ItemPosList[slot].y = positionsY[i].value;
		}
	}

	std::vector<AccountDbItemRow> items;
	LoadCharacterItems(db, m_pClientList[iClientH]->m_cCharName, items);
	for (const auto& item : items) {
		if (item.slot < 0 || item.slot >= hb::limits::MaxItems) {
			continue;
		}
		if (m_pClientList[iClientH]->m_pItemList[item.slot] != 0) {
			delete m_pClientList[iClientH]->m_pItemList[item.slot];
		}
		m_pClientList[iClientH]->m_pItemList[item.slot] = new CItem;
		if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[item.slot], item.itemId) == false) {
			delete m_pClientList[iClientH]->m_pItemList[item.slot];
			m_pClientList[iClientH]->m_pItemList[item.slot] = 0;
			continue;
		}
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_dwCount = item.count;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sTouchEffectType = item.touchEffectType;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sTouchEffectValue1 = item.touchEffectValue1;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sTouchEffectValue2 = item.touchEffectValue2;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sTouchEffectValue3 = item.touchEffectValue3;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_cItemColor = item.itemColor;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sItemSpecEffectValue1 = item.specEffectValue1;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sItemSpecEffectValue2 = item.specEffectValue2;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_sItemSpecEffectValue3 = item.specEffectValue3;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_wCurLifeSpan = (short)item.curLifeSpan;
		m_pClientList[iClientH]->m_pItemList[item.slot]->m_dwAttribute = item.attribute;

		if ((m_pClientList[iClientH]->m_pItemList[item.slot]->m_dwAttribute & 0x00000001) != 0) {
			m_pClientList[iClientH]->m_pItemList[item.slot]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[item.slot]->m_sItemSpecEffectValue1;
		}
		_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[item.slot]);
		if (m_pClientList[iClientH]->m_pItemList[item.slot]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[item.slot]->m_wMaxLifeSpan) {
			m_pClientList[iClientH]->m_pItemList[item.slot]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[item.slot]->m_wMaxLifeSpan;
		}
		bCheckAndConvertPlusWeaponItem(iClientH, item.slot);
	}

	std::vector<AccountDbBankItemRow> bankItems;
	LoadCharacterBankItems(db, m_pClientList[iClientH]->m_cCharName, bankItems);
	for (const auto& item : bankItems) {
		if (item.slot < 0 || item.slot >= hb::limits::MaxBankItems) {
			continue;
		}
		if (m_pClientList[iClientH]->m_pItemInBankList[item.slot] != 0) {
			delete m_pClientList[iClientH]->m_pItemInBankList[item.slot];
		}
		m_pClientList[iClientH]->m_pItemInBankList[item.slot] = new CItem;
		if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[item.slot], item.itemId) == false) {
			delete m_pClientList[iClientH]->m_pItemInBankList[item.slot];
			m_pClientList[iClientH]->m_pItemInBankList[item.slot] = 0;
			continue;
		}
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_dwCount = item.count;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sTouchEffectType = item.touchEffectType;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sTouchEffectValue1 = item.touchEffectValue1;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sTouchEffectValue2 = item.touchEffectValue2;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sTouchEffectValue3 = item.touchEffectValue3;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_cItemColor = item.itemColor;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sItemSpecEffectValue1 = item.specEffectValue1;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sItemSpecEffectValue2 = item.specEffectValue2;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sItemSpecEffectValue3 = item.specEffectValue3;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wCurLifeSpan = (short)item.curLifeSpan;
		m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_dwAttribute = item.attribute;
		if ((m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_dwAttribute & 0x00000001) != 0) {
			m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_sItemSpecEffectValue1;
		}
		_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[item.slot]);
		if (m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wMaxLifeSpan) {
			m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[item.slot]->m_wMaxLifeSpan;
		}
	}

	std::vector<AccountDbIndexedValue> equips;
	LoadCharacterItemEquips(db, m_pClientList[iClientH]->m_cCharName, equips);
	for (const auto& equip : equips) {
		if (equip.index >= 0 && equip.index < hb::limits::MaxItems) {
			m_pClientList[iClientH]->m_bIsItemEquipped[equip.index] = (equip.value != 0);
		}
	}

	int packedIndex = 0;
	for(int i = 0; i < hb::limits::MaxItems; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] == 0) {
			continue;
		}
		if (i != packedIndex) {
			m_pClientList[iClientH]->m_pItemList[packedIndex] = m_pClientList[iClientH]->m_pItemList[i];
			m_pClientList[iClientH]->m_pItemList[i] = 0;
			m_pClientList[iClientH]->m_ItemPosList[packedIndex] = m_pClientList[iClientH]->m_ItemPosList[i];
			m_pClientList[iClientH]->m_bIsItemEquipped[packedIndex] = m_pClientList[iClientH]->m_bIsItemEquipped[i];
		}
		packedIndex++;
	}
	for(int i = packedIndex; i < hb::limits::MaxItems; i++) {
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
		m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
	}

	packedIndex = 0;
	for(int i = 0; i < hb::limits::MaxBankItems; i++) {
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {
			continue;
		}
		if (i != packedIndex) {
			m_pClientList[iClientH]->m_pItemInBankList[packedIndex] = m_pClientList[iClientH]->m_pItemInBankList[i];
			m_pClientList[iClientH]->m_pItemInBankList[i] = 0;
		}
		packedIndex++;
	}
	for(int i = packedIndex; i < hb::limits::MaxBankItems; i++) {
		m_pClientList[iClientH]->m_pItemInBankList[i] = 0;
	}

	for(int i = 0; i < DEF_MAXITEMEQUIPPOS; i++) {
		m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;
	}

	for(int i = 0; i < hb::limits::MaxItems; i++) {
		if ((m_pClientList[iClientH]->m_pItemList[i] != 0) && m_pClientList[iClientH]->m_bIsItemEquipped[i]) {
			if (m_pClientList[iClientH]->m_pItemList[i]->GetItemType() == ItemType::Equip) {
				if (bEquipItemHandler(iClientH, i) == false) {
					m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
				}
			}
			else {
				m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;
			}
		}
	}

	for(int i = 0; i < DEF_MAXMAGICTYPE; i++) {
		m_pClientList[iClientH]->m_cMagicMastery[i] = 0;
	}
	std::vector<AccountDbIndexedValue> magicMastery;
	LoadCharacterMagicMastery(db, m_pClientList[iClientH]->m_cCharName, magicMastery);
	for (const auto& entry : magicMastery) {
		if (entry.index >= 0 && entry.index < DEF_MAXMAGICTYPE) {
			m_pClientList[iClientH]->m_cMagicMastery[entry.index] = (char)entry.value;
		}
	}

	for(int i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_cSkillMastery[i] = 0;
		m_pClientList[iClientH]->m_iSkillSSN[i] = 0;
	}
	std::vector<AccountDbIndexedValue> skillMastery;
	LoadCharacterSkillMastery(db, m_pClientList[iClientH]->m_cCharName, skillMastery);
	for (const auto& entry : skillMastery) {
		if (entry.index >= 0 && entry.index < DEF_MAXSKILLTYPE) {
			m_pClientList[iClientH]->m_cSkillMastery[entry.index] = (unsigned char)entry.value;
		}
	}

	std::vector<AccountDbIndexedValue> skillSsn;
	LoadCharacterSkillSSN(db, m_pClientList[iClientH]->m_cCharName, skillSsn);
	for (const auto& entry : skillSsn) {
		if (entry.index >= 0 && entry.index < DEF_MAXSKILLTYPE) {
			m_pClientList[iClientH]->m_iSkillSSN[entry.index] = entry.value;
		}
	}

	short sTmpType = 0;
	if (m_pClientList[iClientH]->m_cSex == 1) {
		sTmpType = 1;
	}
	else if (m_pClientList[iClientH]->m_cSex == 2) {
		sTmpType = 4;
	}
	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:
		break;
	case 2:
		sTmpType += 1;
		break;
	case 3:
		sTmpType += 2;
		break;
	}
	m_pClientList[iClientH]->m_sType = sTmpType;
	m_pClientList[iClientH]->m_appearance.iHairStyle = m_pClientList[iClientH]->m_cHairStyle;
	m_pClientList[iClientH]->m_appearance.iHairColor = m_pClientList[iClientH]->m_cHairColor;
	m_pClientList[iClientH]->m_appearance.iUnderwearType = m_pClientList[iClientH]->m_cUnderwear;

	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		int temp1 = 1;
		int temp2 = 1;
		for(int i = 0; i < 10; i++) {
			temp1 += m_pClientList[iClientH]->m_cCharName[i];
			temp2 += abs(m_pClientList[iClientH]->m_cCharName[i] ^ m_pClientList[iClientH]->m_cCharName[i]);
		}
		m_pClientList[iClientH]->m_sCharIDnum1 = (short)GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_sCharIDnum2 = (short)temp1;
		m_pClientList[iClientH]->m_sCharIDnum3 = (short)temp2;
	}

	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		m_pClientList[iClientH]->m_bIsNeutral = true;
	}

	// Load block list
	m_pClientList[iClientH]->m_BlockedAccounts.clear();
	m_pClientList[iClientH]->m_BlockedAccountsList.clear();
	m_pClientList[iClientH]->m_bBlockListDirty = false;
	std::vector<std::pair<std::string, std::string>> blocks;
	if (LoadBlockList(db, blocks)) {
		for (const auto& entry : blocks) {
			m_pClientList[iClientH]->m_BlockedAccounts.insert(entry.first);
			m_pClientList[iClientH]->m_BlockedAccountsList.push_back(entry);
		}
	}

	CloseAccountDatabase(db);
	return true;
}

void CGame::InitPlayerData(int iClientH, char* pData, uint32_t dwSize)
{
	char cTxt[256], cQuestRemain;
	int     iRet, iTotalPoints;
	bool    bRet, bGuildStatus;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete) return;

	// Log Server
	//cp = (char *)(pData + hb::net::MessageOffsetType + 2);

	//std::memset(cName, 0, sizeof(cName));
	//memcpy(cName, cp, DEF_CHARNAME - 1);
	//cp += 10;

	////m_pClientList[iClientH]->m_cAccountStatus = *cp;
	//cp++;

	//cGuildStatus = *cp;
	//cp++;

	m_pClientList[iClientH]->m_iHitRatio = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = 0;
	m_pClientList[iClientH]->m_cSide = 0;

	bRet = LoadPlayerDataFromDb(iClientH);
	if (bRet == false) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
		DeleteClient(iClientH, false, true);
		return;
	}

	___RestorePlayerCharacteristics(iClientH);

	___RestorePlayerRating(iClientH);

	if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1)) {
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
	}

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	// Set faction/identity status fields from player data
	m_pClientList[iClientH]->m_status.bPK = (m_pClientList[iClientH]->m_iPKCount != 0) ? 1 : 0;
	m_pClientList[iClientH]->m_status.bCitizen = (m_pClientList[iClientH]->m_cSide != 0) ? 1 : 0;
	m_pClientList[iClientH]->m_status.bAresden = (m_pClientList[iClientH]->m_cSide == 1) ? 1 : 0;
	m_pClientList[iClientH]->m_status.bHunter = m_pClientList[iClientH]->m_bIsPlayerCivil ? 1 : 0;

	if (m_pClientList[iClientH]->m_iLevel > 100)
		if (m_pClientList[iClientH]->m_bIsPlayerCivil)
			ForceChangePlayMode(iClientH, false);

	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

	CalcTotalItemEffect(iClientH, -1, true); //false
	iCalcTotalWeight(iClientH);

	iTotalPoints = 0;
	for(int i = 0; i < DEF_MAXSKILLTYPE; i++)
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];
	if ((iTotalPoints - 21 > DEF_MAXSKILLPOINTS) ) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) - has more than allowed skill points (%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, iTotalPoints);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{
		}
		return;
	}

	CheckSpecialEvent(iClientH);
	bCheckMagicInt(iClientH);

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, 0, 0, 0);

	if (strcmp(m_pClientList[iClientH]->m_cGuildName, "NONE") != 0) {
		char cFn[112] = {};
		std::memset(cFn, 0, sizeof(cFn));
		std::snprintf(cFn, sizeof(cFn), "Guilds\\AscII%d\\%s.txt", m_pClientList[iClientH]->m_cGuildName[0], m_pClientList[iClientH]->m_cGuildName);
		HANDLE  hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
		auto dwFileSize = GetFileSize(hFile, 0);

		bGuildStatus = !(hFile == INVALID_HANDLE_VALUE);
		CloseHandle(hFile);
		// GuildName
		if ((!bGuildStatus) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
			std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
			m_pClientList[iClientH]->m_iGuildRank = -1;
			m_pClientList[iClientH]->m_iGuildGUID = -1;

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GUILDDISBANDED, 0, 0, 0, m_pClientList[iClientH]->m_cGuildName);
		}
	}

	if (m_pClientList[iClientH]->m_iQuest != 0) {
		cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, 0, 0, 0);
		_bCheckIsQuestCompleted(iClientH);
	}


	if (m_pClientList[iClientH] == 0) {
		std::snprintf(cTxt, sizeof(cTxt), "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}

	hb::net::PacketResponseInitPlayer pkt{};
	pkt.header.msg_id = MSGID_RESPONSE_INITPLAYER;
	pkt.header.msg_type = DEF_MSGTYPE_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ## BUG POINT!!!
		std::snprintf(cTxt, sizeof(cTxt), "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);

		DeleteClient(iClientH, false, true);
		return;
	}


	m_pClientList[iClientH]->m_bIsInitComplete = true;
}

void CGame::GameProcess()
{
	// MODERNIZED: Socket polling moved to EventLoop (wmain.cpp) for continuous responsiveness
	// This function now handles only game logic processing
	NpcProcess();
	MsgProcess();
	ForceRecallProcess();
	DelayEventProcess();
}


void CGame::_ClearItemConfigList()
{
	for(int i = 0; i < DEF_MAXITEMTYPES; i++) {
		if (m_pItemConfigList[i] != 0) {
			delete m_pItemConfigList[i];
			m_pItemConfigList[i] = 0;
		}
	}
}


// Helper function to normalize item name for comparison (removes spaces and underscores)
static void NormalizeItemName(const char* src, char* dst, size_t dstSize)
{
	size_t j = 0;
	for (size_t i = 0; src[i] && j < dstSize - 1; ++i) {
		if (src[i] != ' ' && src[i] != '_') {
			dst[j++] = src[i];
		}
	}
	dst[j] = '\0';
}

bool CGame::_bInitItemAttr(CItem* pItem, const char* pItemName)
{
	
	char cTmpName[DEF_NPCNAME];
	char cNormalizedInput[21];
	char cNormalizedConfig[21];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	// Normalize the input name for comparison (client may send "MagicStaff" while DB has "Magic Staff")
	NormalizeItemName(cTmpName, cNormalizedInput, sizeof(cNormalizedInput));

	for(int i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != 0) {
			// Normalize the config name for comparison
			NormalizeItemName(m_pItemConfigList[i]->m_cName, cNormalizedConfig, sizeof(cNormalizedConfig));
			if (_stricmp(cNormalizedInput, cNormalizedConfig) == 0) {
				std::memset(pItem->m_cName, 0, sizeof(pItem->m_cName));
				strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
				pItem->m_cItemType = m_pItemConfigList[i]->m_cItemType;
				pItem->m_cEquipPos = m_pItemConfigList[i]->m_cEquipPos;
				pItem->m_sItemEffectType = m_pItemConfigList[i]->m_sItemEffectType;
				pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
				pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
				pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
				pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
				pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
				pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
				pItem->m_wMaxLifeSpan = m_pItemConfigList[i]->m_wMaxLifeSpan;
				pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				pItem->m_sSpecialEffect = m_pItemConfigList[i]->m_sSpecialEffect;

				pItem->m_sSprite = m_pItemConfigList[i]->m_sSprite;
				pItem->m_sSpriteFrame = m_pItemConfigList[i]->m_sSpriteFrame;
				pItem->m_wPrice = m_pItemConfigList[i]->m_wPrice;
				pItem->m_wWeight = m_pItemConfigList[i]->m_wWeight;
				pItem->m_cApprValue = m_pItemConfigList[i]->m_cApprValue;
				pItem->m_cSpeed = m_pItemConfigList[i]->m_cSpeed;
				pItem->m_sLevelLimit = m_pItemConfigList[i]->m_sLevelLimit;
				pItem->m_cGenderLimit = m_pItemConfigList[i]->m_cGenderLimit;

				pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
				pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

				pItem->m_sRelatedSkill = m_pItemConfigList[i]->m_sRelatedSkill;
				pItem->m_cCategory = m_pItemConfigList[i]->m_cCategory;
				pItem->m_sIDnum = m_pItemConfigList[i]->m_sIDnum;

				pItem->m_bIsForSale = m_pItemConfigList[i]->m_bIsForSale;
				pItem->m_cItemColor = m_pItemConfigList[i]->m_cItemColor;

				return true;
			}
		}

	return false;
}

bool CGame::_bInitItemAttr(CItem* pItem, int iItemID)
{
	if (iItemID < 0 || iItemID >= DEF_MAXITEMTYPES) return false;
	if (m_pItemConfigList[iItemID] == nullptr) return false;

	CItem* pConfig = m_pItemConfigList[iItemID];

	std::memset(pItem->m_cName, 0, sizeof(pItem->m_cName));
	strcpy(pItem->m_cName, pConfig->m_cName);
	pItem->m_cItemType = pConfig->m_cItemType;
	pItem->m_cEquipPos = pConfig->m_cEquipPos;
	pItem->m_sItemEffectType = pConfig->m_sItemEffectType;
	pItem->m_sItemEffectValue1 = pConfig->m_sItemEffectValue1;
	pItem->m_sItemEffectValue2 = pConfig->m_sItemEffectValue2;
	pItem->m_sItemEffectValue3 = pConfig->m_sItemEffectValue3;
	pItem->m_sItemEffectValue4 = pConfig->m_sItemEffectValue4;
	pItem->m_sItemEffectValue5 = pConfig->m_sItemEffectValue5;
	pItem->m_sItemEffectValue6 = pConfig->m_sItemEffectValue6;
	pItem->m_wMaxLifeSpan = pConfig->m_wMaxLifeSpan;
	pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
	pItem->m_sSpecialEffect = pConfig->m_sSpecialEffect;
	pItem->m_sSprite = pConfig->m_sSprite;
	pItem->m_sSpriteFrame = pConfig->m_sSpriteFrame;
	pItem->m_wPrice = pConfig->m_wPrice;
	pItem->m_wWeight = pConfig->m_wWeight;
	pItem->m_cApprValue = pConfig->m_cApprValue;
	pItem->m_cSpeed = pConfig->m_cSpeed;
	pItem->m_sLevelLimit = pConfig->m_sLevelLimit;
	pItem->m_cGenderLimit = pConfig->m_cGenderLimit;
	pItem->m_sSpecialEffectValue1 = pConfig->m_sSpecialEffectValue1;
	pItem->m_sSpecialEffectValue2 = pConfig->m_sSpecialEffectValue2;
	pItem->m_sRelatedSkill = pConfig->m_sRelatedSkill;
	pItem->m_cCategory = pConfig->m_cCategory;
	pItem->m_sIDnum = pConfig->m_sIDnum;
	pItem->m_bIsForSale = pConfig->m_bIsForSale;
	pItem->m_cItemColor = pConfig->m_cItemColor;

	return true;
}

bool CGame::_bGetIsStringIsNumber(char* pStr)
{
	
	for(int i = 0; i < (int)strlen(pStr); i++)
		if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return false;

	return true;
}


bool CGame::_bReadMapInfoFiles(int iMapIndex)
{
	if (__bReadMapInfo(iMapIndex) == false) {
		return false;
	}

	return true;
}


int CGame::bCreateNewNpc(char* pNpcName, char* pName, char* pMapName, short sClass, char cSA, char cMoveType, int* poX, int* poY, char* pWaypointList, GameRectangle* pArea, int iSpotMobIndex, char cChangeSide, bool bHideGenMode, bool bIsSummoned, bool bFirmBerserk, bool bIsMaster, int iGuildGUID, bool bBypassMobLimit)
{
	if (m_pEntityManager == 0)
		return false;

	return (m_pEntityManager->CreateEntity(
		pNpcName, pName, pMapName, sClass, cSA, cMoveType,
		poX, poY, pWaypointList, pArea, iSpotMobIndex, cChangeSide,
		bHideGenMode, bIsSummoned, bFirmBerserk, bIsMaster, iGuildGUID, bBypassMobLimit) > 0);
}

int CGame::SpawnMapNpcsFromDatabase(sqlite3* db, int iMapIndex)
{
	if (db == nullptr || m_pMapList[iMapIndex] == nullptr)
		return 0;

	const char* sql =
		"SELECT npc_name, move_type, waypoint_list, name_prefix"
		" FROM map_npcs WHERE map_name = ? COLLATE NOCASE;";

	sqlite3_stmt* stmt = nullptr;
	if (sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr) != SQLITE_OK) {
		return 0;
	}

	sqlite3_bind_text(stmt, 1, m_pMapList[iMapIndex]->m_cName, -1, SQLITE_STATIC);

	int npcCount = 0;
	char cNpcName[DEF_NPCNAME];
	char cNpcWaypointIndex[12];
	char cNamePrefix;
	char cNpcMoveType;
	char cName[8];
	int iNamingValue;

	while (sqlite3_step(stmt) == SQLITE_ROW) {
		// Get NPC name
		const char* npcName = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
		if (npcName == nullptr) continue;
		std::memset(cNpcName, 0, sizeof(cNpcName));
		strncpy(cNpcName, npcName, sizeof(cNpcName) - 1);

		// Get move type
		cNpcMoveType = static_cast<char>(sqlite3_column_int(stmt, 1));

		// Get waypoint list (comma-separated string like "0,0,0,0,0,0,0,0,0,0")
		std::memset(cNpcWaypointIndex, 0, sizeof(cNpcWaypointIndex));
		const char* waypointList = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 2));
		if (waypointList != nullptr && strlen(waypointList) > 0) {
			// Parse comma-separated waypoints
			char waypointCopy[64];
			strncpy(waypointCopy, waypointList, sizeof(waypointCopy) - 1);
			waypointCopy[sizeof(waypointCopy) - 1] = '\0';

			char* token = strtok(waypointCopy, ",");
			int wpIndex = 0;
			while (token != nullptr && wpIndex < 10) {
				cNpcWaypointIndex[wpIndex] = static_cast<char>(atoi(token));
				token = strtok(nullptr, ",");
				wpIndex++;
			}
		}

		// Get name prefix
		const char* prefix = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 3));
		cNamePrefix = (prefix != nullptr && strlen(prefix) > 0) ? prefix[0] : '_';

		// Get a naming value for this NPC
		iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
			// No more naming values available for this map
			continue;
		}

		// Construct the NPC instance name
		std::memset(cName, 0, sizeof(cName));
		std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
		cName[0] = cNamePrefix;
		cName[1] = static_cast<char>(iMapIndex + 65);

		// Spawn the NPC
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, 0, 0, cNpcWaypointIndex, 0, 0, -1, false) == false) {
			// Failed, release the naming value
			m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
		else {
			npcCount++;
		}
	}

	sqlite3_finalize(stmt);

	if (npcCount > 0) {
		char cTxt[128];
		std::snprintf(cTxt, sizeof(cTxt), "  - Spawned %d static NPCs for map: %s", npcCount, m_pMapList[iMapIndex]->m_cName);
		PutLogList(cTxt);
	}

	return npcCount;
}

void CGame::NpcProcess()
{
	if (m_pEntityManager != 0)
		m_pEntityManager->ProcessEntities();
}


void CGame::BroadcastServerMessage(const char* pMessage)
{
	if (pMessage == nullptr || pMessage[0] == '\0')
		return;

	// Build a chat packet: header(6) + x(2) + y(2) + name(10) + chat_type(1) + message + null
	char pkt[256];
	std::memset(pkt, 0, sizeof(pkt));

	size_t msgLen = std::strlen(pMessage);
	if (msgLen > sizeof(pkt) - 22) msgLen = sizeof(pkt) - 22;

	uint32_t* dwp = (uint32_t*)(pkt);
	*dwp = MSGID_COMMAND_CHATMSG;

	uint16_t* wp = (uint16_t*)(pkt + 4);
	*wp = 0; // msg_type = 0 (no sender client handle)

	// x, y at offset 6 and 8  leave as 0
	// name at offset 10  use "Server"
	std::memcpy(pkt + 10, "Server", 6);

	// chat_type at offset 20  GM chat = 10
	pkt[20] = 10;

	// message at offset 21
	std::memcpy(pkt + 21, pMessage, msgLen);
	pkt[21 + msgLen] = '\0';

	uint32_t dwSize = (uint32_t)(21 + msgLen + 1);

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
	{
		if (m_pClientList[i] != nullptr && m_pClientList[i]->m_bIsInitComplete)
			m_pClientList[i]->m_pXSock->iSendMsg(pkt, dwSize);
	}

	ChatLog::Get().Write(10, "Server", "", pMessage);
}

bool CGame::IsBlockedBy(int iSenderH, int iReceiverH) const
{
	if (m_pClientList[iSenderH] == nullptr || m_pClientList[iReceiverH] == nullptr)
		return false;
	return m_pClientList[iReceiverH]->m_BlockedAccounts.count(
		m_pClientList[iSenderH]->m_cAccountName) > 0;
}

// 05/29/2004 - Hypnotoad - GM chat tweak
void CGame::ChatMsgHandler(int iClientH, char* pData, size_t dwMsgSize)
{
	int iRet;
	char* cp;
	char cSendMode = 0;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (dwMsgSize > 83 + 30) return;

	auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandChatMsgHeader>(pData, sizeof(hb::net::PacketCommandChatMsgHeader));
	if (!pkt) return;
	char* payload = reinterpret_cast<char*>(header) + sizeof(hb::net::PacketHeader);
	char* message = payload + 15;

	if (_strnicmp(pkt->name, m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;

	if (m_pClientList[iClientH]->m_bIsObserverMode) return;

	// v1.432-2
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	cp = message;

	switch (*cp) {
	case '@':
		*cp = 32;

		if ((m_pClientList[iClientH]->m_iLevel > 1) &&
			(m_pClientList[iClientH]->m_iSP >= 3)) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 1;
		}
		else cSendMode = 0;
		break;

		// New 08/05/2004
		// Party chat
	case '$':
		*cp = 32;

		if (m_pClientList[iClientH]->m_iSP >= 3) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 4;
		}
		else {
			cSendMode = 0;
		}
		break;

	case '^':
		*cp = 32;

		if ((m_pClientList[iClientH]->m_iLevel > 10) &&
			(m_pClientList[iClientH]->m_iSP > 5) && m_pClientList[iClientH]->m_iGuildRank != -1) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 1;
		}
		else cSendMode = 0;

		// v1.4334
		if (m_pClientList[iClientH]->m_iHP < 0) cSendMode = 0;

		break;

	case '!':
		*cp = 32;

		if ((m_pClientList[iClientH]->m_iLevel > 10) &&
			(m_pClientList[iClientH]->m_iSP >= 5)) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 5;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 2;
		}
		else cSendMode = 0;

		// v1.4334
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = 0;

		break;

	case '~':
		*cp = 32;
		if ((m_pClientList[iClientH]->m_iLevel > 1) &&
			(m_pClientList[iClientH]->m_iSP >= 3)) {
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
			cSendMode = 3;
		}
		else cSendMode = 0;
		// v1.4334
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = 0;
		break;

	case '/':
		if (GameChatCommandManager::Get().ProcessCommand(iClientH, cp, dwMsgSize - 21))
			return;
		// Not a recognized command - fall through as normal chat
		break;
	}

	pData[dwMsgSize - 1] = 0;

	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Confuse] == 1) && (iDice(1, 3) != 2)) {
		// Confuse Language
		cp = message;

		while (*cp != 0) {
			if ((cp[0] != 0) && (cp[0] != ' ') && (cp[1] != 0) && (cp[1] != ' ')) {
				switch (iDice(1, 3)) {
				case 1:	memcpy(cp, "", 2); break;
				case 2:	memcpy(cp, "", 2); break;
				case 3:	memcpy(cp, "", 2); break;
				}
				cp += 2;
			}
			else cp++;
		}
	}

	cp = message;

	if ((cSendMode == 0) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
		cSendMode = 20;

		if (*cp == '#') cSendMode = 0;
	}

	// Refresh AFK timer for non-whisper chat (whispers don't break AFK)
	if (cSendMode != 20) {
		m_pClientList[iClientH]->m_dwAfkActivityTime = GameClock::GetTimeMS();
	}

	ChatLog::Get().Write(cSendMode, m_pClientList[iClientH]->m_cCharName,
		m_pClientList[iClientH]->m_cMapName, message,
		(cSendMode == 20) ? m_pClientList[iClientH]->m_cWhisperPlayerName : nullptr);

	header->msg_type = (uint16_t)iClientH;
	cp = payload + 14;
	*cp = cSendMode;

	if (cSendMode != 20) {
		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != 0) {
				if (IsBlockedBy(iClientH, i)) continue;
				switch (cSendMode) {
				case 0:
					if (m_pClientList[i]->m_bIsInitComplete == false) break;

					if ((m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
						(m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - DEF_VIEWCENTER_X) &&
						(m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + DEF_VIEWCENTER_X) &&
						(m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - DEF_VIEWCENTER_Y) &&
						(m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + DEF_VIEWCENTER_Y)) {

						// Crusade
						if (m_bIsCrusadeMode) {
							if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
								(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
							}
							else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					break;

				case 1:
					if (m_pClientList[i]->m_bIsInitComplete == false) break;

					if ((memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
						(memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0)) {

						// Crusade
						if (m_bIsCrusadeMode) {
							if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
								(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
							}
							else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					break;

				case 2:
				case 10:
					// Crusade
					if (m_bIsCrusadeMode) {
						if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) &&
							(m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					break;

				case 3:
					if (m_pClientList[i]->m_bIsInitComplete == false) break;

					if ((m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide))
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					break;

				case 4:
					if (m_pClientList[i]->m_bIsInitComplete == false) break;
					if ((m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID))
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					break;
				}

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					//DeleteClient(i, true, true);
					break;
				}
			}
	}
	else {
		// New 16/05/2004
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);
		{
			int whisperTarget = m_pClientList[iClientH]->m_iWhisperPlayerIndex;
			if (m_pClientList[whisperTarget] != 0 &&
				_stricmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[whisperTarget]->m_cCharName) == 0) {
				if (!IsBlockedBy(iClientH, whisperTarget)) {
					iRet = m_pClientList[whisperTarget]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
			}
		}

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			//DeleteClient(i, true, true);
			break;
		}
	}
}


void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char* pName, char* pData, size_t dwMsgSize)
{
	int iRet;
	short* sp;
	char* cp, cTemp[256], cSendMode = 0;

	std::memset(cTemp, 0, sizeof(cTemp));

	{
		auto* header = reinterpret_cast<hb::net::PacketHeader*>(cTemp);
		header->msg_id = MSGID_COMMAND_CHATMSG;
		header->msg_type = 0;
	}
	cp = (char*)(cTemp + sizeof(hb::net::PacketHeader));
	sp = (short*)cp;
	*sp = 0;
	cp += 2;

	sp = (short*)cp;
	*sp = 0;
	cp += 2;

	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char)iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
	case 1:
		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != 0) {
				if (m_pClientList[i]->m_bIsInitComplete == false) break;
				if ((m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
				}
			}
		break;

	case 2:
	case 10:
		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != 0) {
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
			}
		break;
	}
}

//  int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, uint16_t wTargetObjectID, bool bResponse, bool bIsDash)
//  description			:: controls player attack
//	return value		:: int
//  last updated		:: October 29, 2004; 8:06 PM; Hypnotoad
//  commentary			:: - contains attack hack detection
//						   - added checks for Firebow and Directionbow to see if player is m_bIsInsideWarehouse, m_bIsInsideWizardTower, m_bIsInsideOwnTown 
//						   - added ability to attack moving object
//						   - fixed attack unmoving object
// Incomplete: 
//			- Direction Bow damage disabled
int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, uint16_t wTargetObjectID, uint32_t dwClientTime, bool bResponse, bool bIsDash)
{
	uint32_t dwTime, iExp;
	int     iRet, tdX = 0, tdY = 0;
	short   sOwner, sAbsX, sAbsY;
	char    cOwnerType;
	bool    bNearAttack = false, var_AC = false;
	short sItemIndex;
	int tX, tY, iErr, iStX, iStY;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;

	dwTime = GameClock::GetTimeMS();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7) {
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0) {
			// Compute expected time for 7 consecutive attacks from weapon speed and status.
			// Uses client time to avoid false positives from TCP buffering/network jitter.
			// Must match client-side animation timing (PlayerAnim::Attack: sMaxFrame=7, frames 0-7 = 8 durations @ 78ms base).
			constexpr int ATTACK_FRAME_DURATIONS = 8;
			constexpr int BASE_FRAME_TIME = 78;
			constexpr int RUN_FRAME_TIME = 39;
			constexpr int BATCH_TOLERANCE_MS = 100;

			const auto& status = m_pClientList[iClientH]->m_status;
			int iAttackDelay = status.iAttackDelay;
			bool bHaste = status.bHaste;
			bool bFrozen = status.bFrozen;

			int effectiveFrameTime = BASE_FRAME_TIME + (iAttackDelay * 12);
			if (bFrozen) effectiveFrameTime += BASE_FRAME_TIME >> 2;
			if (bHaste)  effectiveFrameTime -= static_cast<int>(RUN_FRAME_TIME / 2.3);

			int singleSwingTime = ATTACK_FRAME_DURATIONS * effectiveFrameTime;
			int batchThreshold = 7 * singleSwingTime - BATCH_TOLERANCE_MS;
			if (batchThreshold < 2800) batchThreshold = 2800;

			uint32_t dwClientGap = dwClientTime - m_pClientList[iClientH]->m_dwAttackLAT;
			if (dwClientGap < static_cast<uint32_t>(batchThreshold)) {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Batch Swing Hack: (%s) Player: (%s) - 7 attacks in %ums, Min: %dms",
					m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName,
					dwClientGap, batchThreshold);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true, true);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwClientTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}

	if ((wTargetObjectID != 0) && (wType != 2)) {
		if (wTargetObjectID < DEF_MAXCLIENTS) {
			if (m_pClientList[wTargetObjectID] != 0) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
			}
		}
		else if ((wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS))) {
			if (m_pNpcList[wTargetObjectID - 10000] != 0) {
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
			}
		}

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		if ((sOwner == (wTargetObjectID - 10000)) && (m_pNpcList[sOwner] != 0)) {
			tdX = m_pNpcList[sOwner]->m_sX;
			dX = tdX;
			tdY = m_pNpcList[sOwner]->m_sY;
			dY = tdY;
			bNearAttack = false;
			var_AC = true;
		}
		if (var_AC != true) {
			if ((tdX == dX) && (tdY == dY)) {
				bNearAttack = false;
			}
			else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
				dX = tdX;
				dY = tdY;
				bNearAttack = true;
			}
		}
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		if (var_AC == false) {
			sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
			if (sItemIndex != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return 0;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
					if ((sAbsX > 4) || (sAbsY > 4)) wType = 0;
				}
				else {
					if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
				}
			}
			else {
				if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
			}
		}
		else {
			cDir = CMisc::cGetNextMoveDir(sX, sY, dX, dY);
			if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bCheckFlySpaceAvailable(
				sX, static_cast<char>(sY), cDir, sOwner)))
				wType = 0;
		}
	}
	else if (wType >= 20) {
		short sMaxRange;
		switch (wType) {
		case 30: sMaxRange = 5; break; // StormBlade critical
		case 22: sMaxRange = 4; break; // Esterk
		case 23: sMaxRange = 3; break; // Long Sword
		case 24: sMaxRange = 2; break; // Axe
		case 26: sMaxRange = 2; break; // Hammer
		case 27: sMaxRange = 2; break; // Wand
		case 25: sMaxRange = 0; break; // Bow - ranged, no melee limit
		default: sMaxRange = 1; break; // Boxing (20), Dagger/SS (21)
		}
		if ((sMaxRange > 0) && ((sAbsX > sMaxRange) || (sAbsY > sMaxRange))) wType = 0;
	}

	ClearSkillUsingStatus(iClientH);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	m_pClientList[iClientH]->m_cDir = cDir;

	iExp = 0;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

	if (sOwner != 0) {
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) {
			if ((m_pClientList[iClientH]->m_pIsProcessingAllowed == false) && (m_pClientList[iClientH]->m_bIsInsideWarehouse == false)
				&& (m_pClientList[iClientH]->m_bIsInsideWizardTower == false) && (m_pClientList[iClientH]->m_bIsInsideOwnTown == false)) {

				uint32_t dwType1 = 0, dwType2, dwValue1, dwValue2;
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)] != -1) {
					sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
				}
				else if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] != -1) {
					sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
				}
				else sItemIndex = -1;

				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
						dwType1 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
						dwValue1 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
						dwType2 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;
						dwValue2 = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
					}

					if (dwType1 == 2) {
						// Centuu - fix for poison
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (!m_pClientList[sOwner]->m_bIsPoisoned && !bCheckResistingPoisonSuccess(sOwner, cOwnerType))
							{
								m_pClientList[sOwner]->m_bIsPoisoned = true;
								m_pClientList[sOwner]->m_iPoisonLevel = dwValue1 * 5;
								m_pClientList[sOwner]->m_dwPoisonTime = dwTime;
								SetPoisonFlag(sOwner, cOwnerType, true);
								SendNotifyMsg(0, sOwner, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Poison, m_pClientList[sOwner]->m_iPoisonLevel, 0, 0);
							}
							break;
						case DEF_OWNERTYPE_NPC:
							break;
						}
					}
				}

				sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 874) { // Directional bow
						for(int i = 2; i < 10; i++) {
							iErr = 0;
							CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY);
							//iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX, tY, wType, bNearAttack, bIsDash, true); // 1
							if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
								//iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false); // 0
							}
						}
					}
					else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 873) { // Firebow
						if (m_pClientList[iClientH]->m_appearance.bIsWalking) {
							if (m_bHeldenianInitiated != 1) {
								iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (iDice(1, 7) + 3) * 1000, 8);
							}
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false);
						}
					}
					else {
						iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false);
					}
				}
				else {
					iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false);
				}
			}
			else {
				iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, false);
			}
			if (m_pClientList[iClientH] == 0) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}
	}
	else _CheckMiningAction(iClientH, dX, dY);

	if (iExp != 0) {
		GetExp(iClientH, iExp, true);
	}

	if (bResponse) {
		hb::net::PacketResponseMotionHeader pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_MOTION;
		pkt.header.msg_type = DEF_OBJECTMOTION_ATTACK_CONFIRM;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return 0;
		}
	}

	return 1;
}

char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int* pError)
{
	char  cDir, cTmpDir;
	int   aX, aY, dX, dY;
	int   iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;

	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else CMisc::GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = CMisc::cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
		for(int i = cDir; i <= cDir + 7; i++) {
			cTmpDir = i;
			if (cTmpDir > 8) cTmpDir -= 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY)) return cTmpDir;
		}

	if (cTurn == 1)
		for(int i = cDir; i >= cDir - 7; i--) {
			cTmpDir = i;
			if (cTmpDir < 1) cTmpDir += 8;
			aX = _tmp_cTmpDirX[cTmpDir];
			aY = _tmp_cTmpDirY[cTmpDir];
			if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY)) return cTmpDir;
		}

	return 0;
}


char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

bool CGame::bGetEmptyPosition(short* pX, short* pY, char cMapIndex)
{
	
	short sX, sY;

	for(int i = 0; i < 25; i++)
		if ((m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i])) &&
			(m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == false)) {
			sX = *pX + _tmp_cEmptyPosX[i];
			sY = *pY + _tmp_cEmptyPosY[i];
			*pX = sX;
			*pY = sY;
			return true;
		}


	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return false;
}


void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode)
{
	
	uint32_t dwTime = GameClock::GetTimeMS();

	for(int i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) {
			if ((m_pNpcList[i]->m_iGuildGUID != 0) && (cTargetType == DEF_OWNERTYPE_PLAYER) &&
				(m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {

				if (m_pNpcList[i]->m_cActionLimit == 0) {
					m_pNpcList[i]->m_bIsSummoned = true;
					m_pNpcList[i]->m_dwSummonedTime = dwTime;
				}
			}

			if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) &&
				(m_pNpcList[i]->m_cTargetType == cTargetType)) {

				switch (iCode) {
				case hb::magic::Invisibility:
					if (m_pNpcList[i]->m_cSpecialAbility == 1) {
					}
					else {
						m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
						m_pNpcList[i]->m_iTargetIndex = 0;
						m_pNpcList[i]->m_cTargetType = 0;
					}
					break;

				default:
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = 0;
					m_pNpcList[i]->m_cTargetType = 0;
					break;
				}
			}
		}
}


int CGame::iGetDangerValue(int iNpcH, short dX, short dY)
{
	int iDangerValue;
	short sOwner, sDOType;
	char  cOwnerType;
	uint32_t dwRegisterTime;

	if (m_pNpcList[iNpcH] == 0) return false;

	iDangerValue = 0;

	for(int ix = dX - 2; ix <= dX + 2; ix++)
		for(int iy = dY - 2; iy <= dY + 2; iy++) {
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sDOType, &dwRegisterTime);

			if (sDOType == 1) iDangerValue++;

			switch (cOwnerType) {
			case 0:
				break;
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner] == 0) break;
				if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide)
					iDangerValue++;
				else iDangerValue--;
				break;
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwner] == 0) break;
				if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide)
					iDangerValue++;
				else iDangerValue--;
				break;
			}
		}

	return iDangerValue;
}


void CGame::MsgProcess()
{
	char* pData, cFrom, cKey;
	size_t    dwMsgSize;
	int      iClientH;
	uint32_t dwTime = GameClock::GetTimeMS();

	if ((m_bF5pressed) && (m_bF1pressed)) {
		PutLogList("(XXX) RELOADING CONFIGS MANUALY...");
		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
				g_login->LocalSavePlayerData(i); //bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
			}
		bInit();
	}

	if ((m_bF1pressed) && (m_bF4pressed) && (m_bOnExitProcess == false)) {
		m_cShutDownCode = 2;
		m_bOnExitProcess = true;
		m_dwExitProcessTime = GameClock::GetTimeMS();
		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		//bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, 0);


		return;
	}

	std::memset(m_pMsgBuffer, 0, DEF_MSGBUFFERSIZE + 1);
	pData = (char*)m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey)) {

		//v1.31
		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom) {
		case DEF_MSGFROM_CLIENT: {
			if (m_pClientList[iClientH] == nullptr) break;

			// Update activity tracking (async reads bypass OnClientSocketEvent)
			m_pClientList[iClientH]->m_dwTime = dwTime;

			const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
				pData, sizeof(hb::net::PacketHeader));
			if (!header) break;

			m_pClientList[iClientH]->m_dwLastMsgId = header->msg_id;
			m_pClientList[iClientH]->m_dwLastMsgTime = dwTime;
			m_pClientList[iClientH]->m_dwLastMsgSize = dwMsgSize;

			// Update AFK activity timer for all messages except keepalive and chat
			// (chat is handled separately in ChatMsgHandler to exclude whispers)
			if (header->msg_id != MSGID_COMMAND_CHECKCONNECTION && header->msg_id != MSGID_COMMAND_CHATMSG) {
				m_pClientList[iClientH]->m_dwAfkActivityTime = dwTime;
			}

			switch (header->msg_id) {

			case DEF_REQUEST_ANGEL: // Angels by Snoopy...
				GetAngelHandler(iClientH, pData, dwMsgSize);
				break;

			case DEF_REQUEST_RESURRECTPLAYER_YES:
				RequestResurrectPlayer(iClientH, true);
				break;

			case DEF_REQUEST_RESURRECTPLAYER_NO:
				RequestResurrectPlayer(iClientH, false);
				break;

			case MSGID_REQUEST_SELLITEMLIST:
				RequestSellItemListHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_RESTART:
				RequestRestartHandler(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				//RequestNoticementHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_SETITEMPOS:
				_SetItemPos(iClientH, pData);
				break;

			case MSGID_REQUEST_FULLOBJECTDATA:
				RequestFullObjectData(iClientH, pData);
				break;

			case MSGID_REQUEST_RETRIEVEITEM:
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				RequestCivilRightHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_TELEPORT:
				RequestTeleportHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_INITPLAYER:
				RequestInitPlayerHandler(iClientH, pData, cKey);
				break;

			case MSGID_REQUEST_INITDATA:
				if (m_pClientList[iClientH] == nullptr) break;
				if (m_pClientList[iClientH]->m_bIsClientConnected) {
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) Client (%s) connection closed!. Sniffer suspect!.", m_pClientList[iClientH]->m_cCharName);
					PutLogList(G_cTxt);					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, 0);
					g_login->LocalSavePlayerData(iClientH); //bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, false);
					if ((dwTime - m_dwGameTime2) > 3000) { // 3 segs
						m_pClientList[iClientH]->m_bIsClientConnected = false;
						DeleteClient(iClientH, true, true, true, true);
					}
					break;
				}
				else {
					m_pClientList[iClientH]->m_bIsClientConnected = true;
					RequestInitDataHandler(iClientH, pData, cKey, dwMsgSize);
				}
				break;

			case MSGID_COMMAND_COMMON:
				ClientCommonHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_MOTION:
				ClientMotionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHECKCONNECTION:
				// Ping response already sent from I/O thread for accurate latency.
				// Still run handler for speedhack detection (skip duplicate send).
				CheckConnectionHandler(iClientH, pData, true);
				break;

			case MSGID_COMMAND_CHATMSG:
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CREATENEWGUILD:
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_DISBANDGUILD:
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_STATECHANGEPOINT:
				StateChangeHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_HELDENIANTELEPORT:
				RequestHeldenianTeleport(iClientH, pData, dwMsgSize);
				break;


			case MSGID_REQUEST_CITYHALLTELEPORT:
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) {
					RequestTeleportHandler(iClientH, "2   ", "dglv2", 263, 258);
				}
				else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) {
					RequestTeleportHandler(iClientH, "2   ", "dglv2", 209, 258);
				}
				break;

			case MSGID_REQUEST_SHOP_CONTENTS:
				RequestShopContentsHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CONFIGDATA:
			{
				const auto* reqPkt = hb::net::PacketCast<hb::net::PacketRequestConfigData>(
					pData, sizeof(hb::net::PacketRequestConfigData));
				if (!reqPkt) break;
				if (dwTime - m_pClientList[iClientH]->m_dwLastConfigRequestTime < 30000) break;
				m_pClientList[iClientH]->m_dwLastConfigRequestTime = dwTime;
				if (reqPkt->requestItems)  bSendClientItemConfigs(iClientH);
				if (reqPkt->requestMagic)  bSendClientMagicConfigs(iClientH);
				if (reqPkt->requestSkills) bSendClientSkillConfigs(iClientH);
			}
			break;

			default:
				if (m_pClientList[iClientH] != 0)  // Snoopy: Anti-crash check !
				{
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Unknown message received: (0x%.8X) PC(%s) - (Delayed). \tIP(%s)"
						, header->msg_id
						, m_pClientList[iClientH]->m_cCharName
						, m_pClientList[iClientH]->m_cIPaddress);
					//DelayedDeleteClient(iClientH, true, true, true, true);
				}
				else
				{
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Unknown message received: (0x%.8X) PC(unknown).", header->msg_id);
				}
				PutLogList(G_cTxt);
				PutHackLogFileList(G_cTxt);
				PutHackLogFileList(m_pMsgBuffer);
				break;
			}
			break;
		}

		case DEF_MSGFROM_LOGSERVER: {
			const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(
				pData, sizeof(hb::net::PacketHeader));
			if (!header) break;

			switch (header->msg_id) {
			case MSGID_REQUEST_CREATENEWACCOUNT:
				g_login->CreateNewAccount(iClientH, pData);
				break;
			case MSGID_REQUEST_LOGIN:
				g_login->RequestLogin(iClientH, pData);
				break;
			case MSGID_REQUEST_CREATENEWCHARACTER: //message from client
				g_login->ResponseCharacter(iClientH, pData);
				break;
			case MSGID_REQUEST_DELETECHARACTER:
				g_login->DeleteCharacter(iClientH, pData);
				break;
			case MSGID_REQUEST_CHANGEPASSWORD:
				g_login->ChangePassword(iClientH, pData);
				break;
			case MSGID_REQUEST_ENTERGAME:
				g_login->RequestEnterGame(iClientH, pData);
				break;
			default:
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Unknown login message received! (0x%.8X) Delete Client", header->msg_id);
				PutLogList(G_cTxt);
				break;
			}
			DeleteLoginClient(iClientH);
		}
								  break;
		}

	}
}

bool CGame::bPutMsgQuene(char cFrom, char* pData, size_t dwMsgSize, int iIndex, char cKey)
{
	return m_msgQueue.Push(cFrom, pData, dwMsgSize, iIndex, cKey);
}


bool CGame::bGetMsgQuene(char* pFrom, char* pData, size_t* pMsgSize, int* pIndex, char* pKey)
{
	return m_msgQueue.Pop(pFrom, pData, pMsgSize, pIndex, pKey);
}


void CGame::ClientCommonHandler(int iClientH, char* pData)
{
	uint16_t wCommand;
	short sX, sY;
	int iV1, iV2, iV3, iV4;
	char cDir;
	const char* pString;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	const auto* req = hb::net::PacketCast<hb::net::PacketCommandCommonWithString>(
		pData, sizeof(hb::net::PacketCommandCommonWithString));
	if (!req) return;
	wCommand = req->base.header.msg_type;
	sX = req->base.x;
	sY = req->base.y;
	cDir = static_cast<char>(req->base.dir);
	iV1 = req->v1;
	iV2 = req->v2;
	iV3 = req->v3;
	pString = req->text;
	iV4 = req->v4;
	switch (wCommand) {

		//50Cent - Repair All
	case DEF_COMMONTYPE_REQ_REPAIRALL:
		RequestRepairAllItemsHandler(iClientH);
		break;
	case DEF_COMMONTYPE_REQ_REPAIRALLDELETE:
		RequestRepairAllItemsDeleteHandler(iClientH, iV1);
		break;
	case DEF_COMMONTYPE_REQ_REPAIRALLCONFIRM:
		RequestRepairAllItemsConfirmHandler(iClientH);
		break;

		// Crafting
	case DEF_COMMONTYPE_CRAFTITEM:
		ReqCreateCraftingHandler(iClientH, pData);
		break;

		// New 15/05/2004
	case DEF_COMMONTYPE_REQ_CREATESLATE:
		ReqCreateSlateHandler(iClientH, pData);
		break;

		// 2.06 - by KLKS
	case DEF_COMMONTYPE_REQ_CHANGEPLAYMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> MSGID_REQUEST_CIVILRIGHT");
		RequestChangePlayMode(iClientH);
		break;

	case DEF_COMMONTYPE_SETGUILDTELEPORTLOC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDTELEPORTLOC");
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, "middleland");
		break;

	case DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC");
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;

	case DEF_COMMONTYPE_GUILDTELEPORT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GUILDTELEPORT");
		RequestGuildTeleportHandler(iClientH);
		break;

	case DEF_COMMONTYPE_SUMMONWARUNIT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SUMMONWARUNIT");
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;

	case DEF_COMMONTYPE_REQUEST_HELP:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_HELP");
		RequestHelpHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQUEST_MAPSTATUS:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_MAPSTATUS");
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY");
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQUEST_CANCELQUEST:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_CANCELQUEST");
		CancelQuestHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY");
		ActivateSpecialAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQUEST_JOINPARTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_JOINPARTY");
		JoinPartyHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_GETMAGICABILITY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GETMAGICABILITY");
		GetMagicAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_BUILDITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_BUILDITEM");
		BuildItemHandler(iClientH, pData);
		break;

	case DEF_COMMONTYPE_QUESTACCEPTED:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_QUESTACCEPTED");
		QuestAcceptedHandler(iClientH);
		break;

	case DEF_COMMONTYPE_CANCELEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CANCELEXCHANGEITEM");
		CancelExchangeItem(iClientH);
		break;

	case DEF_COMMONTYPE_CONFIRMEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CONFIRMEXCHANGEITEM");
		ConfirmExchangeItem(iClientH);
		break;

	case DEF_COMMONTYPE_SETEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETEXCHANGEITEM");
		SetExchangeItem(iClientH, iV1, iV2);
		break;

	case DEF_COMMONTYPE_REQ_GETHEROMANTLE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETHEROMANTLE");
		GetHeroMantleHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQ_GETOCCUPYFLAG:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFLAG");
		GetOccupyFlagHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX");
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_TALKTONPC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TALKTONPC");
		// works for client, but for npc it returns middleland
		// if ((m_pMapList[m_pNpcList[iV1]->m_cMapIndex]->m_cName) != (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) break;
		NpcTalkHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQ_CREATEPORTION:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_CREATEPORTION");
		ReqCreatePortionHandler(iClientH, pData);
		break;

	case DEF_COMMONTYPE_REQ_GETFISHTHISTIME:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETFISHTHISTIME");
		ReqGetFishThisTimeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM");
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQ_REPAIRITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEM");
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;

	case DEF_COMMONTYPE_REQ_SELLITEMCONFIRM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEMCONFIRM");
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;

	case DEF_COMMONTYPE_REQ_SELLITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEM");
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;

	case DEF_COMMONTYPE_REQ_USESKILL:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USESKILL");
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;

	case DEF_COMMONTYPE_REQ_USEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USEITEM");
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
		break;

	case DEF_COMMONTYPE_REQ_GETREWARDMONEY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETREWARDMONEY");
		GetRewardMoneyHandler(iClientH);
		break;

	case DEF_COMMONTYPE_ITEMDROP:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_ITEMDROP");
		DropItemHandler(iClientH, iV1, iV2, pString, true);
		break;

	case DEF_COMMONTYPE_EQUIPITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EQUIPITEM");
		bEquipItemHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQ_PURCHASEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_PURCHASEITEM");
		RequestPurchaseItemHandler(iClientH, pString, iV1, iV2);
		break;

	case DEF_COMMONTYPE_REQ_STUDYMAGIC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_STUDYMAGIC");
		RequestStudyMagicHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_REQ_TRAINSKILL:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_TRAINSKILL");
		//RequestTrainSkillHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_GIVEITEMTOCHAR:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GIVEITEMTOCHAR");
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_EXCHANGEITEMTOCHAR:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EXCHANGEITEMTOCHAR");
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDAPPROVE");
		JoinGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDREJECT");
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDAPPROVE");
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDREJECT");
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_RELEASEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_RELEASEITEM");
		ReleaseItemHandler(iClientH, iV1, true);
		break;

	case DEF_COMMONTYPE_TOGGLECOMBATMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLECOMBATMODE");
		ToggleCombatModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_MAGIC:
	{
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_MAGIC");
		// Parse as PacketCommandCommonWithTime to get target object ID from time_ms field
		const auto* magicReq = hb::net::PacketCast<hb::net::PacketCommandCommonWithTime>(
			pData, sizeof(hb::net::PacketCommandCommonWithTime));
		uint16_t targetObjectID = magicReq ? static_cast<uint16_t>(magicReq->time_ms) : 0;
		PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100), false, 0, targetObjectID);
	}
	break;

	case DEF_COMMONTYPE_TOGGLESAFEATTACKMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLESAFEATTACKMODE");
		ToggleSafeAttackModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET");
		GetFightzoneTicketHandler(iClientH);
		break;

		// Upgrade Item
	case DEF_COMMONTYPE_UPGRADEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_UPGRADEITEM");
		RequestItemUpgradeHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_REQGUILDNAME:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQGUILDNAME");
		RequestGuildNameHandler(iClientH, iV1, iV2);
		break;

	case DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY");
		RequestAcceptJoinPartyHandler(iClientH, iV1);
		break;

	default:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Unknown message received! (0x%.8X)", wCommand);
		PutLogList(G_cTxt);
		break;
	}
}

// New 07/05/2004
void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, const char* pItemName, bool bByPlayer)
{
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((sItemIndex < 0) || (sItemIndex >= hb::limits::MaxItems)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if ((iAmount != -1) && (iAmount < 0)) return;

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Consume) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Arrow)) &&
		(iAmount == -1))
		iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;


	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Consume) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Arrow)) &&
		(((int)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0)) {
		pItem = new CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == false) {
			delete pItem;
			return;
		}
		else {
			if (iAmount <= 0) {
				delete pItem;
				return;
			}
			pItem->m_dwCount = (uint32_t)iAmount;
		}

		if ((uint32_t)iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) {
			delete pItem;
			return;
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		// v1.41 !!!
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY, pItem);

		// v1.411 
		// v2.17 2002-7-31
		if (bByPlayer)
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem);
		else
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem, true);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, 0, 0);
	}
	else {

		ReleaseItemHandler(iClientH, sItemIndex, true);

		// v2.17
		if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex])
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);

		// v1.432
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType() == ItemEffectType::AlterItemDrop) &&
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) {
			delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
		}
		else {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
				m_pClientList[iClientH]->m_sY,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			// v1.41
			// v2.17 2002-7-31
			if (bByPlayer)
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			else
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[sItemIndex], true);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
				0,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); //v1.4 color
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, 0, 0);

		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	iCalcTotalWeight(iClientH);
}

//  int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: check if player is dropping item or picking up item
//  last updated		:: October 29, 2004; 7:12 PM; Hypnotoad
//	return value		:: int
int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
	char  cRemainItemColor;
	int   iRet, iEraseReq;
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	short sIDNum;
	uint32_t dwAttribute;
	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sIDNum, &cRemainItemColor, &dwAttribute);
	if (pItem != 0) {
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {

			_bItemLog(DEF_ITEMLOG_GET, iClientH, 0, pItem);

			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return 0;
			}

			// Broadcast remaining item state to nearby clients (clears tile if no items remain)
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM,
				m_pClientList[iClientH]->m_cMapIndex,
				sX, sY, sIDNum, 0, cRemainItemColor, dwAttribute);
		}
		else
		{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);

			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return 0;
			}
		}
	}

	{
		hb::net::PacketResponseMotionHeader pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_MOTION;
		pkt.header.msg_type = DEF_OBJECTMOTION_CONFIRM;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

bool CGame::_bAddClientItemList(int iClientH, CItem* pItem, int* pDelReq)
{


	if (m_pClientList[iClientH] == 0) return false;
	if (pItem == 0) return false;

	if ((pItem->GetItemType() == ItemType::Consume) || (pItem->GetItemType() == ItemType::Arrow)) {
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > _iCalcMaxLoad(iClientH))
			return false;
	}
	else {
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > _iCalcMaxLoad(iClientH))
			return false;
	}

	if ((pItem->GetItemType() == ItemType::Consume) || (pItem->GetItemType() == ItemType::Arrow)) {
		for(int i = 0; i < hb::limits::MaxItems; i++)
			if ((m_pClientList[iClientH]->m_pItemList[i] != 0) &&
				(m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == pItem->m_sIDnum)) {
				m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
				//delete pItem;
				*pDelReq = 1;

				iCalcTotalWeight(iClientH);

				return true;
			}
	}

	for(int i = 0; i < hb::limits::MaxItems; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == 0) {

			m_pClientList[iClientH]->m_pItemList[i] = pItem;
			m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
			m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

			*pDelReq = 0;

			if (pItem->GetItemType() == ItemType::Arrow)
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

			iCalcTotalWeight(iClientH);

			return true;
		}

	return false;
}

int CGame::_bAddClientBulkItemList(int iClientH, const char* pItemName, int iAmount)
{
	if (m_pClientList[iClientH] == nullptr) return 0;
	if (pItemName == nullptr || iAmount < 1) return 0;

	int iCreated = 0;
	CItem* pFirstItem = nullptr;

	for (int i = 0; i < iAmount; i++)
	{
		CItem* pItem = new CItem();
		if (!_bInitItemAttr(pItem, pItemName))
		{
			delete pItem;
			break;
		}

		// Weight check
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > _iCalcMaxLoad(iClientH))
		{
			delete pItem;
			break;
		}

		// Find an empty slot directly (no merge)
		bool bAdded = false;
		for (int j = 0; j < hb::limits::MaxItems; j++)
		{
			if (m_pClientList[iClientH]->m_pItemList[j] == nullptr)
			{
				m_pClientList[iClientH]->m_pItemList[j] = pItem;
				m_pClientList[iClientH]->m_ItemPosList[j].x = 40;
				m_pClientList[iClientH]->m_ItemPosList[j].y = 30;
				iCalcTotalWeight(iClientH);
				if (pFirstItem == nullptr) pFirstItem = pItem;
				iCreated++;
				bAdded = true;
				break;
			}
		}

		if (!bAdded)
		{
			delete pItem;
			break;
		}
	}

	// Send one bulk notification with total count
	if (iCreated > 0 && pFirstItem != nullptr)
	{
		hb::net::PacketNotifyItemObtained pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = DEF_NOTIFY_ITEMOBTAINED_BULK;
		pkt.is_new = 1;
		memcpy(pkt.name, pFirstItem->m_cName, sizeof(pkt.name));
		pkt.count = iCreated;
		pkt.item_type = pFirstItem->m_cItemType;
		pkt.equip_pos = pFirstItem->m_cEquipPos;
		pkt.is_equipped = 0;
		pkt.level_limit = pFirstItem->m_sLevelLimit;
		pkt.gender_limit = pFirstItem->m_cGenderLimit;
		pkt.cur_lifespan = pFirstItem->m_wCurLifeSpan;
		pkt.weight = pFirstItem->m_wWeight;
		pkt.sprite = pFirstItem->m_sSprite;
		pkt.sprite_frame = pFirstItem->m_sSpriteFrame;
		pkt.item_color = pFirstItem->m_cItemColor;
		pkt.spec_value2 = static_cast<uint8_t>(pFirstItem->m_sItemSpecEffectValue2);
		pkt.attribute = pFirstItem->m_dwAttribute;
		pkt.item_id = pFirstItem->m_sIDnum;
		pkt.max_lifespan = pFirstItem->m_wMaxLifeSpan;
		m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}

	return iCreated;
}

bool CGame::bEquipItemHandler(int iClientH, short sItemIndex, bool bNotify)
{
	char cHeroArmorType;
	EquipPos cEquipPos;

	if (m_pClientList[iClientH] == 0) return false;
	if ((sItemIndex < 0) || (sItemIndex >= hb::limits::MaxItems)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() != ItemType::Equip) return false;

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return false;

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == 0) &&
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return false;


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return false;
			break;
		case 4:
		case 5:
		case 6:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return false;
			break;
		}
	}

	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 100) return false;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetEquipPos();

	if ((cEquipPos == EquipPos::Body) || (cEquipPos == EquipPos::Leggings) ||
		(cEquipPos == EquipPos::Arms) || (cEquipPos == EquipPos::Head)) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
		case 10: // Str
			if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)], true);
				return false;
			}
			break;
		case 11: // Dex
			if ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)], true);
				return false;
			}
			break;
		case 12: // Vit
			if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)], true);
				return false;
			}
			break;
		case 13: // Int
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)], true);
				return false;
			}
			break;
		case 14: // Mag
			if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)], true);
				return false;
			}
			break;
		case 15: // Chr
			if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)], true);
				return false;
			}
			break;
		}
	}

	if (cEquipPos == EquipPos::TwoHand) {
		// Stormbringer
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) < 65) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, 0, 0);
				ReleaseItemHandler(iClientH, sItemIndex, true);
				return false;
			}
		}
	}

	if (cEquipPos == EquipPos::RightHand) {
		// Resurrection wand(MS.10) or Resurrection wand(MS.20)
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
			if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 99 && (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) > 99 && m_pClientList[iClientH]->m_iSpecialAbilityTime < 1) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = true;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
			}
		}
	}

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType() == ItemEffectType::AttackSpecAbility) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType() == ItemEffectType::DefenseSpecAbility)) {

		if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[m_pClientList[iClientH]->m_iSpecialAbilityEquipPos], 0, 0);
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[m_pClientList[iClientH]->m_iSpecialAbilityEquipPos], true);
			}
		}
	}


	if (cEquipPos == EquipPos::None) return false;

	if (cEquipPos == EquipPos::TwoHand) {
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)] != -1)
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)], false);
		else {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)], false);
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::LeftHand)] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::LeftHand)], false);
		}
	}
	else {
		if ((cEquipPos == EquipPos::LeftHand) || (cEquipPos == EquipPos::RightHand)) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] != -1)
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)], false);
		}

		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)] != -1)
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)], false);
	}


	if (cEquipPos == EquipPos::FullBody) {
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Head)] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Head)], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Body)] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Body)], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Arms)] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Arms)], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Leggings)] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Leggings)], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Pants)] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Pants)], false);
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Back)] != -1) {
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Back)], false);
		}
	}
	else {
		if (cEquipPos == EquipPos::Head || cEquipPos == EquipPos::Body || cEquipPos == EquipPos::Arms ||
			cEquipPos == EquipPos::Leggings || cEquipPos == EquipPos::Pants || cEquipPos == EquipPos::Back) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::FullBody)] != -1) {
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::FullBody)], false);
			}
		}
		if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)] != -1)
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)], false);
	}


	m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)] = sItemIndex;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = true;

	ApplyEquipAppearance(
		m_pClientList[iClientH]->m_appearance,
		cEquipPos,
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue,
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor);

	// Weapon-specific: compute attack delay and reset combo
	if (cEquipPos == EquipPos::RightHand || cEquipPos == EquipPos::TwoHand) {
		int speed = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed;
		speed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
		if (speed < 0) speed = 0;
		m_pClientList[iClientH]->m_status.iAttackDelay = static_cast<uint8_t>(speed);
		m_pClientList[iClientH]->m_iComboAttackCount = 0;
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType() == ItemEffectType::AttackSpecAbility) {
		m_pClientList[iClientH]->m_appearance.iShieldGlare = 0;
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 1:
			m_pClientList[iClientH]->m_appearance.iShieldGlare = 1;
			break;

		case 2:
			m_pClientList[iClientH]->m_appearance.iShieldGlare = 3;
			break;

		case 3:
			m_pClientList[iClientH]->m_appearance.iShieldGlare = 2;
			break;
		}
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType() == ItemEffectType::DefenseSpecAbility) {
		m_pClientList[iClientH]->m_appearance.iWeaponGlare = 0;
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0:
			break;
		case 50:
		case 51:
		case 52:
			m_pClientList[iClientH]->m_appearance.iWeaponGlare = 1;
			break;
		default:
			// m_sAppr4
			// 0x0002 Green
			// 0x0003 ice element
			// 0x0004 sparkle
			// 0x0005 sparkle green gm
			// 0x0006 sparkle green
			break;
		}
	}

	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = cHeroArmorType;

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);
	return true;

}

void CGame::SendEventToNearClient_TypeB(uint32_t dwMsgID, uint16_t wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
	int iRet, iShortCutIndex;
	bool bFlag;

	// OPTIMIZATION FIX #2: Early exit if no clients online
	if (m_iClientShortCut[0] == 0) return;

	// OPTIMIZATION FIX #2: Pre-check if any clients are in range before building packet
	bool bHasNearbyClients = false;
	iShortCutIndex = 0;
	while (m_iClientShortCut[iShortCutIndex] != 0) {
		int i = m_iClientShortCut[iShortCutIndex];
		if ((m_pClientList[i] != 0) &&
			(m_pClientList[i]->m_cMapIndex == cMapIndex) &&
			(m_pClientList[i]->m_sX >= sX - DEF_VIEWCENTER_X) &&
			(m_pClientList[i]->m_sX <= sX + DEF_VIEWCENTER_X) &&
			(m_pClientList[i]->m_sY >= sY - (DEF_VIEWCENTER_Y + 1)) &&
			(m_pClientList[i]->m_sY <= sY + (DEF_VIEWCENTER_Y + 1))) {
			bHasNearbyClients = true;
			break;
		}
		iShortCutIndex++;
	}

	// TEMPORARILY DISABLED FOR TESTING - Early exit if no clients in range
	if (false && !bHasNearbyClients) return;

	hb::net::PacketEventNearTypeBShort pkt{};
	pkt.header.msg_id = dwMsgID;
	pkt.header.msg_type = wMsgType;
	pkt.x = sX;
	pkt.y = sY;
	pkt.v1 = sV1;
	pkt.v2 = sV2;
	pkt.v3 = sV3;
	pkt.v4 = sV4;

	//for(int i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = true;
	iShortCutIndex = 0;
	while (bFlag) {
		// DEF_MAXCLIENTS 
		int i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = false;

		if ((bFlag) && (m_pClientList[i] != 0)) {
			if ((m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				(m_pClientList[i]->m_sX >= sX - DEF_VIEWCENTER_X) &&
				(m_pClientList[i]->m_sX <= sX + DEF_VIEWCENTER_X) &&
				(m_pClientList[i]->m_sY >= sY - (DEF_VIEWCENTER_Y + 1)) &&
				(m_pClientList[i]->m_sY <= sY + (DEF_VIEWCENTER_Y + 1))) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
		}
	}
}

void CGame::SendEventToNearClient_TypeB(uint32_t dwMsgID, uint16_t wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, uint32_t dwV4)
{
	int iRet, iShortCutIndex;
	bool bFlag;

	hb::net::PacketEventNearTypeBDword pkt{};
	pkt.header.msg_id = dwMsgID;
	pkt.header.msg_type = wMsgType;
	pkt.x = sX;
	pkt.y = sY;
	pkt.v1 = sV1;
	pkt.v2 = sV2;
	pkt.v3 = sV3;
	pkt.v4 = dwV4;

	//for(int i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = true;
	iShortCutIndex = 0;
	while (bFlag) {
		// DEF_MAXCLIENTS 
		int i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = false;

		if ((bFlag) && (m_pClientList[i] != 0)) {
			if ((m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				(m_pClientList[i]->m_sX >= sX - DEF_VIEWCENTER_X) &&
				(m_pClientList[i]->m_sX <= sX + DEF_VIEWCENTER_X) &&
				(m_pClientList[i]->m_sY >= sY - (DEF_VIEWCENTER_Y + 1)) &&
				(m_pClientList[i]->m_sY <= sY + (DEF_VIEWCENTER_Y + 1))) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
		}
	}
}

//  int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is stopped
//  last updated		:: October 29, 2004; 6:46 PM; Hypnotoad
//	return value		:: int
int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
	int     iRet;
	short   sOwnerH;
	char    cOwnerType;

	if (m_pClientList[iClientH] == 0) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);
		if (sOwnerH != 0) {
			DeleteClient(iClientH, true, true);
			return 0;
		}
	}

	ClearSkillUsingStatus(iClientH);

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	m_pClientList[iClientH]->m_cDir = cDir;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	{
		hb::net::PacketResponseMotionHeader pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_MOTION;
		pkt.header.msg_type = DEF_OBJECTMOTION_CONFIRM;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char* pData, int iType)
{
	
	uint16_t wResult;
	char cCharName[DEF_CHARNAME], cTxt[120];
	int iRet;

	std::memset(cCharName, 0, sizeof(cCharName));
	//cp = (char *)(pData + hb::net::MessageOffsetType + 2);
	memcpy(cCharName, pData, DEF_CHARNAME - 1);
	//cp += 10;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (_strnicmp(m_pClientList[i]->m_cCharName, cCharName, DEF_CHARNAME - 1) == 0) &&
			(m_pClientList[i]->m_iLevel >= 20) && (m_pClientList[i]->m_iCharisma >= 20)) {

			//wp = (uint16_t *)(pData + hb::net::MessageOffsetType);
			switch (iType) {
			case 1: // DEF_LOGRESMSGTYPE_CONFIRM
				wResult = DEF_MSGTYPE_CONFIRM;
				m_pClientList[i]->m_iGuildRank = 0;
				std::snprintf(cTxt, sizeof(cTxt), "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);
				break;

			case 0: // DEF_LOGRESMSGTYPE_REJECT
				// "NONE".
				wResult = DEF_MSGTYPE_REJECT;
				std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
				memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
				m_pClientList[i]->m_iGuildRank = -1;
				m_pClientList[i]->m_iGuildGUID = -1;
				std::snprintf(cTxt, sizeof(cTxt), "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);
				break;
			}

			hb::net::PacketHeader pkt{};
			pkt.msg_id = MSGID_RESPONSE_CREATENEWGUILD;
			pkt.msg_type = wResult;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(i, true, true);
				return;
			}

			return;
		}

	std::snprintf(cTxt, sizeof(cTxt), "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char* pData, size_t dwMsgSize)
{
	char* cp;
	char cGuildName[21], cTxt[120], cData[100];
	int     iRet;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_bIsCrusadeMode) return;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestGuildAction>(
		pData, sizeof(hb::net::PacketRequestGuildAction));
	if (!pkt) return;
	std::memset(cGuildName, 0, sizeof(cGuildName));
	memcpy(cGuildName, pkt->guild, sizeof(pkt->guild));

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		std::snprintf(cTxt, sizeof(cTxt), "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		if ((m_pClientList[iClientH]->m_iLevel < 20) || (m_pClientList[iClientH]->m_iCharisma < 20) ||
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) ||
			(memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) != 0)) { // v1.4
			std::memset(cData, 0, sizeof(cData));

			hb::net::PacketHeader pkt{};
			pkt.msg_id = MSGID_RESPONSE_CREATENEWGUILD;
			pkt.msg_type = DEF_MSGTYPE_REJECT;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return;
			}
		}
		else {
			// . ->    Rank -1  .
			std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			std::memset(m_pClientList[iClientH]->m_cLocation, 0, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			// GUID  .
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + GameClock::GetTimeMS());

			//bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);

			char cData[512];
			std::memset(cData, 0, sizeof(cData));
			uint32_t* dwp;

			cp = (char*)cData;

			memcpy(cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
			cp += 20;

			memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
			cp += 10;

			dwp = (uint32_t*)cp;
			*dwp = (uint32_t)m_pClientList[iClientH]->m_iGuildGUID;
			cp += 4;

			RequestCreateNewGuild(iClientH, cData);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char* pData, size_t dwMsgSize)
{
	char* cp;
	char cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode) return;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestGuildAction>(
		pData, sizeof(hb::net::PacketRequestGuildAction));
	if (!pkt) return;
	std::memset(cGuildName, 0, sizeof(cGuildName));

	memcpy(cGuildName, pkt->guild, sizeof(pkt->guild));

	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
		std::snprintf(cTxt, sizeof(cTxt), "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		//bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);

		char cData[512];

		cp = (char*)(cData);

		memcpy((char*)cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
		cp += 10;

		memcpy((char*)cp, m_pClientList[iClientH]->m_cGuildName, 20);
		cp += 20;

		RequestDisbandGuild(iClientH, cData);
	}
}

void CGame::ResponseDisbandGuildHandler(char* pData, int iType)
{
	
	uint16_t wResult;
	char cCharName[DEF_CHARNAME], cTxt[120];
	int iRet;

	std::memset(cCharName, 0, sizeof(cCharName));
	//cp = (char *)(pData + hb::net::MessageOffsetType + 2);
	memcpy(cCharName, pData, DEF_CHARNAME - 1);
	//cp += 10;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (_strnicmp(m_pClientList[i]->m_cCharName, cCharName, DEF_CHARNAME - 1) == 0)) {

			//wp = (uint16_t *)(pData + hb::net::MessageOffsetType);
			switch (iType) {
			case 1: // DEF_LOGRESMSGTYPE_CONFIRM
				wResult = DEF_MSGTYPE_CONFIRM;
				std::snprintf(cTxt, sizeof(cTxt), "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);

				SendGuildMsg(i, DEF_NOTIFY_GUILDDISBANDED, 0, 0, 0);

				std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
				memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
				m_pClientList[i]->m_iGuildRank = -1;
				m_pClientList[i]->m_iGuildGUID = -1;
				break;

			case 0: // DEF_LOGRESMSGTYPE_REJECT
				wResult = DEF_MSGTYPE_REJECT;
				std::snprintf(cTxt, sizeof(cTxt), "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
				PutLogList(cTxt);
				break;
			}

			hb::net::PacketHeader pkt{};
			pkt.msg_id = MSGID_RESPONSE_DISBANDGUILD;
			pkt.msg_type = wResult;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(i, true, true);
				return;
			}
			return;
		}

	std::snprintf(cTxt, sizeof(cTxt), "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

// 05/29/2004 - Hypnotoad - Purchase Dicount updated to take charisma into consideration
void CGame::RequestPurchaseItemHandler(int iClientH, const char* pItemName, int iNum, int iItemId)
{
	CItem* pItem;
	uint32_t dwGoldCount, dwItemCount;
	uint16_t wTempPrice;
	int   iRet, iEraseReq, iGoldWeight;
	int   iCost, iDiscountRatio, iDiscountCost;
	double dTmp1, dTmp2, dTmp3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) {
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arefarm", 7) == 0)) {

			}
			else return;
		}

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvfarm", 7) == 0)) {

			}
			else return;
		}
	}


	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	// Determine item ID and count from client-provided item ID
	short sItemID = 0;
	dwItemCount = 1;

	if (iItemId > 0 && iItemId < DEF_MAXITEMTYPES) {
		sItemID = static_cast<short>(iItemId);
	}
	else {
		// No valid item ID provided
		return;
	}

	for(int i = 1; i <= iNum; i++) {

		pItem = new CItem;
		bool bInitOk = _bInitItemAttr(pItem, sItemID);
		if (bInitOk == false) {
			delete pItem;
		}
		else {

			if (pItem->m_bIsForSale == false) {
				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;

			iCost = pItem->m_wPrice * pItem->m_dwCount;


			dwGoldCount = dwGetItemCountByID(iClientH, hb::item::ItemId::Gold);

			iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma - 10) / 4);

			// 2.03 Discount Method
			// Charisma
			// iDiscountRatio = (m_pClientList[iClientH]->m_iCharisma / 4) -1;
			// if (iDiscountRatio == 0) iDiscountRatio = 1;

			dTmp1 = (double)(iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;

			if (iDiscountCost >= (iCost / 2)) iDiscountCost = (iCost / 2) - 1;

			if (dwGoldCount < (uint32_t)(iCost - iDiscountCost)) {
				delete pItem;

				{
					hb::net::PacketNotifyNotEnoughGold pkt{};
					pkt.header.msg_id = MSGID_NOTIFY;
					pkt.header.msg_type = DEF_NOTIFY_NOTENOUGHGOLD;
					pkt.item_index = -1;
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
				}
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
				}
				return;
			}

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				wTempPrice = (iCost - iDiscountCost);
				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMPURCHASED, pItem, wTempPrice);
				if (iEraseReq == 1) delete pItem;

				// Gold  .      .
				iGoldWeight = SetItemCountByID(iClientH, hb::item::ItemId::Gold, dwGoldCount - wTempPrice);
				iCalcTotalWeight(iClientH);

				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
				}
			}
			else
			{
				delete pItem;

				iCalcTotalWeight(iClientH);

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
				}
			}
		}
	}
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, uint16_t wObjectID, const char* pItemName)
{
	int iRet, iEraseReq;
	short sOwnerH;
	char cOwnerType, cCharName[DEF_NPCNAME];
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if ((sItemIndex < 0) || (sItemIndex >= hb::limits::MaxItems)) return;
	if (iAmount <= 0) return;


	std::memset(cCharName, 0, sizeof(cCharName));

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Consume) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Arrow)) &&
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (uint32_t)iAmount)) {

		pItem = new CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == false) {
			delete pItem;
			return;
		}
		else {
			pItem->m_dwCount = iAmount;
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

		// dX, dY     .
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		if (wObjectID != 0) {
			if (wObjectID < 10000) {
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != 0) {
						if ((uint16_t)sOwnerH != wObjectID) sOwnerH = 0;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != 0) {
						if ((uint16_t)sOwnerH != (wObjectID - 10000)) sOwnerH = 0;
					}
				}
			}
		}

		if (sOwnerH == 0) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4 color
		}
		else {
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, DEF_CHARNAME - 1);

				if (sOwnerH == iClientH) {
					delete pItem;
					return;
				}

				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq)) {
					iRet = SendItemNotifyMsg(sOwnerH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, true, true);
						break;
					}

					// v1.4
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, 0, cCharName);
				}
				else {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
						m_pClientList[iClientH]->m_sY,
						pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);

					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4 color

					{
						iRet = SendItemNotifyMsg(sOwnerH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
					}


					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, true, true);
						break;
					}

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, 0, cCharName);
				}

			}
			else {
				// NPC  .
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, DEF_NPCNAME - 1);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC     .
					if (bSetItemToBankItem(iClientH, pItem) == false) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, 0, 0, 0, 0);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

						// v1.411  
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);

						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color
					}
				}
				else {
					// NPC       .
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, pItem);

					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color
				}
			}
		}
	}
	else {

		ReleaseItemHandler(iClientH, sItemIndex, true);

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Arrow)
			m_pClientList[iClientH]->m_cArrowIndex = -1;

		// dX, dY     .
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); // dX, dY   .         .

		if (wObjectID != 0) {
			if (wObjectID < 10000) {
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != 0) {
						if ((uint16_t)sOwnerH != wObjectID) sOwnerH = 0;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != 0) {
						if ((uint16_t)sOwnerH != (wObjectID - 10000)) sOwnerH = 0;
					}
				}
			}
		}

		if (sOwnerH == 0) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
				m_pClientList[iClientH]->m_sY,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
				0,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, 0, 0);
		}
		else {
			// . @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, DEF_CHARNAME - 1);
				pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];


				if (pItem->m_sIDnum == 88) {

					// iClientH  sOwnerH   .
					// sOwnerH         .
					if ((m_pClientList[iClientH]->m_iGuildRank == -1) &&
						(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
						(memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[sOwnerH]->m_cLocation, 10) == 0) &&
						(m_pClientList[sOwnerH]->m_iGuildRank == 0)) {
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION, 0, 0, 0, 0);
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, 0, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, (int)-1, pItem);

						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {

					// iClientH  sOwnerH   .
					// sOwnerH  iClientH    iClientH
					if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
						(m_pClientList[iClientH]->m_iGuildRank != -1) &&
						(m_pClientList[sOwnerH]->m_iGuildRank == 0)) {
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, 0, 0, 0, 0);
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, 0, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, (int)-1, pItem);

						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq)) {

					_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					iRet = SendItemNotifyMsg(sOwnerH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, true, true);
						break;
					}
				}
				else {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
						m_pClientList[iClientH]->m_sY,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
						0,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

					{
						iRet = SendItemNotifyMsg(sOwnerH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
					}


					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(sOwnerH, true, true);
						break;
					}

					std::memset(cCharName, 0, sizeof(cCharName));
				}
			}
			else {
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, DEF_NPCNAME - 1);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					if (bSetItemToBankItem(iClientH, sItemIndex) == false) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, 0, 0, 0, 0);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
							m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
							0,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color
					}
				}
				else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) {
					if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {

						if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
							SendNotifyMsg(iClientH, iClientH, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, 0, 0, 0, 0);

							std::memset(m_pClientList[iClientH]->m_cGuildName, 0, sizeof(m_pClientList[iClientH]->m_cGuildName));
							memcpy(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
							m_pClientList[iClientH]->m_iGuildRank = -1;
							m_pClientList[iClientH]->m_iGuildGUID = -1;

							SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

							m_pClientList[iClientH]->m_iExp -= 300;
							if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
						}

						delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
					}
					else {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
							m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
							0,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

						std::memset(cCharName, 0, sizeof(cCharName));

					}
				}
				else {
					// NPC       .

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
						m_pClientList[iClientH]->m_sY,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					_bItemLog(DEF_ITEMLOG_DROP, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum,
						0,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute); // v1.4 color

					std::memset(cCharName, 0, sizeof(cCharName));
				}
			}

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, 0, cCharName);
		}

	REMOVE_ITEM_PROCEDURE:

		if (m_pClientList[iClientH] == 0) return;

		// . delete !
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;

		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	iCalcTotalWeight(iClientH);
}

void CGame::SendNotifyMsg(int iFromH, int iToH, uint16_t wMsgType, uint32_t sV1, uint32_t sV2, uint32_t sV3, char* pString, uint32_t sV4, uint32_t sV5, uint32_t sV6, uint32_t sV7, uint32_t sV8, uint32_t sV9, char* pString2)
{
	int iRet = 0;

	if (m_pClientList[iToH] == 0) return;

	// !!! sV1, sV2, sV3 DWORD .
	switch (wMsgType) {
	case DEF_NOTIFY_CURLIFESPAN:
	{
		hb::net::PacketNotifyCurLifeSpan pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<int32_t>(sV1);
		pkt.cur_lifespan = static_cast<int32_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_NOTIFY_HELDENIANCOUNT:
	{
		hb::net::PacketNotifyHeldenianCount pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.aresden_tower_left = static_cast<int16_t>(sV1);
		pkt.elvine_tower_left = static_cast<int16_t>(sV2);
		pkt.aresden_flags = static_cast<int16_t>(sV3);
		pkt.elvine_flags = static_cast<int16_t>(sV4);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_NOMOREAGRICULTURE:
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT:
	case DEF_NOTIFY_AGRICULTURENOAREA:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 18/05/2004
	case DEF_NOTIFY_SPAWNEVENT:
	{
		hb::net::PacketNotifySpawnEvent pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.monster_id = static_cast<uint8_t>(sV3);
		pkt.x = static_cast<int16_t>(sV1);
		pkt.y = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_QUESTCOUNTER:
	{
		hb::net::PacketNotifyQuestCounter pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.current_count = static_cast<int32_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_APOCGATECLOSE:
	case DEF_NOTIFY_APOCGATEOPEN:
	{
		hb::net::PacketNotifyApocGateOpen pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.gate_x = static_cast<int32_t>(sV1);
		pkt.gate_y = static_cast<int32_t>(sV2);
		if (pString != 0) {
			memcpy(pkt.map_name, pString, sizeof(pkt.map_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_ABADDONKILLED:
	{
		hb::net::PacketNotifyAbaddonKilled pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		memcpy(pkt.killer_name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.killer_name));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_APOCFORCERECALLPLAYERS:
	case DEF_NOTIFY_APOCGATESTARTMSG:
	case DEF_NOTIFY_APOCGATEENDMSG:
	case DEF_NOTIFY_NORECALL:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_FORCERECALLTIME:
	{
		hb::net::PacketNotifyForceRecallTime pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.seconds_left = static_cast<uint16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 16/05/2004
	//0xB4E2, 0xBEB
	case DEF_NOTIFY_MONSTERCOUNT:
	case DEF_NOTIFY_SLATE_STATUS:
		if (wMsgType == DEF_NOTIFY_MONSTERCOUNT) {
			hb::net::PacketNotifyMonsterCount pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.count = static_cast<int16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifySimpleShort pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.value = static_cast<int16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

		//0x0BE5, 0x0BE7, 0x0BE8, 0x0BEA
	case DEF_NOTIFY_0BE8:
	case DEF_NOTIFY_HELDENIANTELEPORT:
	case DEF_NOTIFY_HELDENIANEND:
	case DEF_NOTIFY_RESURRECTPLAYER:
	case DEF_NOTIFY_SLATE_EXP:
	case DEF_NOTIFY_SLATE_MANA:
	case DEF_NOTIFY_SLATE_INVINCIBLE:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SLATE_CREATEFAIL:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SLATE_CREATESUCCESS:
	{
		hb::net::PacketNotifySimpleInt pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.value = static_cast<int32_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 07/05/2004
	// Party Notify Msg's
	case DEF_NOTIFY_PARTY:
		switch (sV1) {
		case 4:
		case 6:
		{
			hb::net::PacketNotifyPartyName pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.type = static_cast<int16_t>(sV1);
			pkt.v2 = static_cast<int16_t>(sV2);
			pkt.v3 = static_cast<int16_t>(sV3);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			break;
		}
		case 5:
		{
			hb::net::PacketWriter writer;
			writer.Reserve(sizeof(hb::net::PacketNotifyPartyList) + (sV3 * 11));

			auto* pkt = writer.Append<hb::net::PacketNotifyPartyList>();
			pkt->header.msg_id = MSGID_NOTIFY;
			pkt->header.msg_type = wMsgType;
			pkt->type = static_cast<int16_t>(sV1);
			pkt->v2 = static_cast<int16_t>(sV2);
			pkt->count = static_cast<int16_t>(sV3);

			if (pString != 0 && sV3 > 0) {
				writer.AppendBytes(pString, sV3 * 11);
			}

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
			break;
		}
		default:
		{
			hb::net::PacketNotifyPartyBasic pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.type = static_cast<int16_t>(sV1);
			pkt.v2 = static_cast<int16_t>(sV2);
			pkt.v3 = static_cast<int16_t>(sV3);
			pkt.v4 = static_cast<int16_t>(sV4);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			break;
		}
		}
		break;

	case DEF_NOTIFY_REQGUILDNAMEANSWER:
	{
		hb::net::PacketNotifyReqGuildNameAnswer pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.guild_rank = static_cast<int16_t>(sV1);
		pkt.index = static_cast<int16_t>(sV2);
		if (pString != 0) {
			memcpy(pkt.guild_name, pString, sizeof(pkt.guild_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 06/05/2004
	// Upgrade Notify Msg's
	case DEF_NOTIFY_ITEMUPGRADEFAIL:
	{
		hb::net::PacketNotifyItemUpgradeFail pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.reason = static_cast<int16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ITEMATTRIBUTECHANGE:
	case DEF_NOTIFY_GIZONITEMUPGRADELEFT:
	{
		hb::net::PacketNotifyItemAttributeChange pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<int16_t>(sV1);
		pkt.attribute = sV2;
		pkt.spec_value1 = sV3;
		pkt.spec_value2 = sV4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_GIZONEITEMCHANGE:
	{
		hb::net::PacketNotifyGizonItemChange pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<int16_t>(sV1);
		pkt.item_type = static_cast<uint8_t>(sV2);
		pkt.cur_lifespan = static_cast<int16_t>(sV3);
		pkt.sprite = static_cast<int16_t>(sV4);
		pkt.sprite_frame = static_cast<int16_t>(sV5);
		pkt.item_color = static_cast<uint8_t>(sV6);
		pkt.spec_value2 = static_cast<uint8_t>(sV7);
		pkt.attribute = sV8;
		pkt.item_id = static_cast<int16_t>(sV9);
		if (pString != 0) {
			memcpy(pkt.item_name, pString, sizeof(pkt.item_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// 2.06 - by KLKS
	case DEF_NOTIFY_CHANGEPLAYMODE:
	{
		hb::net::PacketNotifyChangePlayMode pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != 0) {
			memcpy(pkt.location, pString, sizeof(pkt.location));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_TCLOC:
	{
		hb::net::PacketNotifyTCLoc pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.dest_x = static_cast<int16_t>(sV1);
		pkt.dest_y = static_cast<int16_t>(sV2);
		if (pString != 0) {
			memcpy(pkt.teleport_map, pString, sizeof(pkt.teleport_map));
		}
		pkt.construct_x = static_cast<int16_t>(sV4);
		pkt.construct_y = static_cast<int16_t>(sV5);
		if (pString2 != 0) {
			memcpy(pkt.construct_map, pString2, sizeof(pkt.construct_map));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	//New 11/05/2004
	case DEF_NOTIFY_GRANDMAGICRESULT:
	{
		hb::net::PacketWriter writer;
		writer.Reserve(sizeof(hb::net::PacketNotifyGrandMagicResultHeader) + (sV9 * 2));

		auto* pkt = writer.Append<hb::net::PacketNotifyGrandMagicResultHeader>();
		pkt->header.msg_id = MSGID_NOTIFY;
		pkt->header.msg_type = wMsgType;
		pkt->crashed_structures = static_cast<uint16_t>(sV1);
		pkt->structure_damage = static_cast<uint16_t>(sV2);
		pkt->casualities = static_cast<uint16_t>(sV3);
		if (pString != 0) {
			memcpy(pkt->map_name, pString, sizeof(pkt->map_name));
		}
		pkt->active_structure = static_cast<uint16_t>(sV4);
		pkt->value_count = static_cast<uint16_t>(sV9);

		if (sV9 > 0 && pString2 != 0) {
			writer.AppendBytes(pString2 + 2, sV9 * 2);
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	}
	break;

	case DEF_NOTIFY_MAPSTATUSNEXT:
	{
		hb::net::PacketWriter writer;
		writer.Reserve(sizeof(hb::net::PacketHeader) + sV1);

		auto* pkt = writer.Append<hb::net::PacketHeader>();
		pkt->msg_id = MSGID_NOTIFY;
		pkt->msg_type = wMsgType;

		if (pString != 0 && sV1 > 0) {
			writer.AppendBytes(pString, sV1);
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	}
	break;

	case DEF_NOTIFY_MAPSTATUSLAST:
	{
		hb::net::PacketWriter writer;
		writer.Reserve(sizeof(hb::net::PacketHeader) + sV1);

		auto* pkt = writer.Append<hb::net::PacketHeader>();
		pkt->msg_id = MSGID_NOTIFY;
		pkt->msg_type = wMsgType;

		if (pString != 0 && sV1 > 0) {
			writer.AppendBytes(pString, sV1);
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	}
	break;

	case DEF_NOTIFY_LOCKEDMAP:
	{
		hb::net::PacketNotifyLockedMap pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.seconds_left = static_cast<int16_t>(sV1);
		if (pString != 0) {
			memcpy(pkt.map_name, pString, sizeof(pkt.map_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_BUILDITEMSUCCESS:
	case DEF_NOTIFY_BUILDITEMFAIL:
	{
		hb::net::PacketNotifyBuildItemResult pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (sV1 >= 0) {
			pkt.item_id = static_cast<int16_t>(sV1);
		}
		else {
			pkt.item_id = static_cast<int16_t>(sV1 + 10000);
		}
		pkt.item_count = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_HELP:
	case DEF_NOTIFY_QUESTREWARD:
	{
		hb::net::PacketNotifyQuestReward pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.who = static_cast<int16_t>(sV1);
		pkt.flag = static_cast<int16_t>(sV2);
		pkt.amount = static_cast<int32_t>(sV3);
		if (pString != 0) {
			memcpy(pkt.reward_name, pString, sizeof(pkt.reward_name));
		}
		pkt.contribution = static_cast<int32_t>(sV4);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CANNOTCONSTRUCT:
	{
		hb::net::PacketNotifyCannotConstruct pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.reason = static_cast<int16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_NOTIFY_METEORSTRIKECOMING:
	{
		hb::net::PacketNotifyMeteorStrikeComing pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.phase = static_cast<int16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_NOTIFY_OBSERVERMODE:
	{
		hb::net::PacketNotifyObserverMode pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.enabled = static_cast<int16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_NOTIFY_SPELLINTERRUPTED:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_NOTIFY_METEORSTRIKEHIT:
	case DEF_NOTIFY_HELPFAILED:
	case DEF_NOTIFY_SPECIALABILITYENABLED:
	case DEF_NOTIFY_FORCEDISCONN:
	case DEF_NOTIFY_QUESTCOMPLETED:
	case DEF_NOTIFY_QUESTABORTED:
		if (wMsgType == DEF_NOTIFY_FORCEDISCONN) {
			hb::net::PacketNotifyForceDisconn pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.seconds = static_cast<uint16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifySimpleShort pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.value = static_cast<int16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_QUESTCONTENTS:
	{
		hb::net::PacketNotifyQuestContents pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.who = static_cast<int16_t>(sV1);
		pkt.quest_type = static_cast<int16_t>(sV2);
		pkt.contribution = static_cast<int16_t>(sV3);
		pkt.target_type = static_cast<int16_t>(sV4);
		pkt.target_count = static_cast<int16_t>(sV5);
		pkt.x = static_cast<int16_t>(sV6);
		pkt.y = static_cast<int16_t>(sV7);
		pkt.range = static_cast<int16_t>(sV8);
		pkt.is_completed = static_cast<int16_t>(sV9);
		if (pString2 != 0) {
			memcpy(pkt.target_name, pString2, sizeof(pkt.target_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_ENERGYSPHERECREATED:
	{
		hb::net::PacketNotifyEnergySphereCreated pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.x = static_cast<int16_t>(sV1);
		pkt.y = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;
	case DEF_NOTIFY_ITEMCOLORCHANGE:
	{
		hb::net::PacketNotifyItemColorChange pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<int16_t>(sV1);
		pkt.item_color = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
	case DEF_NOTIFY_CANCELEXCHANGEITEM:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SETEXCHANGEITEM:
	{
		hb::net::PacketNotifyExchangeItem pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.dir = static_cast<int16_t>(sV1);
		pkt.sprite = static_cast<int16_t>(sV2);
		pkt.sprite_frame = static_cast<int16_t>(sV3);
		pkt.amount = static_cast<int32_t>(sV4);
		pkt.color = static_cast<uint8_t>(sV5);
		pkt.cur_life = static_cast<int16_t>(sV6);
		pkt.max_life = static_cast<int16_t>(sV7);
		pkt.performance = static_cast<int16_t>(sV8);
		if (pString != 0) {
			memcpy(pkt.item_name, pString, sizeof(pkt.item_name));
		}
		memcpy(pkt.char_name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.char_name));
		pkt.attribute = static_cast<uint32_t>(sV9);
		pkt.item_id = static_cast<int16_t>(reinterpret_cast<intptr_t>(pString2));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
	{
		hb::net::PacketNotifyExchangeItem pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.dir = static_cast<int16_t>(sV1);
		pkt.sprite = static_cast<int16_t>(sV2);
		pkt.sprite_frame = static_cast<int16_t>(sV3);
		pkt.amount = static_cast<int32_t>(sV4);
		pkt.color = static_cast<uint8_t>(sV5);
		pkt.cur_life = static_cast<int16_t>(sV6);
		pkt.max_life = static_cast<int16_t>(sV7);
		pkt.performance = static_cast<int16_t>(sV8);
		if (pString != 0) {
			memcpy(pkt.item_name, pString, sizeof(pkt.item_name));
		}
		memcpy(pkt.char_name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.char_name));
		pkt.attribute = static_cast<uint32_t>(sV9);
		pkt.item_id = static_cast<int16_t>(reinterpret_cast<intptr_t>(pString2));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_NOTFLAGSPOT:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ITEMPOSLIST:
	{
		hb::net::PacketNotifyItemPosList pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		for(int i = 0; i < hb::limits::MaxItems; i++) {
			pkt.positions[i * 2] = static_cast<int16_t>(m_pClientList[iToH]->m_ItemPosList[i].x);
			pkt.positions[i * 2 + 1] = static_cast<int16_t>(m_pClientList[iToH]->m_ItemPosList[i].y);
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ENEMYKILLS:
	{
		hb::net::PacketNotifyEnemyKills pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.count = static_cast<int32_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CRUSADE:
	{
		hb::net::PacketNotifyCrusade pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.crusade_mode = static_cast<int32_t>(sV1);
		pkt.crusade_duty = static_cast<int32_t>(sV2);
		pkt.v3 = static_cast<int32_t>(sV3);
		pkt.v4 = static_cast<int32_t>(sV4);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
	{
		hb::net::PacketNotifyConstructionPoint pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.construction_point = static_cast<int16_t>(sV1);
		pkt.war_contribution = static_cast<int16_t>(sV2);
		pkt.notify_type = static_cast<int16_t>(sV3);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SPECIALABILITYSTATUS:
	{
		hb::net::PacketNotifySpecialAbilityStatus pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.status_type = static_cast<int16_t>(sV1);
		pkt.ability_type = static_cast<int16_t>(sV2);
		pkt.seconds_left = static_cast<int16_t>(sV3);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_DAMAGEMOVE:
	{
		hb::net::PacketNotifyDamageMove pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.dir = static_cast<uint8_t>(sV1);
		pkt.amount = static_cast<int16_t>(sV2);
		pkt.weapon = static_cast<uint8_t>(sV3);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		if (wMsgType == DEF_NOTIFY_RESPONSE_CREATENEWPARTY) {
			hb::net::PacketNotifyResponseCreateNewParty pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.result = static_cast<int16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyDownSkillIndexSet pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.skill_index = static_cast<uint16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_HELDENIANSTART:
	case DEF_NOTIFY_NPCTALK:
	{
		hb::net::PacketNotifyNpcTalk pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.type = static_cast<int16_t>(sV1);
		pkt.response = static_cast<int16_t>(sV2);
		pkt.amount = static_cast<int16_t>(sV3);
		pkt.contribution = static_cast<int16_t>(sV4);
		pkt.target_type = static_cast<int16_t>(sV5);
		pkt.target_count = static_cast<int16_t>(sV6);
		pkt.x = static_cast<int16_t>(sV7);
		pkt.y = static_cast<int16_t>(sV8);
		pkt.range = static_cast<int16_t>(sV9);
		if (pString != 0) {
			memcpy(pkt.reward_name, pString, sizeof(pkt.reward_name));
		}
		if (pString2 != 0) {
			memcpy(pkt.target_name, pString2, sizeof(pkt.target_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// Crafting
	case DEF_NOTIFY_CRAFTING_FAIL:		//reversed by Snoopy: 0x0BF1:
	{
		hb::net::PacketNotifyCraftingFail pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.reason = static_cast<int32_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_CRAFTING_SUCCESS:		//reversed by Snoopy: 0x0BF0
	case DEF_NOTIFY_PORTIONSUCCESS:
	case DEF_NOTIFY_LOWPORTIONSKILL:
	case DEF_NOTIFY_PORTIONFAIL:
	case DEF_NOTIFY_NOMATCHINGPORTION:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SUPERATTACKLEFT:
	{
		hb::net::PacketNotifySuperAttackLeft pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.left = static_cast<int16_t>(m_pClientList[iToH]->m_iSuperAttackLeft);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SAFEATTACKMODE:
	{
		hb::net::PacketNotifySafeAttackMode pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.enabled = m_pClientList[iToH]->m_bIsSafeAttackMode ? 1 : 0;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_QUERY_JOINPARTY:
	case DEF_NOTIFY_IPACCOUNTINFO:
		if (wMsgType == DEF_NOTIFY_QUERY_JOINPARTY) {
			hb::net::PacketWriter writer;
			writer.Reserve(sizeof(hb::net::PacketHeader) + 11);

			auto* pkt = writer.Append<hb::net::PacketHeader>();
			pkt->msg_id = MSGID_NOTIFY;
			pkt->msg_type = wMsgType;

			std::size_t name_len = 0;
			if (pString != 0) {
				name_len = std::strlen(pString);
				if (name_len > 10) {
					name_len = 10;
				}
				writer.AppendBytes(pString, name_len);
			}
			writer.AppendBytes("", 1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
		}
		else {
			hb::net::PacketWriter writer;
			writer.Reserve(sizeof(hb::net::PacketHeader) + 510);

			auto* pkt = writer.Append<hb::net::PacketHeader>();
			pkt->msg_id = MSGID_NOTIFY;
			pkt->msg_type = wMsgType;

			std::size_t text_len = 0;
			if (pString != 0) {
				text_len = std::strlen(pString);
				if (text_len >= 509) {
					text_len = 509;
				}
				writer.AppendBytes(pString, text_len);
			}
			writer.AppendBytes("", 1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
		}
		break;

	case DEF_NOTIFY_REWARDGOLD:
	{
		hb::net::PacketNotifyRewardGold pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.gold = static_cast<uint32_t>(m_pClientList[iToH]->m_iRewardGold);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SERVERSHUTDOWN:
	{
		hb::net::PacketNotifyServerShutdown pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.mode = static_cast<uint8_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
	case DEF_NOTIFY_WHETHERCHANGE:
		if (wMsgType == DEF_NOTIFY_GLOBALATTACKMODE) {
			hb::net::PacketNotifyGlobalAttackMode pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.mode = static_cast<uint8_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyWhetherChange pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.status = static_cast<uint8_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_FISHCANCELED:
	case DEF_NOTIFY_FISHSUCCESS:
	case DEF_NOTIFY_FISHFAIL:
		if (wMsgType == DEF_NOTIFY_FISHCANCELED) {
			hb::net::PacketNotifyFishCanceled pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.reason = static_cast<uint16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifySimpleShort pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.value = static_cast<int16_t>(sV1);
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_DEBUGMSG:
	{
		hb::net::PacketNotifySimpleShort pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.value = static_cast<int16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_FISHCHANCE:
	{
		hb::net::PacketNotifyFishChance pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.chance = static_cast<uint16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
	case DEF_NOTIFY_EVENTFISHMODE:
		if (wMsgType == DEF_NOTIFY_ENERGYSPHEREGOALIN) {
			hb::net::PacketNotifyEnergySphereGoalIn pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.result = static_cast<int16_t>(sV1);
			pkt.side = static_cast<int16_t>(sV2);
			pkt.goal = static_cast<int16_t>(sV3);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyEventFishMode pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.price = static_cast<uint16_t>(sV1);
			pkt.sprite = static_cast<uint16_t>(sV2);
			pkt.sprite_frame = static_cast<uint16_t>(sV3);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_NOTICEMSG:
	{
		char buf[sizeof(hb::net::PacketHeader) + 256]{};
		auto* pkt = reinterpret_cast<hb::net::PacketNotifyNoticeMsg*>(buf);
		pkt->header.msg_id = MSGID_NOTIFY;
		pkt->header.msg_type = wMsgType;
		std::size_t msg_len = 0;
		if (pString != 0) {
			msg_len = std::strlen(pString);
			if (msg_len > 255) msg_len = 255;
			memcpy(pkt->text, pString, msg_len);
		}
		pkt->text[msg_len] = '\0';
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(buf,
			static_cast<int>(sizeof(hb::net::PacketHeader) + msg_len + 1));
		break;
	}

	case DEF_NOTIFY_STATUSTEXT:
	{
		hb::net::PacketNotifyStatusText pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != nullptr) {
			strncpy(pkt.text, pString, sizeof(pkt.text) - 1);
			pkt.text[sizeof(pkt.text) - 1] = '\0';
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_CANNOTRATING:
	{
		hb::net::PacketNotifyCannotRating pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.time_left = static_cast<uint16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_RATINGPLAYER:
	{
		hb::net::PacketNotifyRatingPlayer pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.result = static_cast<uint8_t>(sV1);
		if (pString != 0) {
			memcpy(pkt.name, pString, sizeof(pkt.name));
		}
		pkt.rating = m_pClientList[iToH]->m_iRating;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;


	case DEF_NOTIFY_TIMECHANGE:
	{
		hb::net::PacketNotifyTimeChange pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.sprite_alpha = static_cast<uint8_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_TOBERECALLED:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_HUNGER:
	{
		hb::net::PacketNotifyHunger pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.hunger = static_cast<uint8_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_PLAYERPROFILE:
	{
		hb::net::PacketNotifyPlayerProfile pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		std::size_t send_len = 0;
		if (pString != 0) {
			send_len = std::strlen(pString);
			if (send_len >= sizeof(pkt.text)) {
				send_len = sizeof(pkt.text) - 1;
			}
			std::size_t copy_len = send_len;
			if (copy_len > 100) {
				copy_len = 100;
			}
			memcpy(pkt.text, pString, copy_len);
		}
		pkt.text[send_len] = '\0';
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt),
			static_cast<int>(sizeof(hb::net::PacketHeader) + send_len + 1));
		break;
	}

	// New 10/05/2004 Changed
	case DEF_NOTIFY_WHISPERMODEON:
	case DEF_NOTIFY_WHISPERMODEOFF:
	case DEF_NOTIFY_PLAYERNOTONGAME:
	{
		hb::net::PacketNotifyPlayerNotOnGame pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != 0) {
			memcpy(pkt.name, pString, sizeof(pkt.name));
		}
		std::memset(pkt.filler, ' ', sizeof(pkt.filler));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 15/05/2004 Changed
	case DEF_NOTIFY_PLAYERONGAME:
	{
		hb::net::PacketNotifyPlayerOnGame pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != 0) {
			memcpy(pkt.name, pString, sizeof(pkt.name));
		}
		if (pString != 0 && pString[0] != 0 && pString2 != 0) {
			memcpy(pkt.map_name, pString2, sizeof(pkt.map_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// New 06/05/2004
	case DEF_NOTIFY_ITEMSOLD:
	case DEF_NOTIFY_ITEMREPAIRED:
	{
		hb::net::PacketNotifyItemRepaired pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_id = static_cast<uint32_t>(sV1);
		pkt.life = static_cast<uint32_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	// New 06/05/2004
	case DEF_NOTIFY_REPAIRITEMPRICE:
	case DEF_NOTIFY_SELLITEMPRICE:
	{
		if (wMsgType == DEF_NOTIFY_REPAIRITEMPRICE) {
			hb::net::PacketNotifyRepairItemPrice pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.v1 = static_cast<uint32_t>(sV1);
			pkt.v2 = static_cast<uint32_t>(sV2);
			pkt.v3 = static_cast<uint32_t>(sV3);
			pkt.v4 = static_cast<uint32_t>(sV4);
			if (pString != 0) {
				memcpy(pkt.item_name, pString, sizeof(pkt.item_name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifySellItemPrice pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.v1 = static_cast<uint32_t>(sV1);
			pkt.v2 = static_cast<uint32_t>(sV2);
			pkt.v3 = static_cast<uint32_t>(sV3);
			pkt.v4 = static_cast<uint32_t>(sV4);
			if (pString != 0) {
				memcpy(pkt.item_name, pString, sizeof(pkt.item_name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;
	}

	case DEF_NOTIFY_CANNOTREPAIRITEM:
	case DEF_NOTIFY_CANNOTSELLITEM:
		if (wMsgType == DEF_NOTIFY_CANNOTREPAIRITEM) {
			hb::net::PacketNotifyCannotRepairItem pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.item_index = static_cast<uint16_t>(sV1);
			pkt.reason = static_cast<uint16_t>(sV2);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyCannotSellItem pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.item_index = static_cast<uint16_t>(sV1);
			pkt.reason = static_cast<uint16_t>(sV2);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_SHOWMAP:
	{
		hb::net::PacketNotifyShowMap pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.map_id = static_cast<uint16_t>(sV1);
		pkt.map_type = static_cast<uint16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SKILLUSINGEND:
	{
		hb::net::PacketNotifySkillUsingEnd pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.result = static_cast<uint16_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_TOTALUSERS:
	{
		hb::net::PacketNotifyTotalUsers pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.total = static_cast<uint16_t>(m_iTotalGameServerClients);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_MAGICEFFECTOFF:
	case DEF_NOTIFY_MAGICEFFECTON:
	{
		hb::net::PacketNotifyMagicEffect pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.magic_type = static_cast<uint16_t>(sV1);
		pkt.effect = static_cast<uint32_t>(sV2);
		pkt.owner = static_cast<uint32_t>(sV3);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CANNOTITEMTOBANK:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SERVERCHANGE:
	{
		hb::net::PacketNotifyServerChange pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		memcpy(pkt.map_name, m_pClientList[iToH]->m_cMapName, sizeof(pkt.map_name));
		memcpy(pkt.log_server_addr, m_cLoginListenIP, sizeof(pkt.log_server_addr));
		pkt.log_server_port = m_iLoginListenPort;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SKILL:
	{
		hb::net::PacketNotifySkill pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.skill_index = static_cast<uint16_t>(sV1);
		pkt.skill_value = static_cast<uint16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_SETITEMCOUNT:
	{
		hb::net::PacketNotifySetItemCount pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<uint16_t>(sV1);
		pkt.count = static_cast<uint32_t>(sV2);
		pkt.notify = static_cast<uint8_t>(sV3);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
	{
		hb::net::PacketNotifyItemDepletedEraseItem pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<uint16_t>(sV1);
		pkt.use_result = static_cast<uint16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
	{
		hb::net::PacketNotifyDropItemFinCountChanged pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<uint16_t>(sV1);
		pkt.amount = static_cast<int32_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
	{
		hb::net::PacketNotifyDropItemFinEraseItem pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<uint16_t>(sV1);
		pkt.amount = static_cast<int32_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_CANNOTGIVEITEM:
	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		if (wMsgType == DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED) {
			hb::net::PacketNotifyGiveItemFinCountChanged pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.item_index = static_cast<uint16_t>(sV1);
			pkt.amount = static_cast<int32_t>(sV2);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyCannotGiveItem pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			pkt.item_index = static_cast<uint16_t>(sV1);
			pkt.amount = static_cast<int32_t>(sV2);
			if (pString != 0) {
				memcpy(pkt.name, pString, sizeof(pkt.name));
			}
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
	{
		hb::net::PacketNotifyGiveItemFinEraseItem pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.item_index = static_cast<uint16_t>(sV1);
		pkt.amount = static_cast<int32_t>(sV2);
		if (pString != 0) {
			memcpy(pkt.name, pString, sizeof(pkt.name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_ENEMYKILLREWARD:
	{
		hb::net::PacketNotifyEnemyKillReward pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.exp = static_cast<uint32_t>(m_pClientList[iToH]->m_iExp);
		pkt.kill_count = static_cast<uint32_t>(m_pClientList[iToH]->m_iEnemyKillCount);
		memcpy(pkt.killer_name, m_pClientList[sV1]->m_cCharName, sizeof(pkt.killer_name));
		memcpy(pkt.killer_guild, m_pClientList[sV1]->m_cGuildName, sizeof(pkt.killer_guild));
		pkt.killer_rank = static_cast<int16_t>(m_pClientList[sV1]->m_iGuildRank);
		pkt.war_contribution = static_cast<int16_t>(m_pClientList[iToH]->m_iWarContribution);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_PKCAPTURED:
	{
		hb::net::PacketNotifyPKcaptured pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.pk_count = static_cast<uint16_t>(sV1);
		pkt.victim_pk_count = static_cast<uint16_t>(sV2);
		if (pString != 0) {
			memcpy(pkt.victim_name, pString, sizeof(pkt.victim_name));
		}
		pkt.reward_gold = static_cast<uint32_t>(m_pClientList[iToH]->m_iRewardGold);
		pkt.exp = static_cast<uint32_t>(m_pClientList[iToH]->m_iExp);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_PKPENALTY:
	{
		hb::net::PacketNotifyPKpenalty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.exp = static_cast<uint32_t>(m_pClientList[iToH]->m_iExp);
		pkt.str = static_cast<uint32_t>(m_pClientList[iToH]->m_iStr);
		pkt.vit = static_cast<uint32_t>(m_pClientList[iToH]->m_iVit);
		pkt.dex = static_cast<uint32_t>(m_pClientList[iToH]->m_iDex);
		pkt.intel = static_cast<uint32_t>(m_pClientList[iToH]->m_iInt);
		pkt.mag = static_cast<uint32_t>(m_pClientList[iToH]->m_iMag);
		pkt.chr = static_cast<uint32_t>(m_pClientList[iToH]->m_iCharisma);
		pkt.pk_count = static_cast<uint32_t>(m_pClientList[iToH]->m_iPKCount);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_REPAIRALLPRICES:
	{
		hb::net::PacketNotifyRepairAllPricesHeader header{};
		header.header.msg_id = MSGID_NOTIFY;
		header.header.msg_type = wMsgType;
		int total = m_pClientList[iToH]->totalItemRepair;
		if (total < 0) total = 0;
		header.total = static_cast<int16_t>(total);

		hb::net::PacketWriter writer;
		writer.Reserve(sizeof(hb::net::PacketNotifyRepairAllPricesHeader) +
			(total * sizeof(hb::net::PacketNotifyRepairAllPricesEntry)));
		writer.AppendBytes(&header, sizeof(header));

		for(int i = 0; i < total; i++) {
			hb::net::PacketNotifyRepairAllPricesEntry entry{};
			entry.index = static_cast<uint8_t>(m_pClientList[iToH]->m_stRepairAll[i].index);
			entry.price = static_cast<int16_t>(m_pClientList[iToH]->m_stRepairAll[i].price);
			writer.AppendBytes(&entry, sizeof(entry));
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	}
	break;

	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
	case DEF_NOTIFY_LIMITEDLEVEL:
	{
		hb::net::PacketNotifySimpleInt pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.value = static_cast<int32_t>(m_pClientList[iToH]->m_iExp);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_ITEMRELEASED:
	{
		hb::net::PacketNotifyItemReleased pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.equip_pos = static_cast<int16_t>(sV1);
		pkt.item_index = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}
	case DEF_NOTIFY_ITEMLIFESPANEND:
	{
		hb::net::PacketNotifyItemLifeSpanEnd pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.equip_pos = static_cast<int16_t>(sV1);
		pkt.item_index = static_cast<int16_t>(sV2);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_KILLED:
	{
		hb::net::PacketNotifyKilled pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != 0) {
			memcpy(pkt.attacker_name, pString, sizeof(pkt.attacker_name));
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_EXP:
	{
		hb::net::PacketNotifyExp pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.exp = static_cast<uint32_t>(m_pClientList[iToH]->m_iExp);
		pkt.rating = static_cast<int32_t>(m_pClientList[iToH]->m_iRating);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_HP:
	{
		hb::net::PacketNotifyHP pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.hp = static_cast<uint32_t>(m_pClientList[iToH]->m_iHP);
		pkt.hunger = static_cast<uint32_t>(m_pClientList[iToH]->m_iHungerStatus);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_MP:
	{
		hb::net::PacketNotifyMP pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.mp = static_cast<uint32_t>(m_pClientList[iToH]->m_iMP);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_SP:
	{
		hb::net::PacketNotifySP pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.sp = static_cast<uint32_t>(m_pClientList[iToH]->m_iSP);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_CHARISMA:
	{
		hb::net::PacketNotifyCharisma pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.charisma = static_cast<uint32_t>(m_pClientList[iToH]->m_iCharisma);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	// State change failures
	case DEF_NOTIFY_STATECHANGE_FAILED:
	case DEF_NOTIFY_SETTING_FAILED:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_STATECHANGE_SUCCESS:	// 2003-04-14     .. wtf korean junk
	{
		
		hb::net::PacketNotifyStateChangeSuccess pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;

		for(int i = 0; i < DEF_MAXMAGICTYPE; i++) {
			pkt.magic_mastery[i] = static_cast<uint8_t>(m_pClientList[iToH]->m_cMagicMastery[i]);
		}

		for(int i = 0; i < DEF_MAXSKILLTYPE; i++) {
			pkt.skill_mastery[i] = static_cast<uint8_t>(m_pClientList[iToH]->m_cSkillMastery[i]);
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_SETTING_SUCCESS:
	case DEF_NOTIFY_LEVELUP:
	{
		hb::net::PacketNotifyLevelUp pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.level = m_pClientList[iToH]->m_iLevel;
		pkt.str = m_pClientList[iToH]->m_iStr;
		pkt.vit = m_pClientList[iToH]->m_iVit;
		pkt.dex = m_pClientList[iToH]->m_iDex;
		pkt.intel = m_pClientList[iToH]->m_iInt;
		pkt.mag = m_pClientList[iToH]->m_iMag;
		pkt.chr = m_pClientList[iToH]->m_iCharisma;
		pkt.attack_delay = m_pClientList[iToH]->m_status.iAttackDelay;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	{
		hb::net::PacketNotifyQueryDismissGuildPermission pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		memcpy(pkt.name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.name));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	{
		hb::net::PacketNotifyQueryJoinGuildPermission pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		memcpy(pkt.name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.name));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
	{
		hb::net::PacketNotifyCannotJoinMoreGuildsMan pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		memcpy(pkt.name, m_pClientList[iFromH]->m_cCharName, sizeof(pkt.name));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		break;
	}

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
	{
		hb::net::PacketNotifyJoinGuildApprove pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (m_pClientList[iFromH] != 0) {
			memcpy(pkt.guild_name, m_pClientList[iFromH]->m_cGuildName, sizeof(pkt.guild_name));
		}
		else {
			memcpy(pkt.guild_name, "?", 1);
		}
		pkt.rank = m_iStartingGuildRank;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:
	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		if (wMsgType == DEF_COMMONTYPE_JOINGUILDREJECT) {
			hb::net::PacketNotifyJoinGuildReject pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			if (m_pClientList[iFromH] != 0) {
				memcpy(pkt.guild_name, m_pClientList[iFromH]->m_cGuildName, sizeof(pkt.guild_name));
			}
			else {
				memcpy(pkt.guild_name, "?", 1);
			}
			pkt.rank = m_iStartingGuildRank;
			memcpy(pkt.location, m_pClientList[iToH]->m_cLocation, sizeof(pkt.location));
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else if (wMsgType == DEF_COMMONTYPE_DISMISSGUILDAPPROVE) {
			hb::net::PacketNotifyDismissGuildApprove pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			if (m_pClientList[iFromH] != 0) {
				memcpy(pkt.guild_name, m_pClientList[iFromH]->m_cGuildName, sizeof(pkt.guild_name));
			}
			else {
				memcpy(pkt.guild_name, "?", 1);
			}
			pkt.rank = m_iStartingGuildRank;
			memcpy(pkt.location, m_pClientList[iToH]->m_cLocation, sizeof(pkt.location));
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		else {
			hb::net::PacketNotifyDismissGuildReject pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = wMsgType;
			if (m_pClientList[iFromH] != 0) {
				memcpy(pkt.guild_name, m_pClientList[iFromH]->m_cGuildName, sizeof(pkt.guild_name));
			}
			else {
				memcpy(pkt.guild_name, "?", 1);
			}
			pkt.rank = m_iStartingGuildRank;
			memcpy(pkt.location, m_pClientList[iToH]->m_cLocation, sizeof(pkt.location));
			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		break;

	case DEF_NOTIFY_GUILDDISBANDED:
	{
		hb::net::PacketNotifyGuildDisbanded pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		if (pString != 0) {
			memcpy(pkt.guild_name, pString, sizeof(pkt.guild_name));
		}
		memcpy(pkt.location, m_pClientList[iToH]->m_cLocation, sizeof(pkt.location));
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_FIGHTZONERESERVE:
	{
		hb::net::PacketNotifyFightZoneReserve pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.result = static_cast<int32_t>(sV1);
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CANNOTBANGUILDMAN:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// . Time Out  .
		//DeleteClient(iToH, true, true);
		return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, const char* pName)
{
	
	bool bIsExist = false;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// pName   iClientH    .

	// pName     .
	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (_strnicmp(m_pClientList[i]->m_cCharName, pName, DEF_CHARNAME - 1) == 0)) {
			if (memcmp(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) != 0) return;

			std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);

			// GUID.
			m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

			std::memset(m_pClientList[i]->m_cLocation, 0, sizeof(m_pClientList[i]->m_cLocation));
			strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

			m_pClientList[i]->m_iGuildRank = m_iStartingGuildRank; // @@@  GuildRank  DEF_GUILDSTARTRANK

			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDAPPROVE, 0, 0, 0, 0);

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

			SendGuildMsg(i, DEF_NOTIFY_NEWGUILDSMAN, 0, 0, 0);

			//bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
			return;
		}

}

void CGame::JoinGuildRejectHandler(int iClientH, const char* pName)
{
	

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// pName   iClientH      .

	// pName     .
	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (_strnicmp(m_pClientList[i]->m_cCharName, pName, DEF_CHARNAME - 1) == 0)) {

			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDREJECT, 0, 0, 0, 0);
			return;
		}

}

void CGame::DismissGuildApproveHandler(int iClientH, const char* pName)
{
	


	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (_strnicmp(m_pClientList[i]->m_cCharName, pName, DEF_CHARNAME - 1) == 0)) {

			//bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
			//_bItemLog(DEF_ITEMLOG_BANGUILD,i,(char *)0,0) ;
			SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, 0, 0, 0);

			std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;

			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, 0, 0, 0, 0);

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			return;
		}

}

void CGame::DismissGuildRejectHandler(int iClientH, const char* pName)
{
	

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// pName   iClientH      .

	// pName     .
	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (_strnicmp(m_pClientList[i]->m_cCharName, pName, DEF_CHARNAME - 1) == 0)) {

			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDREJECT, 0, 0, 0, 0);
			return;
		}

}


int CGame::SetItemCount(int iClientH, int iItemIndex, uint32_t dwCount)
{
	uint16_t wWeight;

	if (m_pClientList[iClientH] == 0) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return -1;

	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;

	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, false);
	}
	else {
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)true, 0);
	}

	return wWeight;
}

uint32_t CGame::dwGetItemCountByID(int iClientH, short sItemID)
{
	if (m_pClientList[iClientH] == nullptr) return 0;

	for(int i = 0; i < hb::limits::MaxItems; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] != nullptr &&
		    m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == sItemID) {
			return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		}
	}

	return 0;
}

int CGame::SetItemCountByID(int iClientH, short sItemID, uint32_t dwCount)
{
	if (m_pClientList[iClientH] == nullptr) return -1;

	for(int i = 0; i < hb::limits::MaxItems; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] != nullptr &&
		    m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == sItemID) {

			uint16_t wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);

			if (dwCount == 0) {
				ItemDepleteHandler(iClientH, i, false);
			}
			else {
				m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char)true, 0);
			}

			return wWeight;
		}
	}

	return -1;
}

void CGame::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage)
{
	char cAttackerName[DEF_NPCNAME];
	short sAttackerWeapon;
	int iExH;
	bool  bIsSAattacked = false;


	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	// 2002-7-4
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fight", 5) == 0) {
		m_pClientList[iClientH]->m_dwFightzoneDeadTime = GameClock::GetTimeMS();
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Fightzone Dead Time: %d", m_pClientList[iClientH]->m_dwFightzoneDeadTime);
		PutLogList(G_cTxt);
	}

	m_pClientList[iClientH]->m_bIsKilled = true;
	// HP 0.
	m_pClientList[iClientH]->m_iHP = 0;

	// Snoopy: Remove all magic effects and flags
	for(int i = 0; i < DEF_MAXMAGICEFFECTS; i++)
		m_pClientList[iClientH]->m_cMagicEffectStatus[i] = 0;

	SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetInhibitionCastingFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
	SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);
	SetHasteFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);

	if (m_pClientList[iClientH]->m_bIsExchangeMode) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// NPC    .
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

	// Delete all summoned NPCs belonging to this player
	for (int i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) {
			if ((m_pNpcList[i]->m_bIsSummoned) &&
				(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
				(m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER)) {
				m_pEntityManager->DeleteEntity(i);
			}
		}

	std::memset(cAttackerName, 0, sizeof(cAttackerName));
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER_INDIRECT:
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iAttackerH] != 0)
			memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, DEF_CHARNAME - 1);
		break;
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iAttackerH] != 0)
#ifdef DEF_LOCALNPCNAME
			std::snprintf(cAttackerName, sizeof(cAttackerName), "NPCNPCNPC@%d", m_pNpcList[iAttackerH]->m_sType);
#else 
			memcpy(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, DEF_NPCNAME - 1);
#endif
		break;
	default:
		break;
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_KILLED, 0, 0, 0, cAttackerName);
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = m_pClientList[iAttackerH]->m_appearance.iWeaponType;
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, 0);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap) {
		if (m_pClientList[iClientH]->m_cSide == 1) {
			m_iHeldenianAresdenDead++;
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			m_iHeldenianElvineDead++;
		}
		UpdateHeldenianStatus();
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// v1.432
		switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			bIsSAattacked = true;
			break;
		}

		if (iAttackerH == iClientH) return;
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
			if (m_pClientList[iClientH]->m_iPKCount == 0) {


				ApplyPKpenalty(iAttackerH, iClientH);
			}
			else {

				PK_KillRewardHandler(iAttackerH, iClientH);
			}
		}
		else {
			if (m_pClientList[iClientH]->m_iGuildRank == -1) {
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {

					}
				}
				else {
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
			else {
				// , ,   -> PK /   ->
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {

					}
				}
				else {
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
		}

		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
				//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
				//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
				//SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
			}
			else {
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) == 0) {
					//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
					//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
					//SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
				}
				else {
					ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
				}
			}
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		char cTxt[128];
		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "%s killed %s", m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iClientH]->m_cCharName);
		for(int killedi = 0; killedi < DEF_MAXCLIENTS; killedi++) {
			if (m_pClientList[killedi] != 0 && killedi != iAttackerH) {
				SendNotifyMsg(0, killedi, DEF_NOTIFY_NOTICEMSG, 0, 0, 0, cTxt);
			}
		}
		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "%s(%s) killed %s(%s) in %s(%d,%d)", m_pClientList[iAttackerH]->m_cCharName, m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		PutPvPLogFileList(cTxt); // Centu : log pvp
	}
	else if (cAttackerType == DEF_OWNERTYPE_NPC) {

		_bPKLog(DEF_PKLOG_BYNPC, iClientH, 0, cAttackerName);

		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		if (m_pNpcList[iAttackerH]->m_iGuildGUID != 0) {

			if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				for(int i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) &&
						(m_pClientList[i]->m_iCrusadeDuty == 3)) {
						m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);

						if (m_pClientList[i]->m_iConstructionPoint > m_iMaxConstructionPoints)
							m_pClientList[i]->m_iConstructionPoint = m_iMaxConstructionPoints;

						//testcode
						std::snprintf(G_cTxt, sizeof(G_cTxt), "Enemy Player Killed by Npc! Construction +%d", (m_pClientList[iClientH]->m_iLevel / 2));
						PutLogList(G_cTxt);
						SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, 0);
						return;
					}
			}
		}
		char cTxt[128];
		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "%s killed %s", m_pNpcList[iAttackerH]->m_cNpcName, m_pClientList[iClientH]->m_cCharName);
		for(int Killedi = 0; Killedi < DEF_MAXCLIENTS; Killedi++) {
			if (m_pClientList[Killedi] != 0) {
				SendNotifyMsg(0, Killedi, DEF_NOTIFY_NOTICEMSG, 0, 0, 0, cTxt);
			}
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) {
		_bPKLog(DEF_PKLOG_BYOTHER, iClientH, 0, 0);
		// m_pClientList[iClientH]->m_iExp -= iDice(1, 50);
		// if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		// SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
	}
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, bool bNotice)
{
	char cHeroArmorType;
	EquipPos cEquipPos;

	if (m_pClientList[iClientH] == 0) return;
	if ((sItemIndex < 0) || (sItemIndex >= hb::limits::MaxItems)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() != ItemType::Equip) return;

	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == false) return;

	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = 0;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetEquipPos();
	if (cEquipPos == EquipPos::RightHand) {
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = false;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
			}
		}
	}

	// Appr .
	switch (cEquipPos) {
	case EquipPos::RightHand:
		m_pClientList[iClientH]->m_appearance.iWeaponType = 0;
		m_pClientList[iClientH]->m_appearance.iWeaponColor = 0;
		m_pClientList[iClientH]->m_status.iAttackDelay = 0;
		break;

	case EquipPos::LeftHand:
		m_pClientList[iClientH]->m_appearance.iShieldType = 0;
		m_pClientList[iClientH]->m_appearance.iShieldColor = 0;
		break;

	case EquipPos::TwoHand:
		m_pClientList[iClientH]->m_appearance.iWeaponType = 0;
		m_pClientList[iClientH]->m_appearance.iWeaponColor = 0;
		break;

	case EquipPos::Body:
		m_pClientList[iClientH]->m_appearance.iArmorType = 0;
		m_pClientList[iClientH]->m_appearance.bHideArmor = false;
		m_pClientList[iClientH]->m_appearance.iArmorColor = 0;
		break;

	case EquipPos::Back:
		m_pClientList[iClientH]->m_appearance.iMantleType = 0;
		m_pClientList[iClientH]->m_appearance.iMantleColor = 0;
		break;

	case EquipPos::Arms:
		m_pClientList[iClientH]->m_appearance.iArmArmorType = 0;
		m_pClientList[iClientH]->m_appearance.iArmColor = 0;
		break;

	case EquipPos::Pants:
		m_pClientList[iClientH]->m_appearance.iPantsType = 0;
		m_pClientList[iClientH]->m_appearance.iPantsColor = 0;
		break;

	case EquipPos::Leggings:
		m_pClientList[iClientH]->m_appearance.iBootsType = 0;
		m_pClientList[iClientH]->m_appearance.iBootsColor = 0;
		break;

	case EquipPos::Head:
		m_pClientList[iClientH]->m_appearance.iHelmType = 0;
		m_pClientList[iClientH]->m_appearance.iHelmColor = 0;
		break;

	case EquipPos::FullBody:
		m_pClientList[iClientH]->m_appearance.iArmorType = 0;
		m_pClientList[iClientH]->m_appearance.iMantleColor = 0;
		break;
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType() == ItemEffectType::AttackSpecAbility) {
		m_pClientList[iClientH]->m_appearance.iShieldGlare = 0;
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType() == ItemEffectType::DefenseSpecAbility) {
		m_pClientList[iClientH]->m_appearance.iWeaponGlare = 0;
	}

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(cEquipPos)] = -1;

	if (bNotice)
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

	CalcTotalItemEffect(iClientH, sItemIndex, true);
}


bool CGame::_bInitNpcAttr(class CNpc* pNpc, char* pNpcName, short sClass, char cSA)
{
	int iTemp;
	char cTmpName[DEF_NPCNAME];
	double dV1, dV2, dV3;

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pNpcName);

	for(int i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != 0) {
			if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, DEF_NPCNAME - 1) == 0) {
				// NPC  .  .
				std::memset(pNpc->m_cNpcName, 0, sizeof(pNpc->m_cNpcName));
				memcpy(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, DEF_NPCNAME - 1);

				pNpc->m_sType = m_pNpcConfigList[i]->m_sType;

				// HitDice   .    .
				if (m_pNpcConfigList[i]->m_iHitDice <= 5)
					pNpc->m_iHP = (iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
				else pNpc->m_iHP = ((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));
				if (pNpc->m_iHP == 0) pNpc->m_iHP = 1;

				//50Cent - HP Bar
				pNpc->m_iMaxHP = pNpc->m_iHP;

				pNpc->m_iExpDiceMin = m_pNpcConfigList[i]->m_iExpDiceMin;
				pNpc->m_iExpDiceMax = m_pNpcConfigList[i]->m_iExpDiceMax;
				pNpc->m_iGoldDiceMin = m_pNpcConfigList[i]->m_iGoldDiceMin;
				pNpc->m_iGoldDiceMax = m_pNpcConfigList[i]->m_iGoldDiceMax;
				pNpc->m_iDropTableId = m_pNpcConfigList[i]->m_iDropTableId;
				pNpc->m_iExp = (iDice(1, (m_pNpcConfigList[i]->m_iExpDiceMax - m_pNpcConfigList[i]->m_iExpDiceMin)) + m_pNpcConfigList[i]->m_iExpDiceMin);

				pNpc->m_iHitDice = m_pNpcConfigList[i]->m_iHitDice;
				pNpc->m_iDefenseRatio = m_pNpcConfigList[i]->m_iDefenseRatio;
				pNpc->m_iHitRatio = m_pNpcConfigList[i]->m_iHitRatio;
				pNpc->m_iMinBravery = m_pNpcConfigList[i]->m_iMinBravery;
				pNpc->m_cAttackDiceThrow = m_pNpcConfigList[i]->m_cAttackDiceThrow;
				pNpc->m_cAttackDiceRange = m_pNpcConfigList[i]->m_cAttackDiceRange;
				pNpc->m_cSize = m_pNpcConfigList[i]->m_cSize;
				pNpc->m_cSide = m_pNpcConfigList[i]->m_cSide;
				pNpc->m_cActionLimit = m_pNpcConfigList[i]->m_cActionLimit;
				pNpc->m_dwActionTime = m_pNpcConfigList[i]->m_dwActionTime;
				pNpc->m_dwRegenTime = m_pNpcConfigList[i]->m_dwRegenTime;
				pNpc->m_cResistMagic = m_pNpcConfigList[i]->m_cResistMagic;
				pNpc->m_cMagicLevel = m_pNpcConfigList[i]->m_cMagicLevel;
				pNpc->m_iMaxMana = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
				pNpc->m_iMana = m_pNpcConfigList[i]->m_iMaxMana;
				pNpc->m_cChatMsgPresence = m_pNpcConfigList[i]->m_cChatMsgPresence;
				pNpc->m_cDayOfWeekLimit = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
				pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;

				switch (sClass) {
				case 43:
				case 44:
				case 45:
				case 46:
				case 47:
					pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
					break;

				default:
					pNpc->m_iAttackStrategy = iDice(1, 10);
					break;
				}

				pNpc->m_iAILevel = iDice(1, 3);
				pNpc->m_iAbsDamage = m_pNpcConfigList[i]->m_iAbsDamage;
				pNpc->m_iMagicHitRatio = m_pNpcConfigList[i]->m_iMagicHitRatio;
				pNpc->m_iAttackRange = m_pNpcConfigList[i]->m_iAttackRange;
				pNpc->m_cSpecialAbility = cSA;
				pNpc->m_iBuildCount = m_pNpcConfigList[i]->m_iMinBravery;

				switch (pNpc->m_cSpecialAbility) {
				case 1:
					dV2 = (double)pNpc->m_iExp;
					dV3 = 25.0f / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 2:
					dV2 = (double)pNpc->m_iExp;
					dV3 = 30.0f / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 3: // Absorbing Physical Damage
					if (pNpc->m_iAbsDamage > 0) {
						pNpc->m_cSpecialAbility = 0;
						cSA = 0;
					}
					else {
						iTemp = 20 + iDice(1, 60);
						pNpc->m_iAbsDamage -= iTemp;
						if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
					}

					dV2 = (double)pNpc->m_iExp;
					dV3 = (double)abs(pNpc->m_iAbsDamage) / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 4: // Absorbing Magical Damage
					if (pNpc->m_iAbsDamage < 0) {
						pNpc->m_cSpecialAbility = 0;
						cSA = 0;
					}
					else {
						iTemp = 20 + iDice(1, 60);
						pNpc->m_iAbsDamage += iTemp;
						if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
					}

					dV2 = (double)pNpc->m_iExp;
					dV3 = (double)(pNpc->m_iAbsDamage) / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 5:
					dV2 = (double)pNpc->m_iExp;
					dV3 = 15.0f / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 6:
				case 7:
					dV2 = (double)pNpc->m_iExp;
					dV3 = 20.0f / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;

				case 8:
					dV2 = (double)pNpc->m_iExp;
					dV3 = 25.0f / 100.0f;
					dV1 = dV2 * dV3;
					pNpc->m_iExp += (uint32_t)dV1;
					break;
				}

				pNpc->m_iNoDieRemainExp = (pNpc->m_iExp) - (pNpc->m_iExp / 3);

				pNpc->m_status.iAngelPercent = static_cast<uint8_t>(cSA);

				pNpc->m_status.iAttackDelay = static_cast<uint8_t>(sClass);

				return true;
			}
		}

	// NPC    .
	return false;
}

/*********************************************************************************************************************
**  int CGame::iDice(int iThrow, int iRange)																		**
**  description			:: produces a random number between the throw and range										**
**  last updated		:: November 20, 2004; 10:24 PM; Hypnotoad													**
**	return value		:: int																						**
**********************************************************************************************************************/
uint32_t CGame::iDice(uint32_t iThrow, uint32_t iRange)
{
	uint32_t iRet;

	if (iRange <= 0) return 0;
	iRet = 0;
	for (uint32_t i = 1; i <= iThrow; i++) {
		iRet += (rand() % iRange) + 1;
	}
	return iRet;
}


void CGame::TimeManaPointsUp(int iClientH)
{
	int iMaxMP, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) return;

	iMaxMP = iGetMaxMP(iClientH); // v1.4
	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag));
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f) * dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;

		if (m_pClientList[iClientH]->m_iMP > iMaxMP)
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);
	}
}

// 05/29/2004 - Hypnotoad - fixed infinite sp bug
void CGame::TimeStaminarPointsUp(int iClientH)
{
	int iMaxSP, iTotal = 0;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) return;

	iMaxSP = iGetMaxSP(iClientH);
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {

		iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit / 3)); // Staminar Point 10 1D(Vit/3) .
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f) * dV2;
			iTotal += (int)dV1;
		}

		if (m_pClientList[iClientH]->m_iLevel <= 20) {
			iTotal += 15;
		}
		else if (m_pClientList[iClientH]->m_iLevel <= 40) {
			iTotal += 10;
		}
		else if (m_pClientList[iClientH]->m_iLevel <= 60) {
			iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP)
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
	}
}

void CGame::DelayEventProcess()
{

}

void CGame::SendGuildMsg(int iClientH, uint16_t wNotifyMsgType, short sV1, short sV2, char* pString)
{
	int iRet;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	for(int i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) &&
			(memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0)) {

			switch (wNotifyMsgType) {
			case DEF_NOTIFY_GUILDDISBANDED:
				if (i == iClientH) break;
				{
					hb::net::PacketNotifyGuildDisbanded pkt{};
					pkt.header.msg_id = MSGID_NOTIFY;
					pkt.header.msg_type = wNotifyMsgType;
					memcpy(pkt.guild_name, m_pClientList[iClientH]->m_cGuildName, sizeof(pkt.guild_name));
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
				}
				std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
				strcpy(m_pClientList[i]->m_cGuildName, "NONE");
				m_pClientList[i]->m_iGuildRank = -1;
				m_pClientList[i]->m_iGuildGUID = -1;
				break;

			case DEF_NOTIFY_EVENTMSGSTRING:
			{
				hb::net::PacketWriter writer;
				writer.Reserve(sizeof(hb::net::PacketHeader) + 256);

				auto* header = writer.Append<hb::net::PacketHeader>();
				header->msg_id = MSGID_NOTIFY;
				header->msg_type = wNotifyMsgType;

				if (pString != 0) {
					const std::size_t len = std::strlen(pString);
					writer.AppendBytes(pString, len);
				}
				writer.AppendBytes("", 1);

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
			}
			break;

			case DEF_NOTIFY_NEWGUILDSMAN:
			{
				hb::net::PacketNotifyNewGuildsMan pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = wNotifyMsgType;
				memcpy(pkt.name, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			break;

			case DEF_NOTIFY_DISMISSGUILDSMAN:
			{
				hb::net::PacketNotifyDismissGuildsMan pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = wNotifyMsgType;
				memcpy(pkt.name, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			break;
			}

			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(i, true, true);
				return;
			}
		}

}


void CGame::GuildNotifyHandler(char* pData, size_t dwMsgSize)
{
	char* cp, cCharName[DEF_CHARNAME], cGuildName[21];

	std::memset(cCharName, 0, sizeof(cCharName));
	std::memset(cGuildName, 0, sizeof(cGuildName));

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader));

	memcpy(cCharName, cp, DEF_CHARNAME - 1);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

}

void CGame::ToggleCombatModeHandler(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) return;

	m_pClientList[iClientH]->m_bIsAttackModeChange = true; // v2.172

	if (!m_pClientList[iClientH]->m_appearance.bIsWalking) {
		m_pClientList[iClientH]->m_appearance.bIsWalking = true;
	}
	else {
		m_pClientList[iClientH]->m_appearance.bIsWalking = false;
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

}


//  int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is casting magic
//  last updated		:: October 29, 2004; 6:51 PM; Hypnotoad
//	return value		:: int
int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
	int     iRet;

	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	if (m_pClientList[iClientH]->m_status.bInvisibility) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, hb::magic::Invisibility);
		m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Invisibility] = 0;
	}

	m_pClientList[iClientH]->m_cDir = cDir;

	{
		hb::net::PacketResponseMotionHeader pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_MOTION;
		pkt.header.msg_type = DEF_OBJECTMOTION_CONFIRM;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

/*********************************************************************************************************************
**  void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, bool bItemEffect, int iV1)			**
**  description			:: handles all magic related items/spells													**
**  last updated		:: November 22, 2004; 5:45 PM; Hypnotoad													**
**	return value		:: void																						**
**  commentary			::	-	added 3.51 casting detection														**
**							-	updated it so civilians can only cast certain spells on players and vice versa		**
**							-	fixed bug causing spell to be cast when mana is below required amount				**
**********************************************************************************************************************/
int  _tmp_iMCProb[] = { 0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40 };
int  _tmp_iMLevelPenalty[] = { 0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40 };
void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, bool bItemEffect, int iV1, uint16_t targetObjectID)
{
	short sX, sY, sOwnerH, sMagicCircle, rx, ry, sLevelMagic;
	char cDir, cOwnerType, cName[DEF_CHARNAME], cItemName[DEF_ITEMNAME], cNpcWaypoint[11], cName_Master[DEF_CHARNAME], cNpcName[DEF_NPCNAME], cRemainItemColor, cScanMessage[256];
	double dV1, dV2, dV3, dV4;
	int iErr, iRet, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
	int tX, tY, iManaCost, iMagicAttr;
	CItem* pItem;
	uint32_t dwTime;
	uint16_t wWeaponType;
	short sEqStatus;
	int iMapSide = 0;
	short sIDNum;
	uint32_t dwAttr;

	dwTime = GameClock::GetTimeMS();
	m_pClientList[iClientH]->m_bMagicConfirm = true;
	m_pClientList[iClientH]->m_bMagicPauseTime = false;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// Auto-aim: If client clicked on an entity, use the target's current position
	// This compensates for latency - players with high ping can still hit moving targets
	// Security: Only allow if target is within reasonable distance of original click (prevents cross-map exploits)
	constexpr int MAX_AUTOAIM_DISTANCE = 10;  // Max tiles target can move and still be tracked
	if (targetObjectID != 0)
	{
		int targetMapIndex = m_pClientList[iClientH]->m_cMapIndex;
		int targetX = -1, targetY = -1;

		if (targetObjectID < 10000)
		{
			// Target is a player
			if ((targetObjectID > 0) && (targetObjectID < DEF_MAXCLIENTS) && m_pClientList[targetObjectID] != nullptr)
			{
				// Verify target is on the same map
				if (m_pClientList[targetObjectID]->m_cMapIndex == targetMapIndex)
				{
					targetX = m_pClientList[targetObjectID]->m_sX;
					targetY = m_pClientList[targetObjectID]->m_sY;
				}
			}
		}
		else
		{
			// Target is an NPC (objectID - 10000)
			int npcIndex = targetObjectID - 10000;
			if ((npcIndex > 0) && (npcIndex < DEF_MAXNPCS) && m_pNpcList[npcIndex] != nullptr)
			{
				// Verify target is on the same map
				if (m_pNpcList[npcIndex]->m_cMapIndex == targetMapIndex)
				{
					targetX = m_pNpcList[npcIndex]->m_sX;
					targetY = m_pNpcList[npcIndex]->m_sY;
				}
			}
		}

		// Only use auto-aim if target was near the original click position
		// This prevents exploits where hackers send fake objectIDs for targets across the map
		if (targetX >= 0 && targetY >= 0)
		{
			int distX = abs(targetX - dX);
			int distY = abs(targetY - dY);
			if (distX <= MAX_AUTOAIM_DISTANCE && distY <= MAX_AUTOAIM_DISTANCE)
			{
				dX = targetX;
				dY = targetY;
			}
			// If target moved too far, fall back to original tile coordinates (no tracking)
		}
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;

	if (((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 1000) && (bItemEffect == 0)) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "3.51 Detection: (%s) Player: (%s) - Magic casting speed is too fast! Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{
		}
		return;
	}
	m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

	if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == 0) return;

	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == 0) return;

	if ((bItemEffect == false) && (m_pClientList[iClientH]->m_cMagicMastery[sType] != 1)) return;

	// Only block offensive magic in no-attack zones; allow friendly spells (healing, buffs, teleport, create, etc.)
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled == false)
		&& sType != 14)
	{

		switch (m_pMagicConfigList[sType]->m_sType)
		{
		case hb::magic::DamageSpot:
		case hb::magic::DamageArea:
		case hb::magic::SpDownSpot:
		case hb::magic::SpDownArea:
		case hb::magic::HoldObject:
		case hb::magic::Possession:
		case hb::magic::Confuse:
		case hb::magic::Poison:
		case hb::magic::DamageLinear:
		case hb::magic::DamageAreaNoSpot:
		case hb::magic::Tremor:
		case hb::magic::Ice:
		case hb::magic::DamageAreaNoSpotSpDown:
		case hb::magic::IceLinear:
		case hb::magic::DamageAreaArmorBreak:
		case hb::magic::DamageLinearSpDown:
		case hb::magic::Inhibition:
			return;
		}
	}
	//if ((var_874 ) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap ) && (m_pMagicConfigList[sType]->m_sType != 8)) return;

	if ((m_pClientList[iClientH]->m_status.bInhibitionCasting) && (bItemEffect != true)) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, DEF_MAGIC_FAILED, -1, 0);
		return;
	}

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)] != -1) {
		wWeaponType = m_pClientList[iClientH]->m_appearance.iWeaponType;
		if ((wWeaponType >= 34) && (wWeaponType <= 39)) {
		}
		else return;
	}

	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::LeftHand)] != -1) ||
		(m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] != -1)) return;

	// Reject spell if the cast was interrupted by damage (sentinel value -1)
	if ((bItemEffect == false) && (m_pClientList[iClientH]->m_iSpellCount == -1)) {
		m_pClientList[iClientH]->m_iSpellCount = 0;
		return;
	}

	if ((m_pClientList[iClientH]->m_iSpellCount > 1) && (bItemEffect == false)) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "TSearch Spell Hack: (%s) Player: (%s) - casting magic without precasting.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{
		}
		return;
	}

	if (m_pClientList[iClientH]->m_bInhibition) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, DEF_MAGIC_FAILED, -1, 0);
		return;
	}

	/*if (((m_pClientList[iClientH]->m_iUninteruptibleCheck - (iGetMaxHP(iClientH)/10)) > (m_pClientList[iClientH]->m_iHP)) && (m_pClientList[iClientH]->m_bMagicItem == false)) {
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, 0,
			0, 0, 0, 0, 0, 0);
		return;
	}*/

	if (m_pMagicConfigList[sType]->m_sType == 32) { // Invisiblity
		sEqStatus = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
		if ((sEqStatus != -1) && (m_pClientList[iClientH]->m_pItemList[sEqStatus] != 0)) {
			if ((m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 866)) {
				bItemEffect = true;
			}
		}
	}

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	sMagicCircle = (sType / 10) + 1;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0)
		dV1 = 1.0f;
	else dV1 = (double)m_pClientList[iClientH]->m_cSkillMastery[4];

	if (bItemEffect) dV1 = (double)100.0f;
	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];
	dV1 = dV2 * dV3;
	iResult = (int)dV1;

	if ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) > 50)
		iResult += ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) - 50) / 2;

	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic * 10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic) * 10;
			dV4 = (dV1 / dV3) * dV2;
			iResult -= abs(abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5 * abs(sMagicCircle - sLevelMagic);
		}
	}

	switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break;
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}

	if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10) {
		dV1 = (double)iResult;
		dV2 = (double)(m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int)dV3;
	}

	if (iResult <= 0) iResult = 1;

	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);

	iManaCost = m_pMagicConfigList[sType]->m_sValue1;
	if ((m_pClientList[iClientH]->m_bIsSafeAttackMode) &&
		(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)) {
		iManaCost += (iManaCost / 2) - (iManaCost / 10);
	}

	if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) {
		dV1 = (double)m_pClientList[iClientH]->m_iManaSaveRatio;
		dV2 = (double)(dV1 / 100.0f);
		dV3 = (double)iManaCost;
		dV1 = dV2 * dV3;
		dV2 = dV3 - dV1;
		iManaCost = (int)dV2;

		if (iManaCost <= 0) iManaCost = 1;
	}

	wWeaponType = m_pClientList[iClientH]->m_appearance.iWeaponType;
	if (wWeaponType == 34) {
		iManaCost += 20;
	}

	if (iResult < 100) {
		iDiceRes = iDice(1, 100);
		if (iResult < iDiceRes) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, DEF_MAGIC_FAILED, -1, 0);
			return;
		}
	}

	if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1, 1000) <= 100)) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, DEF_MAGIC_FAILED, -1, 0);
		return;
	}

	if (m_pClientList[iClientH]->m_iMP < iManaCost) {
		return;
	}

	iResult = m_pClientList[iClientH]->m_cSkillMastery[4];
	if ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) > 50) iResult += ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) - 50);

	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic * 10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic) * 10;
			dV4 = (dV1 / dV3) * dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic) * _tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5 * abs(sMagicCircle - sLevelMagic);
		}
	}

	iResult += m_pClientList[iClientH]->m_iAddAR;
	if (iResult <= 0) iResult = 1;

	if (sType >= 80) iResult += 10000;

	if (m_pMagicConfigList[sType]->m_sType == 28) {
		iResult += 10000;
	}

	if (m_pMagicConfigList[sType]->m_cCategory == 1) {
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
	}

	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;
	if (m_pClientList[iClientH]->m_status.bInvisibility) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, hb::magic::Invisibility);
		m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Invisibility] = 0;
	}

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	if ((m_bIsCrusadeMode == false) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
		if ((m_pClientList[iClientH]->m_bIsPlayerCivil != true) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil)) {
			if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) return;
		}
		else if ((m_pClientList[iClientH]->m_bIsPlayerCivil) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil == false)) {
			switch (m_pMagicConfigList[sType]->m_sType) {
			case 1:  // hb::magic::DamageSpot
			case 4:  // hb::magic::SpDownSpot 4
			case 8:  // hb::magic::Teleport 8
			case 10: // hb::magic::Create 10
			case 11: // hb::magic::Protect 11
			case 12: // hb::magic::HoldObject 12
			case 16: // hb::magic::Confuse
			case 17: // hb::magic::Poison
			case 32: // hb::magic::Resurrection
			case hb::magic::Haste:
				return;
			}
		}
	}

	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		switch (m_pMagicConfigList[sType]->m_sType) {
		case hb::magic::Haste:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (sOwnerH == iClientH) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Haste] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Haste] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetHasteFlag(sOwnerH, cOwnerType, true);
					break;

				case DEF_OWNERTYPE_NPC:
					goto MAGIC_NOEFFECT;
					break;
				}
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Haste, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Haste, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
				break;
			}
			break;
		case hb::magic::DamageSpot:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
			}
			break;

		case hb::magic::HpUpSpot:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;

		case hb::magic::DamageArea:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
			}

			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					}
				}
			break;

		case hb::magic::SpDownSpot:
			break;

		case hb::magic::SpDownArea:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
				}
			break;

		case hb::magic::Polymorph:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (1) { // bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Polymorph] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Polymorph] = (char)m_pMagicConfigList[sType]->m_sValue4;
					m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
					m_pClientList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Polymorph] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Polymorph] = (char)m_pMagicConfigList[sType]->m_sValue4;
					m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
					m_pNpcList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					break;
				}

				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Polymorph, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Polymorph, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
			}
			break;

			// 05/20/2004 - Hypnotoad - Cancellation
		case hb::magic::Cancellation:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) && (m_pClientList[sOwnerH]->m_iHP > 0)) {

				// Removes Invisibility Flag 0x0010
				SetInvisibilityFlag(sOwnerH, cOwnerType, false);

				// Removes Illusion Flag 0x01000000
				SetIllusionFlag(sOwnerH, cOwnerType, false);

				// Removes Defense Shield Flag 0x02000000
				// Removes Great Defense Shield Flag 0x02000000
				SetDefenseShieldFlag(sOwnerH, cOwnerType, false);

				// Removes Absolute Magic Protection Flag 0x04000000	
				// Removes Protection From Magic Flag 0x04000000
				SetMagicProtectionFlag(sOwnerH, cOwnerType, false);

				// Removes Protection From Arrow Flag 0x08000000
				SetProtectionFromArrowFlag(sOwnerH, cOwnerType, false);

				// Removes Illusion Movement Flag 0x00200000
				SetIllusionMovementFlag(sOwnerH, cOwnerType, false);

				// Removes Berserk Flag 0x0020
				SetBerserkFlag(sOwnerH, cOwnerType, false);

				//Removes ice-added 
				SetIceFlag(sOwnerH, cOwnerType, false);

				//Remove paralyse

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::Ice);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::HoldObject);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::HoldObject, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::Inhibition);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Inhibition, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::Invisibility);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Invisibility, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::Berserk);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Berserk, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::Protect);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Protect, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::Confuse);
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Confuse, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				// Update Client
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			}
			break;

		case hb::magic::DamageAreaNoSpotSpDown:
			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, false, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
					}
				}
			break;

		case hb::magic::DamageLinear:
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for(int i = 2; i < 10; i++) {
				iErr = 0;
				CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
				}

				if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					}
				}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
				(m_pClientList[sOwnerH]->m_iHP > 0)) {
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
			}
			break;

		case hb::magic::IceLinear:
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for(int i = 2; i < 10; i++) {
				iErr = 0;
				CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_iHP < 0) goto MAGIC_NOEFFECT;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
					}
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
					}
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
					}
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
					}
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
					}
				}

				if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
										m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
										SetIceFlag(sOwnerH, cOwnerType, true);
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
											sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
										SetIceFlag(sOwnerH, cOwnerType, true);
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
											sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									}
								}
								break;
							}
						}
					}
				}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
							SetIceFlag(sOwnerH, cOwnerType, true);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
								sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
						}
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
						if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
							SetIceFlag(sOwnerH, cOwnerType, true);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
								sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
						}
					}
					break;
				}
			}

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
				(m_pClientList[sOwnerH]->m_iHP > 0)) {
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
								SetIceFlag(sOwnerH, cOwnerType, true);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
							}
						}
						break;
					}
				}
			}
			break;


		case hb::magic::Inhibition:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Inhibition] != 0) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Protect] == 5) goto MAGIC_NOEFFECT;
				if (m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) goto MAGIC_NOEFFECT;
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

				m_pClientList[sOwnerH]->m_bInhibition = true;
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Inhibition, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
				break;
			}
			break;


		case hb::magic::Tremor:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
				(m_pClientList[sOwnerH]->m_iHP > 0)) {
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
			}

			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					}
				}
			break;

		case hb::magic::DamageAreaNoSpot:
			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					}
				}
			break;

		case hb::magic::SpUpArea:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
				}
			break;

		case hb::magic::DamageLinearSpDown:
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for(int i = 2; i < 10; i++) {
				iErr = 0;
				CMisc::GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
					}
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX - 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
					}
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX + 1, tY);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
					}
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY - 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
					}
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;
					}
				}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY + 1);
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
					(m_pClientList[sOwnerH]->m_iHP > 0)) {
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
					}
				}

				if ((abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
								ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}
							break;
						}
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
									Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
								}
								break;
							}
						}
					}
				}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
					}
					break;
				}
			}

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
				(m_pClientList[sOwnerH]->m_iHP > 0)) {
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr); // v1.41 false
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);

						}
						break;
					}
				}
			}
			break;

		case hb::magic::Teleport:
			// . sValue 4    .
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// . Recall.
				if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH)) {
					// Recall  .
					RequestTeleportHandler(iClientH, "1   ");
				}
				break;
			}
			break;

		case hb::magic::Summon:

			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) return;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// Owner Master .
			if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
				// Master       .
				iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

				// Casting  Magery/20     .
				if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4] / 20)) break;

				iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
				if (iNamingValue == -1) {
					// NPC  .     .
				}
				else {
					// NPC .
					std::memset(cName, 0, sizeof(cName));
					std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

					// Magery     .
					std::memset(cNpcName, 0, sizeof(cNpcName));

					switch (iV1) {
					case 0:
						iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);

						if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20)
							iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;

						switch (iResult) {
						case 1: strcpy(cNpcName, "Slime"); break;
						case 2: strcpy(cNpcName, "Giant-Ant"); break;
						case 3: strcpy(cNpcName, "Amphis"); break;
						case 4: strcpy(cNpcName, "Orc"); break;
						case 5: strcpy(cNpcName, "Skeleton"); break;
						case 6:	strcpy(cNpcName, "Clay-Golem"); break;
						case 7:	strcpy(cNpcName, "Stone-Golem"); break;
						case 8: strcpy(cNpcName, "Orc-Mage"); break;
						case 9:	strcpy(cNpcName, "Hellbound"); break;
						case 10:strcpy(cNpcName, "Cyclops"); break;
						}
						break;

					case 1:	strcpy(cNpcName, "Orc"); break;
					case 2: strcpy(cNpcName, "Skeleton"); break;
					case 3: strcpy(cNpcName, "Clay-Golem"); break;
					case 4: strcpy(cNpcName, "Stone-Golem"); break;
					case 5: strcpy(cNpcName, "Hellbound"); break;
					case 6: strcpy(cNpcName, "Cyclops"); break;
					case 7: strcpy(cNpcName, "Troll"); break;
					case 8: strcpy(cNpcName, "Orge"); break;
					}

					if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, 0, 0, m_pClientList[iClientH]->m_cSide, false, true) == false) {
						// NameValue .
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						std::memset(cName_Master, 0, sizeof(cName_Master));
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, DEF_CHARNAME - 1);
							break;
						case DEF_OWNERTYPE_NPC:
							memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
							break;
						}
						if (m_pEntityManager != 0) m_pEntityManager->bSetNpcFollowMode(cName, cName_Master, cOwnerType);
					}
				}
			}
			break;

		case hb::magic::Create:

			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == false)
				goto MAGIC_NOEFFECT;

			pItem = new CItem;

			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// Food
				if (iDice(1, 2) == 1)
					std::snprintf(cItemName, sizeof(cItemName), "Meat");
				else std::snprintf(cItemName, sizeof(cItemName), "Baguette");
				break;
			}

			_bInitItemAttr(pItem, cItemName);

			pItem->SetTouchEffectType(TouchEffectType::ID);
			pItem->m_sTouchEffectValue1 = static_cast<short>(iDice(1, 100000));
			pItem->m_sTouchEffectValue2 = static_cast<short>(iDice(1, 100000));
			pItem->m_sTouchEffectValue3 = (short)GameClock::GetTimeMS();

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

			_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int)-1, pItem);

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				dX, dY, pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color
			break;

		case hb::magic::Protect:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Protect] != 0) goto MAGIC_NOEFFECT;
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

				m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Protect] = (char)m_pMagicConfigList[sType]->m_sValue4;
				switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
					break;
				case 2:
				case 5:
					SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
					break;
				case 3:
				case 4:
					SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
					break;
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Protect] != 0) goto MAGIC_NOEFFECT;
				// NPC    .
				if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
				m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Protect] = (char)m_pMagicConfigList[sType]->m_sValue4;

				switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_NPC, true);
					break;
				case 2:
				case 5:
					SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_NPC, true);
					break;
				case 3:
				case 4:
					SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_NPC, true);
					break;
				}
				break;
			}

			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Protect, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
				sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

			if (cOwnerType == DEF_OWNERTYPE_PLAYER)
				SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Protect, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
			break;

		case hb::magic::Scan:
			std::memset(cScanMessage, 0, sizeof(cScanMessage));
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					std::snprintf(cScanMessage, sizeof(cScanMessage), " Player: %s HP:%d MP:%d.", m_pClientList[sOwnerH]->m_cCharName, m_pClientList[sOwnerH]->m_iHP, m_pClientList[sOwnerH]->m_iMP);
					ShowClientMsg(iClientH, cScanMessage);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					std::snprintf(cScanMessage, sizeof(cScanMessage), " NPC: %s HP:%d MP:%d", m_pNpcList[sOwnerH]->m_cNpcName, m_pNpcList[sOwnerH]->m_iHP, m_pNpcList[sOwnerH]->m_iMana);
					ShowClientMsg(iClientH, cScanMessage);
					break;
				}
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, 10, (short)10);
			}
			break;

		case hb::magic::HoldObject:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
					// 2002-09-10 #2 (No-Attack-Area)
					if (cOwnerType == DEF_OWNERTYPE_PLAYER) {

						if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
						if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
					}

					// 2002-09-10 #3
					if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland") != 0 &&
						m_bIsCrusadeMode == false &&
						m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide)
						goto MAGIC_NOEFFECT;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}

				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::HoldObject, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::HoldObject, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
			}
			break;

		case hb::magic::Invisibility:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if ((sOwnerH != iClientH) && ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) || (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)) && ((memcmp(m_pClientList[sOwnerH]->m_cLocation, "elvhunter", 9) != 0) || (memcmp(m_pClientList[sOwnerH]->m_cLocation, "arehunter", 9) != 0))) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Invisibility] != 0) goto MAGIC_NOEFFECT;
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Invisibility] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, true);
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::Invisibility);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Invisibility] != 0) goto MAGIC_NOEFFECT;

					if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
						// NPC     .
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Invisibility] = (char)m_pMagicConfigList[sType]->m_sValue4;
						SetInvisibilityFlag(sOwnerH, cOwnerType, true);
						// NPC    .
						RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, hb::magic::Invisibility);
					}
					break;
				}

				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Invisibility, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Invisibility, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
				break;

			case 2:
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
				if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) || (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)) goto MAGIC_NOEFFECT;

				// dX, dY  8  Invisibility  Object   .
				for(int ix = dX - 8; ix <= dX + 8; ix++)
					for(int iy = dY - 8; iy <= dY + 8; iy++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != 0) {
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Invisibility] != 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Invisibility] = 0;
									SetInvisibilityFlag(sOwnerH, cOwnerType, false);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, hb::magic::Invisibility);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Invisibility] != 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Invisibility] = 0;
									SetInvisibilityFlag(sOwnerH, cOwnerType, false);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, hb::magic::Invisibility);
								}
								break;
							}
						}
					}
				break;
			}
			break;

		case hb::magic::CreateDynamic:
			// Dynamic Object    .

			if (m_bIsCrusadeMode == false) {
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
				// v2.14
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) return;
				if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0) return;
			}

			switch (m_pMagicConfigList[sType]->m_sValue10) {
			case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:

			case DEF_DYNAMICOBJECT_FIRE:   // Fire .
			case DEF_DYNAMICOBJECT_SPIKE:  // Spike

#ifdef DEF_TAIWANLOG 
				short sTemp_X, sTemp_Y;
				sTemp_X = m_pClientList[iClientH]->m_sX;
				sTemp_Y = m_pClientList[iClientH]->m_sY;

				m_pClientList[iClientH]->m_sX = dX;
				m_pClientList[iClientH]->m_sY = dY;

				_bItemLog(DEF_ITEMLOG_SPELLFIELD, iClientH, m_pMagicConfigList[sType]->m_cName, 0);

				m_pClientList[iClientH]->m_sX = sTemp_X;
				m_pClientList[iClientH]->m_sY = sTemp_Y;
#endif

				switch (m_pMagicConfigList[sType]->m_sValue11) {
				case 1:
					// wall - type
					cDir = CMisc::cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
					switch (cDir) {
					case 1:	rx = 1; ry = 0;   break;
					case 2: rx = 1; ry = 1;   break;
					case 3: rx = 0; ry = 1;   break;
					case 4: rx = -1; ry = 1;  break;
					case 5: rx = 1; ry = 0;   break;
					case 6: rx = -1; ry = -1; break;
					case 7: rx = 0; ry = -1;  break;
					case 8: rx = 1; ry = -1;  break;
					}

					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime * 1000);

					bAnalyzeCriminalAction(iClientH, dX, dY);

					for(int i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
							dX + i * rx, dY + i * ry, m_pMagicConfigList[sType]->m_dwLastTime * 1000);
						bAnalyzeCriminalAction(iClientH, dX + i * rx, dY + i * ry);

						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
							dX - i * rx, dY - i * ry, m_pMagicConfigList[sType]->m_dwLastTime * 1000);
						bAnalyzeCriminalAction(iClientH, dX - i * rx, dY - i * ry);
					}
					break;

				case 2:
					// Field - Type
					bool bFlag = false;
					int cx, cy;
					for(int ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++)
						for(int iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) {
							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
								ix, iy, m_pMagicConfigList[sType]->m_dwLastTime * 1000, m_pMagicConfigList[sType]->m_sValue5);

							if (bAnalyzeCriminalAction(iClientH, ix, iy, true)) {
								bFlag = true;
								cx = ix;
								cy = iy;
							}
						}
					if (bFlag) bAnalyzeCriminalAction(iClientH, cx, cy);
					break;
				}
				break;

			case DEF_DYNAMICOBJECT_ICESTORM:
				// Ice-Storm Dynamic Object 
				iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex,
					dX, dY, m_pMagicConfigList[sType]->m_dwLastTime * 1000,
					m_pClientList[iClientH]->m_cSkillMastery[4]);
				break;

			default:
				break;
			}
			break;

		case hb::magic::Possession:
			if (m_pClientList[iClientH]->m_cSide == 0) goto MAGIC_NOEFFECT;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (sOwnerH != 0) break;

			pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sIDNum, &cRemainItemColor, &dwAttr);
			if (pItem != 0) {
				if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {

					_bItemLog(DEF_ITEMLOG_GET, iClientH, (int)-1, pItem);

					iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, true, true);
						return;
					}
				}
				else
				{

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

					iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, true, true);
						return;
					}
				}
			}
			break;

		case hb::magic::Confuse:
			// if the caster side is the same as the targets side, no effect occurs
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1: // confuse Language.
			case 2: // Confusion, Mass Confusion 	
				for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Confuse] != 0) break; // Confuse  .
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Confuse] = (char)m_pMagicConfigList[sType]->m_sValue4;

								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Confuse, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Confuse, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
							}
						}
					}
				break;

			case 3: // Ilusion, Mass-Ilusion
				for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Confuse] != 0) break; // Confuse  .
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Confuse] = (char)m_pMagicConfigList[sType]->m_sValue4;

								switch (m_pMagicConfigList[sType]->m_sValue4) {
								case 3:
									SetIllusionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
									break;
								}

								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Confuse, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Confuse, m_pMagicConfigList[sType]->m_sValue4, iClientH, 0);
							}
						}
					}
				break;

			case 4: // Ilusion Movement
				if (m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Invisibility] != 0) break;
				for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) && (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Confuse] != 0) break;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Confuse] = (char)m_pMagicConfigList[sType]->m_sValue4;
								switch (m_pMagicConfigList[sType]->m_sValue4) {
								case 4:
									SetIllusionMovementFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, true);
									break;
								}

								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Confuse, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
									sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

								SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Confuse, m_pMagicConfigList[sType]->m_sValue4, iClientH, 0);
							}
						}
					}
			}
			break;


		case hb::magic::Poison:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			if (m_pMagicConfigList[sType]->m_sValue4 == 1) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

					bAnalyzeCriminalAction(iClientH, dX, dY);

					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == false) {
							m_pClientList[sOwnerH]->m_bIsPoisoned = true;
							m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
							m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
							// 05/06/2004 - Hypnotoad - poison aura appears when cast Poison
							SetPoisonFlag(sOwnerH, cOwnerType, true);
							SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Poison, m_pMagicConfigList[sType]->m_sValue5, 0, 0);
#ifdef DEF_TAIWANLOG
							_bItemLog(DEF_ITEMLOG_POISONED, sOwnerH, (char*)0, 0);
#endif
						}
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_iHP > 0) goto MAGIC_NOEFFECT;
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == false) {

						}
					}
					break;
				}
			}
			else if (m_pMagicConfigList[sType]->m_sValue4 == 0) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;

					if (m_pClientList[sOwnerH]->m_bIsPoisoned) {
						m_pClientList[sOwnerH]->m_bIsPoisoned = false;
						// 05/06/2004 - Hypnotoad - poison aura removed when cure cast
						SetPoisonFlag(sOwnerH, cOwnerType, false);
						SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::Poison, 0, 0, 0);
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					break;
				}
			}
			break;

		case hb::magic::Berserk:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Berserk] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Berserk] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetBerserkFlag(sOwnerH, cOwnerType, true);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Berserk] != 0) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
					// 2002-09-11 #3
					if (m_pClientList[iClientH]->m_cSide != m_pNpcList[sOwnerH]->m_cSide) goto MAGIC_NOEFFECT;

					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Berserk] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetBerserkFlag(sOwnerH, cOwnerType, true);
					break;
				}

				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Berserk, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime * 1000),
					sOwnerH, cOwnerType, 0, 0, 0, m_pMagicConfigList[sType]->m_sValue4, 0, 0);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Berserk, m_pMagicConfigList[sType]->m_sValue4, 0, 0);
				break;
			}
			break;

		case hb::magic::DamageAreaArmorBreak:
			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
						ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, false, iMagicAttr);
							ArmorLifeDecrement(iClientH, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
						}
					}
				}
			break;

			// Resurrection Magic. 
		case hb::magic::Resurrection:
			// 10 Mins once
			if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) goto MAGIC_NOEFFECT;
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC / 2;
			// Get the ID of the dead Player/NPC on coords dX, dY. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			switch (cOwnerType) {
				// For Player. 
			case DEF_OWNERTYPE_PLAYER:
				// The Player has to exist. 
				if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
				// Resurrection is not for alive Players. 
				if (m_pClientList[sOwnerH]->m_bIsKilled == false) goto MAGIC_NOEFFECT;
				// Set Deadflag to Alive. 
				m_pClientList[sOwnerH]->m_bIsKilled = false;
				// Player's HP becomes half of the Max HP. 
				m_pClientList[sOwnerH]->m_iHP = ((m_pClientList[sOwnerH]->m_iLevel * 2) + (m_pClientList[sOwnerH]->m_iVit * 3) + ((m_pClientList[sOwnerH]->m_iStr + m_pClientList[sOwnerH]->m_iAngelicStr) / 2)) / 2;
				// Send new HP to Player. 
				SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
				// Make Player stand up. (Currently, by a fake damage). 
				m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->ClearDeadOwner(dX, dY);
				m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->SetOwner(sOwnerH, DEF_OWNERTYPE_PLAYER, dX, dY);
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, 0, 0);
				SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
				break;
				// Resurrection is not for NPC's. 
			case DEF_OWNERTYPE_NPC:
				goto MAGIC_NOEFFECT;
				break;
			}
			break;

		case hb::magic::Ice:
			for(int iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for(int ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {
						//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == 0) goto MAGIC_NOEFFECT;
							if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
								}
							}
							break;
						}

					}

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
						(m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false) {

							//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, true, iMagicAttr);
							if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == false)) {
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
									SetIceFlag(sOwnerH, cOwnerType, true);
									bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (m_pMagicConfigList[sType]->m_sValue10 * 1000),
										sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);

									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
								}
							}
						}
					}
				}
			break;

		default:
			break;
		}
	}
	else {
		// Casting
		// Resurrection wand(MS.10) or Resurrection wand(MS.20)

		if (m_pMagicConfigList[sType]->m_sType == hb::magic::Resurrection) {
			//Check if player has resurrection wand
			if (m_pClientList[iClientH] != 0 && m_pClientList[iClientH]->m_iSpecialAbilityTime == 0 &&
				m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == false) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
				if (m_pClientList[sOwnerH] != 0) {
					// GM's can ressurect ne1, and players must be on same side to ressurect

					if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
						return;
					}
					if (cOwnerType == DEF_OWNERTYPE_PLAYER && m_pClientList[sOwnerH] != 0 &&
						m_pClientList[sOwnerH]->m_iHP <= 0) {
						m_pClientList[sOwnerH]->m_bIsBeingResurrected = true;
						SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_RESURRECTPLAYER, 0, 0, 0, 0);
						m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = true;
						m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;
						m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
						m_pClientList[iClientH]->m_iSpecialAbilityTime = m_pMagicConfigList[sType]->m_dwDelayTime;

						m_pClientList[iClientH]->m_appearance.iEffectType = 4;
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, 0);
						SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}
				}
			}
		}
	}

MAGIC_NOEFFECT:

	if (m_pClientList[iClientH] == 0) return;

	//Mana Slate
	if (m_pClientList[iClientH]->m_status.bSlateMana) {
		iManaCost = 0;
	}

	// Mana  .
	m_pClientList[iClientH]->m_iMP -= iManaCost; // sValue1 Mana Cost
	if (m_pClientList[iClientH]->m_iMP < 0)
		m_pClientList[iClientH]->m_iMP = 0;

	CalculateSSN_SkillIndex(iClientH, 4, 1);

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);

	// .  + 100
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType + 100), m_pClientList[iClientH]->m_sType);

}


void CGame::RequestTeleportHandler(int iClientH, char* pData, char* cMapName, int dX, int dY)
{
	char cTempMapName[21];
	char cDestMapName[11], cDir, cMapIndex, cQuestRemain;
	short sX, sY, sSummonPoints;
	int iRet, iSize, iDestX, iDestY, iExH, iMapSide;
	bool    bRet, bIsLockedMapNotify;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess) return;
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsRecallImpossible) &&
		(m_pClientList[iClientH]->m_bIsKilled == false) && (m_bIsApocalypseMode) && (m_pClientList[iClientH]->m_iHP > 0)) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NORECALL, 0, 0, 0, 0);
		return;
	}
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0)
		&& (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0)
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		&& ((pData[0] == '1') || (pData[0] == '3'))
		&& (m_bIsCrusadeMode == false)) return;

	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0)
		&& (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0)
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		&& ((pData[0] == '1') || (pData[0] == '3'))
		&& (m_bIsCrusadeMode == false)) return;

	bIsLockedMapNotify = false;

	if (m_pClientList[iClientH]->m_bIsExchangeMode) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && (pData[0] == '1'))
		return;

	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

	// Delete all summoned NPCs belonging to this player
	for (int i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) {
			if ((m_pNpcList[i]->m_bIsSummoned) &&
				(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
				(m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER)) {
				m_pEntityManager->DeleteEntity(i);
			}
		}

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER,
		m_pClientList[iClientH]->m_sX,
		m_pClientList[iClientH]->m_sY);

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, 0, 0, 0);


	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	std::memset(cDestMapName, 0, sizeof(cDestMapName));
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	// Crusade
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
		iMapSide = iGetMapLocationSide(cDestMapName);
		if (iMapSide > 3) iMapSide -= 2; // New 18/05/2004
		if ((iMapSide != 0) && (m_pClientList[iClientH]->m_cSide == iMapSide)) {
		}
		else {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = true;
			std::memset(cDestMapName, 0, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
		}
	}

	if ((bRet) && (cMapName == 0)) {
		for(int i = 0; i < DEF_MAXMAPS; i++)
			if (m_pMapList[i] != 0) {
				if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
					m_pClientList[iClientH]->m_sX = iDestX;
					m_pClientList[iClientH]->m_sY = iDestY;
					m_pClientList[iClientH]->m_cDir = cDir;
					m_pClientList[iClientH]->m_cMapIndex = i;
					std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);
					goto RTH_NEXTSTEP;
				}
			}

		m_pClientList[iClientH]->m_sX = iDestX;
		m_pClientList[iClientH]->m_sY = iDestY;
		m_pClientList[iClientH]->m_cDir = cDir;
		std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
		memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);

		// New 18/05/2004
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::Confuse,
			m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Confuse], 0, 0);
		SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

		// bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false);  // !   .
		m_pClientList[iClientH]->m_bIsOnServerChange = true;
		m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
		return;
	}
	else {
		switch (pData[0]) {
		case '0':
			// Forced Recall. 
			std::memset(cTempMapName, 0, sizeof(cTempMapName));
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				strcpy(cTempMapName, "default");
			}
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0) {
				strcpy(cTempMapName, "arefarm");
			}
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) {
				strcpy(cTempMapName, "elvfarm");
			}
			else strcpy(cTempMapName, m_pClientList[iClientH]->m_cLocation);

			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				bIsLockedMapNotify = true;
				std::memset(cTempMapName, 0, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for(int i = 0; i < DEF_MAXMAPS; i++)
				if (m_pMapList[i] != 0) {
					if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
						GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

						m_pClientList[iClientH]->m_cMapIndex = i;
						std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);
						goto RTH_NEXTSTEP;
					}
				}

			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;	  // -1 InitialPoint .

			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);

			// New 18/05/2004
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::Confuse,
				m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Confuse], 0, 0);
			SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

			// bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); // !   .

			m_pClientList[iClientH]->m_bIsOnServerChange = true;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
			return;

		case '1':
			// Recall.     .
			// if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;

			std::memset(cTempMapName, 0, sizeof(cTempMapName));
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				strcpy(cTempMapName, "default");
			}
			else {
				if (m_pClientList[iClientH]->m_iLevel > 80)
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0)
						strcpy(cTempMapName, "aresden");
					else strcpy(cTempMapName, "elvine");
				else {
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0)
						strcpy(cTempMapName, "arefarm");
					else strcpy(cTempMapName, "elvfarm");
				}
			}
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				bIsLockedMapNotify = true;
				std::memset(cTempMapName, 0, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for(int i = 0; i < DEF_MAXMAPS; i++)
				if (m_pMapList[i] != 0) {
					if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {

						GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

						m_pClientList[iClientH]->m_cMapIndex = i;
						std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);
						goto RTH_NEXTSTEP;
					}
				}

			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;	  // -1 InitialPoint .

			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);

			// New 18/05/2004
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::Confuse,
				m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Confuse], 0, 0);
			SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

			// bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); // !   .
			m_pClientList[iClientH]->m_bIsOnServerChange = true;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
			return;

		case '2':

			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = true;
				std::memset(cTempMapName, 0, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				std::memset(cTempMapName, 0, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}

			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				m_pClientList[iClientH]->m_sX = dX; // -1;	  //   .
				m_pClientList[iClientH]->m_sY = dY; // -1;	  // -1 InitialPoint .

				std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);

				// New 18/05/2004
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::Confuse,
					m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Confuse], 0, 0);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, false);

				// bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, false); // !   .
				m_pClientList[iClientH]->m_bIsOnServerChange = true;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = true;
				return;
			}

			m_pClientList[iClientH]->m_sX = dX;
			m_pClientList[iClientH]->m_sY = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;

			std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);
			break;
		}
	}

RTH_NEXTSTEP:

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	// Set faction/identity status fields from player data
	m_pClientList[iClientH]->m_status.bPK = (m_pClientList[iClientH]->m_iPKCount != 0) ? 1 : 0;
	m_pClientList[iClientH]->m_status.bCitizen = (m_pClientList[iClientH]->m_cSide != 0) ? 1 : 0;
	m_pClientList[iClientH]->m_status.bAresden = (m_pClientList[iClientH]->m_cSide == 1) ? 1 : 0;
	m_pClientList[iClientH]->m_status.bHunter = m_pClientList[iClientH]->m_bIsPlayerCivil ? 1 : 0;

	// Crusade
	if (bIsLockedMapNotify) SendNotifyMsg(0, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, 0, 0, m_pClientList[iClientH]->m_cLockedMapName);

	hb::net::PacketWriter writer;
	char initMapData[DEF_MSGBUFFERSIZE + 1];

	writer.Reset();
	auto* init_header = writer.Append<hb::net::PacketResponseInitDataHeader>();
	init_header->header.msg_id = MSGID_RESPONSE_INITDATA;
	init_header->header.msg_type = DEF_MSGTYPE_CONFIRM;

	if (m_pClientList[iClientH]->m_bIsObserverMode == false)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	init_header->player_object_id = static_cast<std::int16_t>(iClientH);
	init_header->pivot_x = static_cast<std::int16_t>(m_pClientList[iClientH]->m_sX - DEF_PLAYER_PIVOT_OFFSET_X);
	init_header->pivot_y = static_cast<std::int16_t>(m_pClientList[iClientH]->m_sY - DEF_PLAYER_PIVOT_OFFSET_Y);
	init_header->player_type = m_pClientList[iClientH]->m_sType;
	init_header->appearance = m_pClientList[iClientH]->m_appearance;
	init_header->status = m_pClientList[iClientH]->m_status;
	std::memcpy(init_header->map_name, m_pClientList[iClientH]->m_cMapName, sizeof(init_header->map_name));
	std::memcpy(init_header->cur_location, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sizeof(init_header->cur_location));

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)
		init_header->sprite_alpha = 1;
	else init_header->sprite_alpha = m_cDayOrNight;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)
		init_header->weather_status = 0;
	else init_header->weather_status = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;

	init_header->contribution = m_pClientList[iClientH]->m_iContribution;

	if (m_pClientList[iClientH]->m_bIsObserverMode == false) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH,
			DEF_OWNERTYPE_PLAYER,
			m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY);
	}

	init_header->observer_mode = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_bIsObserverMode);
	init_header->rating = m_pClientList[iClientH]->m_iRating;
	init_header->hp = m_pClientList[iClientH]->m_iHP;
	init_header->discount = 0;

	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - DEF_VIEWCENTER_X, m_pClientList[iClientH]->m_sY - DEF_VIEWCENTER_Y, iClientH, initMapData);
	writer.AppendBytes(initMapData, static_cast<std::size_t>(iSize));

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);

	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_bIsWarLocation = true;
		// New 17/05/2004
		CheckForceRecallTime(iClientH);
	}
	else if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)) {

		m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_bIsWarLocation = true;

		// New 17/05/2004
		CheckForceRecallTime(iClientH);
	}
	else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) {
		m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_bIsWarLocation = true;
		SetForceRecallTime(iClientH);

		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 20 * 60 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 2 * 20;

	}
	else {
		m_pClientList[iClientH]->m_bIsWarLocation = false;
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		SetForceRecallTime(iClientH);
	}

	// No entering enemy shops
	int iMapside, iMapside2;

	iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
	if (iMapside > 3) iMapside2 = iMapside - 2;
	else iMapside2 = iMapside;
	m_pClientList[iClientH]->m_bIsInsideOwnTown = false;
	if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
		if ((iMapside <= 2)) {
			if (m_pClientList[iClientH]->m_cSide != 0) {
				m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
				m_pClientList[iClientH]->m_bIsWarLocation = true;
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				m_pClientList[iClientH]->m_bIsInsideOwnTown = true;
			}
		}
	}
	else {
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone &&
			m_iFightzoneNoForceRecall == false) {
			m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
			m_pClientList[iClientH]->m_bIsWarLocation = true;
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2 * 60 * 20 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 2 * 20;
		}
		else {
			if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0 ||
				memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0) {
				m_pClientList[iClientH]->m_bIsWarLocation = true;
				m_pClientList[iClientH]->m_dwWarBeginTime = GameClock::GetTimeMS();
				if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
					m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
				else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
					m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
			}
		}
	}

	// . v1.1
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SAFEATTACKMODE, 0, 0, 0, 0);
	// v1.3
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, 0, 0, 0);
	// V1.3
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMPOSLIST, 0, 0, 0, 0);
	// v1.4 
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, 0, 0, 0, 0);

	if (m_bIsCrusadeMode) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// ? GUID .  .
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, 0, 0, -1);
		}
		m_pClientList[iClientH]->m_cVar = 1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, 0);
	}
	else if (m_bIsHeldenianMode) {
		sSummonPoints = m_pClientList[iClientH]->m_iCharisma * 300;
		if (sSummonPoints > m_iMaxSummonPoints) sSummonPoints = m_iMaxSummonPoints;
		if (m_pClientList[iClientH]->m_dwHeldenianGUID == 0) {
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
		}
		else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) {
			m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
		}
		m_pClientList[iClientH]->m_cVar = 2;
		if (m_bIsHeldenianMode) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0);
		}
		if (m_bHeldenianInitiated) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0);
		}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, 0);
		UpdateHeldenianStatus();
	}
	else if ((m_pClientList[iClientH]->m_cVar == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
		m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iConstructionPoint = 0;
	}
	else {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_pClientList[iClientH]->m_cVar == 1) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, 0, 0, -1);
			}
		}
		else {
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			m_pClientList[iClientH]->m_iWarContribution = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	// 2002-7-4
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	// Crusade
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, 0);

	// v2.15
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

	if (m_bIsHeldenianMode) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0);
		if (m_bHeldenianInitiated) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANSTART, 0, 0, 0, 0);
		}
		else {
			UpdateHeldenianStatus();
		}
	}

	if (m_pClientList[iClientH]->m_iQuest != 0) {
		cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, 0, 0, 0);
		_bCheckIsQuestCompleted(iClientH);
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HUNGER, m_pClientList[iClientH]->m_iHungerStatus, 0, 0, 0);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
}

void CGame::ReleaseFollowMode(short sOwnerH, char cOwnerType)
{
	

	for(int i = 0; i < DEF_MAXNPCS; i++)
		if ((i != sOwnerH) && (m_pNpcList[i] != 0)) {
			if ((m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) &&
				(m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
				(m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {

				m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
			}
		}
}

void CGame::RequestStudyMagicHandler(int iClientH, const char* pName, bool bIsPurchase)
{
	char cMagicName[31];
	uint32_t dwGoldCount;
	int iReqInt, iCost, iRet;
	bool bMagic = true;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;


	std::memset(cMagicName, 0, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);

	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) {

	}
	else {
		if (bIsPurchase) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = false;
			dwGoldCount = dwGetItemCountByID(iClientH, hb::item::ItemId::Gold);
			if ((uint32_t)iCost > dwGoldCount)  bMagic = false;
		}
		//wizard remove
		//if (m_pClientList[iClientH]->m_bIsInsideWizardTower == false && bIsPurchase) return;
		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;

		if ((iReqInt <= (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt)) && (bMagic)) {

			if (bIsPurchase) SetItemCountByID(iClientH, hb::item::ItemId::Gold, dwGoldCount - iCost);

			iCalcTotalWeight(iClientH);

			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;

			{

				hb::net::PacketNotifyMagicStudySuccess pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = DEF_NOTIFY_MAGICSTUDYSUCCESS;
				pkt.magic_id = static_cast<uint8_t>(iRet);
				memcpy(pkt.magic_name, cMagicName, sizeof(pkt.magic_name));
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}

			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return;
			}
		}
		else {
			{

				hb::net::PacketNotifyMagicStudyFail pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = DEF_NOTIFY_MAGICSTUDYFAIL;
				pkt.result = 1;
				pkt.magic_id = static_cast<uint8_t>(iRet);
				memcpy(pkt.magic_name, cMagicName, sizeof(pkt.magic_name));
				pkt.cost = static_cast<int32_t>(iCost);
				pkt.req_int = static_cast<int32_t>(iReqInt);
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return;
			}
		}
	}
}

int CGame::_iGetMagicNumber(char* pMagicName, int* pReqInt, int* pCost)
{
	
	char cTmpName[31];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for(int i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != 0) {
			if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
				*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
				*pCost = (int)m_pMagicConfigList[i]->m_iGoldCost;

				return i;
			}
		}

	return -1;
}

void CGame::TrainSkillResponse(bool bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{

	int   iRet;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((iSkillNum < 0) || (iSkillNum > 100)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;

	if (bSuccess) {
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] != 0) return;

		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);

		{

			hb::net::PacketNotifySkillTrainSuccess pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = DEF_NOTIFY_SKILLTRAINSUCCESS;
			pkt.skill_num = static_cast<uint8_t>(iSkillNum);
			pkt.skill_level = static_cast<uint8_t>(iSkillLevel);
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return;
		}
	}
	else {


	}

}


bool CGame::__bReadMapInfo(int iMapIndex)
{
	char* pContents, * token, * pTile, cTxt[250], cFn[255];
	char seps[] = "= \t\r\n";
	char cReadModeA = 0;
	char cReadModeB = 0;
	int  iTeleportLocIndex = 0;
	int  iWayPointCfgIndex = 0;
	int  iTotalNpcSetting = 0;
	int  iMGARCfgIndex = 0;
	int  iSMGRCfgIndex = 0;
	int  iNMRCfgIndex = 0;
	int  iFishPointIndex = 0;
	int  iMineralPointIndex = 0;
	int  iStrategicPointIndex = 0;
	int  iIndex = 0;

	int  iNamingValue;
	HANDLE hFile;
	size_t  dwFileSize, dwReadSize;
	FILE* pFile;

	char cName[6], cNpcName[DEF_NPCNAME], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
	short sIPindex, dX, dY;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fightzone", 9) == 0)
		m_pMapList[iMapIndex]->m_bIsFightZone = true;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0)
		m_pMapList[iMapIndex]->m_bIsSnowEnabled = true;

	std::memset(cFn, 0, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	if (hFile == INVALID_HANDLE_VALUE) return false;
	dwFileSize = GetFileSize(hFile, 0);
	CloseHandle(hFile);


	pContents = new char[dwFileSize + 1];
	std::memset(pContents, 0, dwFileSize + 1);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		std::snprintf(cTxt, sizeof(cTxt), "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return false;
	}
	else {
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	token = strtok(pContents, seps);
	while (token != 0) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					std::memset(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 0, sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:
				switch (cReadModeB) {
				case 1:
					// waypoint
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
						// Waypoint .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					break;

				case 2:
					// waypoint   X
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// waypoint   Y
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:
				// Npc  .
				switch (cReadModeB) {
				case 1:
					// NPC .
					std::memset(cNpcName, 0, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:
					// NpcMoveType
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					cNpcWaypointIndex[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;
				case 13:
					// cNamePrefix
					cNamePrefix = token[0];
					// NPC .

					iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						// NPC  .     .
					}
					else {
						// NPC .
						std::memset(cName, 0, sizeof(cName));
						std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
						cName[0] = cNamePrefix;
						cName[1] = iMapIndex + 65;

						if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, 0, 0, cNpcWaypointIndex, 0, 0, -1, false) == false) {
							// NameValue .
							m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
						}
					}
					cReadModeA = 0;
					cReadModeB = 0;
					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:
				switch (cReadModeB) {
				case 1:
					// Random-Mob-Generator
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_bRandomMobGenerator = (bool)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// Mob- Level
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:
				// Maximum object
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete[] pContents;
					return false;
				}

				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:
				switch (cReadModeB) {
				case 1:
					// Rect
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					iMGARCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].x != -1) {
						// Waypoint .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete[] pContents;
						return false;
					}

					cReadModeB = 2;
					break;

				case 2:
					// left
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// top
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].y = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// right
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].width = atoi(token) - m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].x;
					cReadModeB = 5;
					break;

				case 5:
					// bottom
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].height = atoi(token) - m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].y;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 7:
				switch (cReadModeB) {
				case 1:
					// Rect  m_stSpotMobGenerator[]
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete[] pContents;
						return false;
					}
					iSMGRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = true;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
						cReadModeB = 3;
					else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
						cReadModeB = 9;  // RECT  Waypoint  .
					break;

				case 3:
					// x (was left)
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.x = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// y (was top)
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.y = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// width (file stores right edge, convert: width = right - x)
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.width = atoi(token) - m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.x;
					cReadModeB = 6;
					break;

				case 6:
					// height (file stores bottom edge, convert: height = bottom - y)
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.height = atoi(token) - m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.y;
					cReadModeB = 7;
					break;

				case 7:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// Max Mobs
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs = 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
					break;

				case 19:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs = 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 8:
				std::memset(m_pMapList[iMapIndex]->m_cLocationName, 0, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9:
				switch (cReadModeB) {
				case 1:
					// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					break;

				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 10:
				// RECT
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iNMRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].y != -1) {
						// No-Magic-Rect .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete[] pContents;
						return false;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].y = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// width (file stores right edge, convert: width = right - x)
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].width = atoi(token) - m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].x;
					cReadModeB = 5;
					break;

				case 5:
					// height (file stores bottom edge, convert: height = bottom - y)
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].height = atoi(token) - m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].y;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11:
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = (bool)atoi(token);
				if (m_pMapList[iMapIndex]->m_bIsFixedDayMode)
					m_pMapList[iMapIndex]->m_bIsSnowEnabled = false;
				cReadModeA = 0;
				break;

			case 12:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iFishPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						// Fish Point .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

				cReadModeA = 0;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = (bool)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iMineralPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						// Mineral Point .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iStrategicPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != 0) {
						// Strategic Point .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != 0) {
						// Energy-Sphere-Creation Point .
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != 0) {
						// Energy-Sphere-Goal Point .
						std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
						PutLogList(G_cTxt);
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);

					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != 0) {
						// Point .
						std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(G_cTxt);
						delete[] pContents;
						return false;
					}

					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);

					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);

					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);

					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);

					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);

					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);

					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);

					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);

					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);

					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);

					cReadModeB = 15;
					break;

				case 15:
					std::memset(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, 0, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);

					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break; // end 23

			case 24:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex = atoi(token);

					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != 0) {
						// Item-Event .
						std::snprintf(G_cTxt, sizeof(G_cTxt), "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(G_cTxt);
						delete[] pContents;
						return false;
					}

					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;

				case 2:
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);

					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 25: //mobevent-amount
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					cReadModeB = 0;
					break;
				}
				break;

			case 26: //ApocalypseMobGenType
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_iApocalypseMobGenType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 27: // ApocalypseBossMob
				switch (cReadModeB) {
				case 1: // 3CB6Ch m_pMapList[]->m_ApocalypseBossMobNpcID
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // 3CB70h m_pMapList[]->ApocalypseBossMobRectX1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcApocalypseBossMob.x = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // 3CB74h m_pMapList[]->ApocalypseBossMobRectY1
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcApocalypseBossMob.y = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // 3CB78h m_pMapList[]->ApocalypseBossMobRectX2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcApocalypseBossMob.width = atoi(token) - m_pMapList[iMapIndex]->m_rcApocalypseBossMob.x;
					cReadModeB = 5;
					break;
				case 5: // 3CB7Ch m_pMapList[]->ApocalypseBossMobRectY2
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcApocalypseBossMob.height = atoi(token) - m_pMapList[iMapIndex]->m_rcApocalypseBossMob.y;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 28: //DynamicGateType // 28
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 29: //DynamicGateCoord // 29
				// DynamicGateCoord	= 59 196 60 197        abaddon	   -1  -1
				switch (cReadModeB) {
				case 1: // 3CA20h
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcDynamicGateCoord.x = atoi(token);
					cReadModeB = 2;
					break;

				case 2: // 3CA24h
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcDynamicGateCoord.y = atoi(token);
					cReadModeB = 3;
					break;

				case 3: // 3CA28h
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcDynamicGateCoord.width = atoi(token) - m_pMapList[iMapIndex]->m_rcDynamicGateCoord.x;
					cReadModeB = 4;
					break;

				case 4: // 3CA2Ch
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_rcDynamicGateCoord.height = atoi(token) - m_pMapList[iMapIndex]->m_rcDynamicGateCoord.y;
					cReadModeB = 5;
					break;

				case 5: // 3CA30h
					memcpy(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, token, strlen(token));
					cReadModeB = 6;
					break;

				case 6: // 3CA3Ch
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // (ty = 3CB60h) unknown (3CA3Eh)
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 30: // RecallImpossible // 30
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error RecallImpossible -  Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsRecallImpossible = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 31: // ApocalypseMap // 31
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsApocalypseMap = static_cast<bool>(atoi(token));
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 32: // CitizenLimit // 32
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsCitizenLimit = static_cast<bool>(atoi(token));
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 33: // HeldenianMap
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 34: // HeldenianTower
				switch (cReadModeB) {
				case 1: // NpcID
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].sTypeID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // side 
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].cSide = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dX = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 35: // HeldenianModeMap
				if (_bGetIsStringIsNumber(token) == false) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
					delete[] pContents;
					return false;
				}
				m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 36: // HeldenianWinningZone
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					dX = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					dY = atoi(token);
					pTile = 0;
					pTile = (char*)(m_pMapList[iMapIndex]->m_pTile + dX + dY * m_pMapList[iMapIndex]->m_sSizeY);
					if (pTile == 0) {
						std::snprintf(cTxt, sizeof(cTxt), "(!!!) CRITICAL ERROR! Map Info file error HeldenianWinningZone - pTile is Null dx(%d), dy(%d).", dX, dY);
						PutLogList(cTxt);
						delete[] pContents;
						return false;
					}
					//pTile->m_iAttribute = 1;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 37: // HeldenianGateDoor // 37
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].cDir = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dX = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					if (_bGetIsStringIsNumber(token) == false) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format.");
						delete[] pContents;
						return false;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dY = atoi(token);
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default:
				break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}

			if (memcmp(token, "maximum-object", 14) == 0)
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;	// v1.4
			if (memcmp(token, "strategic-point", 15) == 0) {	// v1.41
				cReadModeA = 20;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}

			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = true;
			}

			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) {
				cReadModeA = 26;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseBossMob", 17) == 0) {
				cReadModeA = 27;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateType", 15) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateCoord", 16) == 0) {
				cReadModeA = 29;
				cReadModeB = 1;
			}

			if (memcmp(token, "RecallImpossible", 16) == 0) {
				cReadModeA = 30;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMap", 13) == 0) {
				cReadModeA = 31;
				cReadModeB = 1;
			}

			if (memcmp(token, "CitizenLimit", 12) == 0) {
				cReadModeA = 32;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianMap", 12) == 0) {
				cReadModeA = 33;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianTower", 14) == 0) {
				cReadModeA = 34;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianModeMap", 16) == 0) {
				cReadModeA = 35;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianWinningZone", 20) == 0) {
				cReadModeA = 36;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianGateDoor", 17) == 0) {
				cReadModeA = 37;
				cReadModeB = 1;
			}

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = strtok(NULL, seps);
	}

RMI_SKIPDECODING:

	delete[] pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return false;
	}

	PutLogList(cTxt);

	// Crusade     .
	m_pMapList[iMapIndex]->_SetupNoAttackArea();

	return true;

}

void CGame::Quit()
{
	

	G_bIsThread = false;
	Sleep(300);

	if (_lsock != 0) delete _lsock;

	for(int i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) delete m_pClientList[i];

	for(int i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) delete m_pNpcList[i];

	for(int i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) delete m_pMapList[i];

	for(int i = 0; i < DEF_MAXITEMTYPES; i++)
		if (m_pItemConfigList[i] != 0) delete m_pItemConfigList[i];

	for(int i = 0; i < DEF_MAXNPCTYPES; i++)
		if (m_pNpcConfigList[i] != 0) delete m_pNpcConfigList[i];

	for(int i = 0; i < DEF_MAXMAGICTYPE; i++)
		if (m_pMagicConfigList[i] != 0) delete m_pMagicConfigList[i];

	for(int i = 0; i < DEF_MAXSKILLTYPE; i++)
		if (m_pSkillConfigList[i] != 0) delete m_pSkillConfigList[i];

	for(int i = 0; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != 0) delete m_pQuestConfigList[i];

	for(int i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != 0) delete m_pDynamicObjectList[i];

	for(int i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != 0) delete m_pDelayEventList[i];

	for(int i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		if (m_pNoticeMsgList[i] != 0) delete m_pNoticeMsgList[i];

	for(int i = 0; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] != 0) delete m_pFish[i];

	for(int i = 0; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] != 0) delete m_pMineral[i];

	for(int i = 0; i < DEF_MAXPORTIONTYPES; i++)
	{
		if (m_pPortionConfigList[i] != 0) delete m_pPortionConfigList[i];
		if (m_pCraftingConfigList[i] != 0) delete m_pCraftingConfigList[i];	// Crafting
	}

	//	for(int i = 0; i < DEF_MAXTELEPORTTYPE; i++)
	//	if (m_pTeleportConfigList[i] != 0) delete m_pTeleportConfigList[i];

	for(int i = 0; i < hb::limits::MaxBuildItems; i++)
		if (m_pBuildItemList[i] != 0) delete m_pBuildItemList[i];

	if (m_pNoticementData != 0) delete m_pNoticementData;

}

uint32_t CGame::iGetLevelExp(int iLevel)
{
	return CalculateLevelExp(iLevel);
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
	int iRet;

	if (iLevel < 1) return 1;

	if (iLevel <= 50)
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = (iLevel * 2);
	}

	return iRet;
}

/*****************************************************************
**---------------------------FUNCTION---------------------------**
**             void Game::CheckLevelUp(int iClientH)            **
**-------------------------DESCRIPTION--------------------------**
** Level-Up                                                     **
**  - Level +1                                                  **
**  - +3 Level Up Points                                        **
**  - Reset Next Level EXP                                      **
**  - Civilian Level Limit                                      **
**      Player mode switches to Combatant                       **
**      when the limit is reached                               **
**  - Majestic Points +1                                        **
**  - Reset Next Level EXP                                      **
**------------------------CREATION DATE-------------------------**
**                January 30, 2007; 3:06 PM; Dax                **
*****************************************************************/
bool CGame::bCheckLevelUp(int iClientH)
{

	if (m_pClientList[iClientH] == 0) return false;


	while (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp)
	{
		if (m_pClientList[iClientH]->m_iLevel < m_iMaxLevel)
		{
			m_pClientList[iClientH]->m_iLevel++;
			m_pClientList[iClientH]->m_iLU_Pool += 3;
//			if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
//	  		      m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) <= DEF_TOTALLEVELUPPOINT) {


			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;

			// New 17/05/2004
			if (m_pClientList[iClientH]->m_iLevel > 100)
				if (m_pClientList[iClientH]->m_bIsPlayerCivil)
					ForceChangePlayMode(iClientH, true);

			// centu - max hp,mp,sp when level up
			m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
			m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
			m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_LEVELUP, 0, 0, 0, 0);

			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

			CalcTotalItemEffect(iClientH, -1, false);

			//std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Level up: Player (%s) Level (%d) Experience(%d) Next Level Experience(%d)", m_pClientList[iClientH]->m_cCharName,m_pClientList[iClientH]->m_iLevel, m_pClientList[iClientH]->m_iExp, m_pClientList[iClientH]->m_iNextLevelExp);
			//PutLogFileList(G_cTxt);
		}
		else {
			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft++;

			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_iMaxLevel + 1];
			m_pClientList[iClientH]->m_iExp = m_iLevelExpTable[m_iMaxLevel];
			//addon
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 1, 0, 0);
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
	}

	return false;
}
// 2003-04-14      ...
void CGame::StateChangeHandler(int iClientH, char* pData, size_t dwMsgSize)
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestStateChange>(
		pData, sizeof(hb::net::PacketRequestStateChange));
	if (!pkt) return;

	int16_t cStr = pkt->str;
	int16_t cVit = pkt->vit;
	int16_t cDex = pkt->dex;
	int16_t cInt = pkt->intel;
	int16_t cMag = pkt->mag;
	int16_t cChar = pkt->chr;

	// All reduction values must be >= 0
	if (cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	// Total must be a positive multiple of 3 (DEF_TOTALLEVELUPPOINT per majestic point)
	int iTotalReduction = cStr + cVit + cDex + cInt + cMag + cChar;
	if (iTotalReduction <= 0 || (iTotalReduction % DEF_TOTALLEVELUPPOINT) != 0)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	int iMajesticCost = iTotalReduction / DEF_TOTALLEVELUPPOINT;
	if (iMajesticCost > m_pClientList[iClientH]->m_iGizonItemUpgradeLeft)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
		return;
	}

	// Stats must equal the max-level formula (all points fully allocated)
	int iOldStr = m_pClientList[iClientH]->m_iStr;
	int iOldVit = m_pClientList[iClientH]->m_iVit;
	int iOldDex = m_pClientList[iClientH]->m_iDex;
	int iOldInt = m_pClientList[iClientH]->m_iInt;
	int iOldMag = m_pClientList[iClientH]->m_iMag;
	int iOldChar = m_pClientList[iClientH]->m_iCharisma;

	if (iOldStr + iOldVit + iOldDex + iOldInt + iOldMag + iOldChar != ((m_iMaxLevel - 1) * 3 + 70))
		return;

	// Each stat must stay >= 10 and <= DEF_CHARPOINTLIMIT after reduction
	if ((iOldStr - cStr < 10) || (iOldStr - cStr > DEF_CHARPOINTLIMIT)) { SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0); return; }
	if ((iOldVit - cVit < 10) || (iOldVit - cVit > DEF_CHARPOINTLIMIT)) { SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0); return; }
	if ((iOldDex - cDex < 10) || (iOldDex - cDex > DEF_CHARPOINTLIMIT)) { SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0); return; }
	if ((iOldInt - cInt < 10) || (iOldInt - cInt > DEF_CHARPOINTLIMIT)) { SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0); return; }
	if ((iOldMag - cMag < 10) || (iOldMag - cMag > DEF_CHARPOINTLIMIT)) { SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0); return; }
	if ((iOldChar - cChar < 10) || (iOldChar - cChar > DEF_CHARPOINTLIMIT)) { SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0); return; }

	// Guild masters cannot reduce CHR below 20
	if (m_pClientList[iClientH]->m_iGuildRank == 0)
	{
		if (iOldChar - cChar < 20)
		{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, 0, 0, 0, 0);
			return;
		}
	}

	std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Majestic: Char(%s) cost(%d) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d)",
		m_pClientList[iClientH]->m_cCharName, iMajesticCost, cStr, cVit, cDex, cInt, cMag, cChar);
	PutLogList(G_cTxt);

	// Apply reductions
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= iMajesticCost;
	m_pClientList[iClientH]->m_iLU_Pool += iTotalReduction;

	m_pClientList[iClientH]->m_iStr -= cStr;
	m_pClientList[iClientH]->m_iVit -= cVit;
	m_pClientList[iClientH]->m_iDex -= cDex;
	m_pClientList[iClientH]->m_iInt -= cInt;
	if (cInt > 0) bCheckMagicInt(iClientH);
	m_pClientList[iClientH]->m_iMag -= cMag;
	m_pClientList[iClientH]->m_iCharisma -= cChar;

	// Recalculate derived stats
	m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
	m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, 0, 0, 0, 0);
}

// 2003-04-21     ...
//  bool CGame::bCheckMagicInt(int iClientH)  //another retarded korean function
// desc		 ::     ... ...
// return value ::  true   // ....dumbass koreans
//  date		 :: 2003-04-21
bool CGame::bCheckMagicInt(int iClientH)
{

	for(int i = 0; i < DEF_MAXMAGICTYPE; i++)
	{
		if (m_pMagicConfigList[i] != 0)
			if (m_pMagicConfigList[i]->m_sIntLimit > (m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt))
			{
				m_pClientList[iClientH]->m_cMagicMastery[i] = 0;
			}
	}

	return true;
}

// 2003-04-14      ...
//  bChangeState(char cStateChange 
//  		  ,char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
// desc		 ::      ...
// return value :: BOOL 0(FASLE)    ...
//  date		 :: [2003-04-14] 
bool CGame::bChangeState(char cStateChange, char* cStr, char* cVit, char* cDex, char* cInt, char* cMag, char* cChar)
{
	if (cStateChange == DEF_STR)
	{
		*cStr += 1;
	}
	else if (cStateChange == DEF_VIT)
	{
		*cVit += 1;
	}
	else if (cStateChange == DEF_DEX)
	{
		*cDex += 1;
	}
	else if (cStateChange == DEF_INT)
	{
		*cInt += 1;
	}
	else if (cStateChange == DEF_MAG)
	{
		*cMag += 1;
	}
	else if (cStateChange == DEF_CHR)
	{
		*cChar += 1;
	}
	else
	{
// ::MessageBox(0, " ? -  ?","debug", MB_ICONEXCLAMATION | MB_YESNO) ;
		return 0;
	}

	return cStateChange;
}

void CGame::LevelUpSettingsHandler(int iClientH, char* pData, size_t dwMsgSize)
{
	int iTotalSetting = 0;

	int16_t cStr, cVit, cDex, cInt, cMag, cChar;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iLU_Pool <= 0)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return;
	}

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestLevelUpSettings>(pData, sizeof(hb::net::PacketRequestLevelUpSettings));
	if (!req) return;

	cStr = req->str;
	cVit = req->vit;
	cDex = req->dex;
	cInt = req->intel;
	cMag = req->mag;
	cChar = req->chr;

	if ((cStr + cVit + cDex + cInt + cMag + cChar) > m_pClientList[iClientH]->m_iLU_Pool)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return;
	}

	// Check if adding points would exceed the stat limit or be negative
	if ((m_pClientList[iClientH]->m_iStr + cStr > DEF_CHARPOINTLIMIT) || (cStr < 0))
		return;

	if ((m_pClientList[iClientH]->m_iDex + cDex > DEF_CHARPOINTLIMIT) || (cDex < 0))
		return;

	if ((m_pClientList[iClientH]->m_iInt + cInt > DEF_CHARPOINTLIMIT) || (cInt < 0))
		return;

	if ((m_pClientList[iClientH]->m_iVit + cVit > DEF_CHARPOINTLIMIT) || (cVit < 0))
		return;

	if ((m_pClientList[iClientH]->m_iMag + cMag > DEF_CHARPOINTLIMIT) || (cMag < 0))
		return;

	if ((m_pClientList[iClientH]->m_iCharisma + cChar > DEF_CHARPOINTLIMIT) || (cChar < 0))
		return;

	iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	// (  +   >   ) ..  ..      ..
	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool > ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70))
	{
		m_pClientList[iClientH]->m_iLU_Pool = (m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70 - iTotalSetting;

		if (m_pClientList[iClientH]->m_iLU_Pool < 0)
			m_pClientList[iClientH]->m_iLU_Pool = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return;
	}

	// (  +    D >   )  ..
	if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChar) > ((m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70))
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_FAILED, 0, 0, 0, 0);
		return;
	}

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChar);

	m_pClientList[iClientH]->m_iStr += cStr;
	m_pClientList[iClientH]->m_iVit += cVit;
	m_pClientList[iClientH]->m_iDex += cDex;
	m_pClientList[iClientH]->m_iInt += cInt;
	m_pClientList[iClientH]->m_iMag += cMag;
	m_pClientList[iClientH]->m_iCharisma += cChar;

	// Recalculate item effects and weapon swing speed after stat changes
	CalcTotalItemEffect(iClientH, -1, false);

	// Recalculate weapon swing speed (m_status.iAttackDelay)
	short sWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
	if (sWeaponIndex == -1)
		sWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
	if (sWeaponIndex != -1 && m_pClientList[iClientH]->m_pItemList[sWeaponIndex] != nullptr)
	{
		short sSpeed = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_cSpeed;
		sSpeed -= ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) / 13);
		if (sSpeed < 0) sSpeed = 0;
		m_pClientList[iClientH]->m_status.iAttackDelay = static_cast<uint8_t>(sSpeed);
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);

}


void CGame::FightzoneReserveHandler(int iClientH, char* pData, size_t dwMsgSize)
{
	int iFightzoneNum, iEnableReserveTime;
	uint32_t dwGoldCount;
	uint16_t wResult;
	int     iRet, iResult = 1, iCannotReserveDay;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	GetLocalTime(&SysTime);

	iEnableReserveTime = 2 * 20 * 60 - ((SysTime.wHour % 2) * 20 * 60 + SysTime.wMinute * 20) - 5 * 20;

	dwGoldCount = dwGetItemCountByID(iClientH, hb::item::ItemId::Gold);

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestFightzoneReserve>(
		pData, sizeof(hb::net::PacketRequestFightzoneReserve));
	if (!pkt) return;
	iFightzoneNum = pkt->fightzone;

	// fightzone  .
	if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;

	// 2 4 6 8  1 3 5 7
	// ex) 1 => {1 + 1 () + 1 (  )} %2 == 1

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum) % 2;
	if (iEnableReserveTime <= 0) {
		wResult = DEF_MSGTYPE_REJECT;
		iResult = 0;
	}
	else if (m_iFightZoneReserve[iFightzoneNum - 1] != 0) {
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -1;
	}
	else if (dwGoldCount < 1500) {
		// Gold    .
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -2;
	}
	else if (iCannotReserveDay) {
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -3;
	}
	else if (m_pClientList[iClientH]->m_iFightzoneNumber != 0) {
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -4;
	}
	else {

		wResult = DEF_MSGTYPE_CONFIRM;

		SetItemCountByID(iClientH, hb::item::ItemId::Gold, dwGoldCount - 1500);
		iCalcTotalWeight(iClientH);

		m_iFightZoneReserve[iFightzoneNum - 1] = iClientH;

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneNum;
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth * 10000 + SysTime.wDay * 100 + SysTime.wHour;

		if (SysTime.wHour % 2)	m_pClientList[iClientH]->m_iReserveTime += 1;
		else					m_pClientList[iClientH]->m_iReserveTime += 2;
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 50;
		iResult = 1;
	}

	hb::net::PacketResponseFightzoneReserve resp{};
	resp.header.msg_id = MSGID_RESPONSE_FIGHTZONE_RESERVE;
	resp.header.msg_type = wResult;
	resp.result = iResult;


	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&resp), sizeof(resp));

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}
}


bool CGame::bCheckLimitedUser(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return false;

	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) &&
		(m_pClientList[iClientH]->m_iExp >= m_iLevelExp20)) {
		// 20   19 .

		m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, 0, 0, 0, 0);
		return true;
	}


	return false;
}

void CGame::RequestCivilRightHandler(int iClientH, char* pData)
{
	uint16_t wResult;
	int  iRet;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) wResult = 0;
	else wResult = 1;

	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;

	if (wResult == 1) {
		std::memset(m_pClientList[iClientH]->m_cLocation, 0, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
	}

	// Side
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 1;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 2;

	hb::net::PacketResponseCivilRight pkt{};
	pkt.header.msg_id = MSGID_RESPONSE_CIVILRIGHT;
	pkt.header.msg_type = wResult;
	std::memset(pkt.location, 0, sizeof(pkt.location));
	memcpy(pkt.location, m_pClientList[iClientH]->m_cLocation, sizeof(pkt.location));

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}


void CGame::RequestRetrieveItemHandler(int iClientH, char* pData)
{
	char cBankItemIndex;
	int j, iRet, iItemWeight;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestRetrieveItem>(
		pData, sizeof(hb::net::PacketRequestRetrieveItem));
	if (!pkt) return;
	cBankItemIndex = static_cast<char>(pkt->item_slot);
	//wh remove
	//if (m_pClientList[iClientH]->m_bIsInsideWarehouse == false) return;

	if ((cBankItemIndex < 0) || (cBankItemIndex >= hb::limits::MaxBankItems)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == 0) {
		// Bank item missing.
		hb::net::PacketResponseRetrieveItem pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_RETRIEVEITEM;
		pkt.header.msg_type = DEF_MSGTYPE_REJECT;
		pkt.bank_index = 0;
		pkt.item_index = 0;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	else {
		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->GetItemType() == ItemType::Consume) ||
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->GetItemType() == ItemType::Arrow) ) {
			//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
			iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		*/
		// v1.432
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

		if ((iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
		// Notify cannot carry more items.
			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				break;
			}
			return;
		}

		if ((m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->GetItemType() == ItemType::Consume) ||
			(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->GetItemType() == ItemType::Arrow)) {
			for(int i = 0; i < hb::limits::MaxItems; i++)
				if ((m_pClientList[iClientH]->m_pItemList[i] != 0) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_sIDnum)) {
					// v1.41 !!! 
					SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);

					delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
					m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = 0;

					for (j = 0; j <= hb::limits::MaxBankItems - 2; j++) {
						if ((m_pClientList[iClientH]->m_pItemInBankList[j + 1] != 0) && (m_pClientList[iClientH]->m_pItemInBankList[j] == 0)) {
							m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j + 1];

							m_pClientList[iClientH]->m_pItemInBankList[j + 1] = 0;
						}
					}

					// Send retrieve confirmation.
					hb::net::PacketResponseRetrieveItem pkt{};
					pkt.header.msg_id = MSGID_RESPONSE_RETRIEVEITEM;
					pkt.header.msg_type = DEF_MSGTYPE_CONFIRM;
					pkt.bank_index = cBankItemIndex;
					pkt.item_index = static_cast<int8_t>(i);

					iCalcTotalWeight(iClientH);
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));

					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, true, true);
						return;
					}
					return;
				}

			goto RRIH_NOQUANTITY;
		}
		else {
		RRIH_NOQUANTITY:
			for(int i = 0; i < hb::limits::MaxItems; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] == 0) {
					m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
					// v1.3 1-27 12:22
					m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
					m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

					m_pClientList[iClientH]->m_bIsItemEquipped[i] = false;

					m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = 0;

					for (j = 0; j <= hb::limits::MaxBankItems - 2; j++) {
						if ((m_pClientList[iClientH]->m_pItemInBankList[j + 1] != 0) && (m_pClientList[iClientH]->m_pItemInBankList[j] == 0)) {
							m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j + 1];

							m_pClientList[iClientH]->m_pItemInBankList[j + 1] = 0;
						}
					}

					// Send retrieve confirmation.
					hb::net::PacketResponseRetrieveItem pktConfirm{};
					pktConfirm.header.msg_id = MSGID_RESPONSE_RETRIEVEITEM;
					pktConfirm.header.msg_type = DEF_MSGTYPE_CONFIRM;
					pktConfirm.bank_index = cBankItemIndex;
					pktConfirm.item_index = static_cast<int8_t>(i);

					iCalcTotalWeight(iClientH);
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pktConfirm), sizeof(pktConfirm));
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						DeleteClient(iClientH, true, true);
						return;
					}
					return;
				}
			// No empty inventory slot.
			hb::net::PacketResponseRetrieveItem pktReject{};
			pktReject.header.msg_id = MSGID_RESPONSE_RETRIEVEITEM;
			pktReject.header.msg_type = DEF_MSGTYPE_REJECT;
			pktReject.bank_index = 0;
			pktReject.item_index = 0;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pktReject), sizeof(pktReject));
		}
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}
}

bool CGame::bSetItemToBankItem(int iClientH, short sItemIndex)
{
	int iRet;
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return false;
	if ((sItemIndex < 0) || (sItemIndex >= hb::limits::MaxItems)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return false;
	//wh remove
	//if (m_pClientList[iClientH]->m_bIsInsideWarehouse == false) return false;

	for(int i = 0; i < hb::limits::MaxBankItems; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {

			m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
			pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
			// !!!      NULL .
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;

			iCalcTotalWeight(iClientH);

			{
				hb::net::PacketNotifyItemToBank pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = DEF_NOTIFY_ITEMTOBANK;
				pkt.bank_index = static_cast<uint8_t>(i);
				pkt.is_new = 1;
				memcpy(pkt.name, pItem->m_cName, sizeof(pkt.name));
				pkt.count = pItem->m_dwCount;
				pkt.item_type = pItem->m_cItemType;
				pkt.equip_pos = pItem->m_cEquipPos;
				pkt.is_equipped = 0;
				pkt.level_limit = pItem->m_sLevelLimit;
				pkt.gender_limit = pItem->m_cGenderLimit;
				pkt.cur_lifespan = pItem->m_wCurLifeSpan;
				pkt.weight = pItem->m_wWeight;
				pkt.sprite = pItem->m_sSprite;
				pkt.sprite_frame = pItem->m_sSpriteFrame;
				pkt.item_color = pItem->m_cItemColor;
				pkt.item_effect_value2 = pItem->m_sItemEffectValue2;
				pkt.attribute = pItem->m_dwAttribute;
				pkt.spec_effect_value2 = static_cast<uint8_t>(pItem->m_sItemSpecEffectValue2);
				pkt.item_id = pItem->m_sIDnum;
				pkt.max_lifespan = pItem->m_wMaxLifeSpan;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// . v1.41  .
				// DeleteClient(iClientH, true, true);
				return true;
			}

			return true;
		}

	return false;
}
// 05/21/2004 - Hypnotoad - send player to jail
void CGame::ApplyPKpenalty(short sAttackerH, short sVictumH)
{
	uint32_t iV1, iV2;

	if (m_pClientList[sAttackerH] == 0) return;
	if (m_pClientList[sVictumH] == 0) return;
	if ((m_pClientList[sAttackerH]->m_bIsSafeAttackMode) && (m_pClientList[sAttackerH]->m_iPKCount == 0)) return;
	if ((strcmp(m_pClientList[sVictumH]->m_cLocation, "aresden") != 0) && (strcmp(m_pClientList[sVictumH]->m_cLocation, "elvine") != 0) && (strcmp(m_pClientList[sVictumH]->m_cLocation, "elvhunter") != 0) && (strcmp(m_pClientList[sVictumH]->m_cLocation, "arehunter") != 0)) {
		return;
	}

	// PK Count
	m_pClientList[sAttackerH]->m_iPKCount++;

	_bPKLog(DEF_PKLOG_BYPK, sAttackerH, sVictumH, 0);

	iV1 = iDice((m_pClientList[sVictumH]->m_iLevel / 2) + 1, 50);
	iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel / 2) + 1, 50);

	m_pClientList[sAttackerH]->m_iExp -= iV1;
	m_pClientList[sAttackerH]->m_iExp -= iV2;
	if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;

	SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_PKPENALTY, 0, 0, 0, 0);

	SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

	// std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) PK-penalty: (%s)  (%d) (%d) ", m_pClientList[sAttackerH]->m_cCharName, iV1+iV2, m_pClientList[sAttackerH]->m_iExp);
	//PutLogFileList(G_cTxt);

	m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;

	m_pClientList[sAttackerH]->m_iRating -= 10;
	if (m_pClientList[sAttackerH]->m_iRating > 10000)  m_pClientList[sAttackerH]->m_iRating = 10000;
	if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;


	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "aresden") == 0) {
		if ((strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk11") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk12") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk21") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk22") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "aresden") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone2") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "areuni") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arefarm") == 0)) {

			// PK .   5
			std::memset(m_pClientList[sAttackerH]->m_cLockedMapName, 0, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 60 * 3;
			RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
			return;
		}
	}

	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "elvine") == 0) {
		if ((strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk11") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk12") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk21") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk22") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvine") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone1") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvuni") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {

			// PK .   5
			std::memset(m_pClientList[sAttackerH]->m_cLockedMapName, 0, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 60 * 3;
			RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
			return;
		}
	}
}


// 05/17/2004 - Hypnotoad - register pk log
void CGame::PK_KillRewardHandler(short sAttackerH, short sVictumH)
{
	if (m_pClientList[sAttackerH] == 0) return;
	if (m_pClientList[sVictumH] == 0)   return;

	_bPKLog(DEF_PKLOG_BYPLAYER, sAttackerH, sVictumH, 0);

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {
		// PK   PK   .

	}
	else {
		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;


		if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
			m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0)
			m_pClientList[sAttackerH]->m_iRewardGold = 0;

		SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, 0, m_pClientList[sVictumH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
	// enemy-kill-mode = 1 | 0
	// if m_bEnemyKillMode is true than death match mode

	// DEATHMATCH MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and gets an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and gets an EK

	// CLASSIC MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and doesnt get an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and doesnt get an EK

	int iEK_Level;
	uint32_t iRewardExp;

	// if the attacker doesnt exist no result
	if (m_pClientList[iAttackerH] == 0) return;
	// if the target doesnt exist no result
	if (m_pClientList[iClientH] == 0)   return;

	// Log the EK (killed by enemy)
	_bPKLog(DEF_PKLOG_BYENERMY, iAttackerH, iClientH, 0);

	// set EK level to 30
	iEK_Level = 30;
	// if attacker's level is greater than 80, set ek level to 80
	if (m_pClientList[iAttackerH]->m_iLevel >= 80) iEK_Level = 80;
	// check if attacker level is less than or equal to max level
	if (m_pClientList[iAttackerH]->m_iLevel >= m_iMaxLevel) {
		// if the
		if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
				&& (m_bEnemyKillMode == false)) {
				m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
			}

			if (m_bEnemyKillMode) {
				m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
			}
		}
		m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
		if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
			m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
			m_pClientList[iAttackerH]->m_iRewardGold = 0;

		SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, 0, 0, 0);
		return;
	}

	if (m_pClientList[iAttackerH]->m_iPKCount != 0) {
	}
	else {
		if (m_pClientList[iClientH]->m_iGuildRank == -1) {
			iRewardExp = (iDice(3, (3 * iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp)) / 3;

			if (m_bIsCrusadeMode) {
				// (1/3)*3    6
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp / 3) * 4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp / 3)) * 12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > m_iMaxWarContribution)
					m_pClientList[iAttackerH]->m_iWarContribution = m_iMaxWarContribution;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > m_iMaxConstructionPoints)
					m_pClientList[iAttackerH]->m_iConstructionPoint = m_iMaxConstructionPoints;

				//testcode
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp / 3)) * 6);
				PutLogList(G_cTxt);

				SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, 0, 0);

				// 80   Enemy Kill count .
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
					if (m_bEnemyKillMode) {
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// 80   Enemy Kill count .
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
						&& (m_bEnemyKillMode == false)) {
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}

					if (m_bEnemyKillMode) {
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		else {
			iRewardExp = (iDice(3, (3 * iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp)) / 3;

			if (m_bIsCrusadeMode) {
				// 1/3    2
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp / 3) * 4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp / 3)) * 12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > m_iMaxWarContribution)
					m_pClientList[iAttackerH]->m_iWarContribution = m_iMaxWarContribution;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > m_iMaxConstructionPoints)
					m_pClientList[iAttackerH]->m_iConstructionPoint = m_iMaxConstructionPoints;

				//testcode
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp / 3)) * 6);
				PutLogList(G_cTxt);

				SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, 0, 0);

				// 80   Enemy Kill count .
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
						&& (m_bEnemyKillMode == false)) {
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}

					if (m_bEnemyKillMode) {
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Enemy Kill count .
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0)
						&& (m_bEnemyKillMode == false)) {
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}

					if (m_bEnemyKillMode) {
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD)
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0)
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}

		SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, 0, 0, 0);

		if (bCheckLimitedUser(iAttackerH) == false) {
			SendNotifyMsg(0, iAttackerH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
		}
		bCheckLevelUp(iAttackerH);

		m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;
	}
}

// 05/22/2004 - Hypnotoad - register in pk log
void CGame::ApplyCombatKilledPenalty(int iClientH, int cPenaltyLevel, bool bIsSAattacked)
{
	uint32_t iExp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	// Crusade
	if (m_bIsCrusadeMode) {
		// PKcount
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PKPENALTY, 0, 0, 0, 0);
			// v2.15 
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL, 0, iClientH, 0);

		}
		return;
	}
	else {
		// PKcount
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PKPENALTY, 0, 0, 0, 0);
			// v2.15
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL, 0, iClientH, 0);
		}

		iExp = iDice(1, (5 * cPenaltyLevel * m_pClientList[iClientH]->m_iLevel));

		if (m_pClientList[iClientH]->m_bIsNeutral) iExp = iExp / 3;

		// if (m_pClientList[iClientH]->m_iLevel == DEF_PLAYERMAXLEVEL) iExp = 0;

		m_pClientList[iClientH]->m_iExp -= iExp;
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);

		if (m_pClientList[iClientH]->m_bIsNeutral != true) {
			if (m_pClientList[iClientH]->m_iLevel < 80) {
				// v2.03 60 -> 80
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			}
			else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
		}
	}
}

// 05/29/2004 - Hypnotoad - Limits some items from not dropping
void CGame::_PenaltyItemDrop(int iClientH, int iTotal, bool bIsSAattacked)
{
	int j, iRemainItem;
	char cItemIndexList[hb::limits::MaxItems], cItemIndex;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) && (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != 0)) {
		// Testcode
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->GetItemEffectType() == ItemEffectType::AlterItemDrop) {
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0) {
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CURLIFESPAN, m_pClientList[iClientH]->m_iAlterItemDropIndex, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan, 0, 0);
			}
			DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);

			m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
		}
		else {
			// v2.04 testcode
			PutLogFileList("Alter Drop Item Index Error1");
			for(int i = 0; i < hb::limits::MaxItems; i++)
				if ((m_pClientList[iClientH]->m_pItemList[i] != 0) && (m_pClientList[iClientH]->m_pItemList[i]->GetItemEffectType() == ItemEffectType::AlterItemDrop)) {
					m_pClientList[iClientH]->m_iAlterItemDropIndex = i;
					if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0) {
						m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_CURLIFESPAN, m_pClientList[iClientH]->m_iAlterItemDropIndex, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan, 0, 0);
					}
					DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);
					m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
					return;
				}

			goto PID_DROP;
		}
		return;
	}

PID_DROP:

	for(int i = 1; i <= iTotal; i++) {
		iRemainItem = 0;
		std::memset(cItemIndexList, 0, sizeof(cItemIndexList));

		for (j = 0; j < hb::limits::MaxItems; j++)
			if (m_pClientList[iClientH]->m_pItemList[j] != 0) {
				cItemIndexList[iRemainItem] = j;
				iRemainItem++;
			}

		if (iRemainItem == 0) return;
		cItemIndex = cItemIndexList[iDice(1, iRemainItem) - 1];


		if ((m_pClientList[iClientH]->m_pItemList[cItemIndex]->GetTouchEffectType() != TouchEffectType::None) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
		}

		else if (
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum >= 400) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum != 402) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum <= 428)) {
		}

		else if (((m_pClientList[iClientH]->m_pItemList[cItemIndex]->GetItemEffectType() == ItemEffectType::AttackSpecAbility) ||
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->GetItemEffectType() == ItemEffectType::DefenseSpecAbility)) &&
			(bIsSAattacked == false)) {
		}

		else if ((m_pClientList[iClientH]->m_bIsLuckyEffect) && (iDice(1, 10) == 5)) {
			// 10%    .
		}

		else DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName);
	}
}

void CGame::GetRewardMoneyHandler(int iClientH)
{
	int iRet, iEraseReq, iWeightLeft;
	uint32_t iRewardGoldLeft;
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;


	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);

	if (iWeightLeft <= 0) return;
	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new CItem;
	_bInitItemAttr(pItem, hb::item::ItemId::Gold);
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;

	// (iWeightLeft / pItem->m_wWeight)     Gold.   .
	uint32_t maxGold = static_cast<uint32_t>(iWeightLeft / iGetItemWeight(pItem, 1));
	if (maxGold >= m_pClientList[iClientH]->m_iRewardGold) {
		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}
	else {
		// (iWeightLeft / pItem->m_wWeight) .
		pItem->m_dwCount = maxGold;
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - maxGold;
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {

		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;

		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
			DeleteClient(iClientH, true, true);
			return;
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REWARDGOLD, 0, 0, 0, 0);
	}
	else {

	}
}


int CGame::_iCalcMaxLoad(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return 0;

	return ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 500 + m_pClientList[iClientH]->m_iLevel * 500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, uint32_t dwLastTime, int iV1)
{
	
	short sPreType;
	uint32_t dwTime, dwRegisterTime;

	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != 0) return 0;

	switch (sType) {
	case DEF_DYNAMICOBJECT_FIRE3:
	case DEF_DYNAMICOBJECT_FIRE:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == false)
			return 0;
		if (dwLastTime != 0) {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			}

			if (dwLastTime == 0) dwLastTime = 1000;
		}
		break;

	case DEF_DYNAMICOBJECT_FISHOBJECT:
	case DEF_DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == false)
			return 0;
		break;

	case DEF_DYNAMICOBJECT_ARESDENFLAG1:
	case DEF_DYNAMICOBJECT_ELVINEFLAG1:
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == false)
			return 0;
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, false);
		break;

	}

	for(int i = 1; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] == 0) {
			dwTime = GameClock::GetTimeMS();

			if (dwLastTime != 0)
				dwLastTime += (iDice(1, 4) * 1000);

			m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
			m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, 0, (short)0);

			return i;
		}
	return 0;
}

void CGame::CheckDynamicObjectList()
{
	
	uint32_t dwTime = GameClock::GetTimeMS(), dwRegisterTime;
	short sType;

	for(int i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) {
		if ((m_pDynamicObjectList[i] != 0) && (m_pDynamicObjectList[i]->m_dwLastTime != 0)) {

			switch (m_pDynamicObjectList[i]->m_sType) {
			case DEF_DYNAMICOBJECT_FIRE3:
			case DEF_DYNAMICOBJECT_FIRE:
				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
				case 0: break;
				case 1:
				case 2:
				case 3:
					// ( /10)*    .
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime -
						(m_pDynamicObjectList[i]->m_dwLastTime / 10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
					break;
				}
				break;
			}
		}
	}

	// .  NULL    .
	for(int i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) {
		if ((m_pDynamicObjectList[i] != 0) && (m_pDynamicObjectList[i]->m_dwLastTime != 0) &&
			((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime)) {

			m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime);

			if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
				SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, 0, (short)0);
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			}

			switch (sType) {
			case DEF_DYNAMICOBJECT_FISHOBJECT:
			case DEF_DYNAMICOBJECT_FISH:
				bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2);
				break;
			}

			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = 0;
		}
	}
}

void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
	short sSkillIndex;
	int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;

	iSSNpoint = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] + 1];

	if ((m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint)) {

		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++;

		switch (sSkillIndex) {
		case 0:  // Mining
		case 5:  // Hand-Attack
		case 13: // Manufacturing
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3: // Magic-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:  // Magic
		case 18: // Crafting
		case 21: // Staff-Attack
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:  // Fishing
		case 6:  // Archery
		case 7:  // Short-Sword
		case 8:  // Long-Sword
		case 9:  // Fencing 
		case 10: // Axe-Attack
		case 11: // Shield        	
		case 14: // Hammer 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:	 // Farming
		case 12: // Alchemy
		case 15:
		case 19: // Pretend-Corpse
		case 20: // Enchanting
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // Poison-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}

		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] != -1) {
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)] != -1) {
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// Mace    .  1 .
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}

		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill  600     1 .
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// Skill    .
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], 0, 0);
		}
	}
}

void CGame::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue)
{
	int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue * 100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;

	iSSNpoint = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] + 1];

	// SkillSSN   Skill .
	if ((m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint)) {

		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++;
		// Skill .
		switch (sSkillIndex) {
		case 0:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iAngelicStr) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			// Level*2 .
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 18: // Crafting
		case 21:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iAngelicMag) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iAngelicDex) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:
		case 12:
		case 14:
		case 15:
		case 19:
		case 20: // Enchanting
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > ((m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iAngelicInt) * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}

		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] != -1) {
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)] != -1) {
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// Mace    .  1 .
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}

		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKill  700     1 .
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);

			// Skill    .
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], 0, 0);
		}
	}
}


void CGame::RequestFullObjectData(int iClientH, char* pData)
{
	uint16_t wObjectID;
	int iRet;
	uint32_t dwTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	wObjectID = header->msg_type;
	dwTime = GameClock::GetTimeMS();

	if ((wObjectID != m_pClientList[iClientH]->m_dwLastFullObjectId) ||
		(dwTime - m_pClientList[iClientH]->m_dwLastFullObjectTime) > 1000) {
		m_pClientList[iClientH]->m_dwLastFullObjectId = wObjectID;
		m_pClientList[iClientH]->m_dwLastFullObjectTime = dwTime;
	}

	if (wObjectID < 10000) {
		if ((wObjectID == 0) || (wObjectID >= DEF_MAXCLIENTS)) return;
		if (m_pClientList[wObjectID] == 0) return;

		hb::net::PacketEventMotionPlayer pkt{};
		pkt.header.msg_id = MSGID_EVENT_MOTION;
		pkt.header.msg_type = DEF_OBJECTSTOP;
		pkt.object_id = wObjectID;
		pkt.x = m_pClientList[wObjectID]->m_sX;
		pkt.y = m_pClientList[wObjectID]->m_sY;
		pkt.type = m_pClientList[wObjectID]->m_sType;
		pkt.dir = static_cast<uint8_t>(m_pClientList[wObjectID]->m_cDir);
		memcpy(pkt.name, m_pClientList[wObjectID]->m_cCharName, sizeof(pkt.name));
		pkt.appearance = m_pClientList[wObjectID]->m_appearance;

		{
			auto pktStatus = m_pClientList[wObjectID]->m_status;
			pktStatus.bPK = (m_pClientList[wObjectID]->m_iPKCount != 0) ? 1 : 0;
			pktStatus.bCitizen = (m_pClientList[wObjectID]->m_cSide != 0) ? 1 : 0;
			pktStatus.bAresden = (m_pClientList[wObjectID]->m_cSide == 1) ? 1 : 0;
			pktStatus.bHunter = m_pClientList[wObjectID]->m_bIsPlayerCivil ? 1 : 0;
			pktStatus.iRelationship = GetPlayerRelationship(wObjectID, iClientH);
			pkt.status = pktStatus;
		}
		pkt.loc = m_pClientList[wObjectID]->m_bIsKilled ? 1 : 0;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	else {
		if (((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= DEF_MAXNPCS)) return;
		if (m_pNpcList[wObjectID - 10000] == 0) return;

		const uint16_t objectId = wObjectID;
		wObjectID -= 10000;

		hb::net::PacketEventMotionNpc pkt{};
		pkt.header.msg_id = MSGID_EVENT_MOTION;
		pkt.header.msg_type = DEF_OBJECTSTOP;
		pkt.object_id = objectId;
		pkt.x = m_pNpcList[wObjectID]->m_sX;
		pkt.y = m_pNpcList[wObjectID]->m_sY;
		pkt.type = m_pNpcList[wObjectID]->m_sType;
		pkt.dir = static_cast<uint8_t>(m_pNpcList[wObjectID]->m_cDir);
		memcpy(pkt.name, m_pNpcList[wObjectID]->m_cName, sizeof(pkt.name));
		pkt.appearance = m_pNpcList[wObjectID]->m_appearance;

		pkt.status = m_pNpcList[wObjectID]->m_status;
		pkt.loc = m_pNpcList[wObjectID]->m_bIsKilled ? 1 : 0;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return;
	}
}


int CGame::_iGetArrowItemIndex(int iClientH)
{
	

	if (m_pClientList[iClientH] == 0) return -1;

	for(int i = 0; i < hb::limits::MaxItems; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {

			// Arrow  1     .
			if ((m_pClientList[iClientH]->m_pItemList[i]->GetItemType() == ItemType::Arrow) &&
				(m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0))
				return i;
		}

	return -1;
}

void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, bool bIsUseItemResult)
{

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((sItemIndex < 0) || (sItemIndex >= hb::limits::MaxItems)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;

	_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

	ReleaseItemHandler(iClientH, sItemIndex, true);

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, 0, 0);

	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = 0;

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = false;

	// !!! BUG POINT
	// . ArrowIndex     .
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

	iCalcTotalWeight(iClientH);
}


void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID)
{
	int iTemp, iMax, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
	uint32_t dwTime;
	short sTemp, sTmpType;
	char cSlateType[20];

	dwTime = GameClock::GetTimeMS();
	std::memset(cSlateType, 0, sizeof(cSlateType));

	//testcode
	//std::snprintf(G_cTxt, sizeof(G_cTxt), "%d", sDestItemID);
	//PutLogList(G_cTxt);

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((sItemIndex < 0) || (sItemIndex >= hb::limits::MaxItems)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::UseDeplete) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::UsePerm) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Arrow) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Eat) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::UseSkill) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::UseDepleteDest)) {
	}
	else return;

	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::UseDeplete) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Eat)) {

		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType()) {
		case ItemEffectType::Warm:

			if (m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Ice] == 1) {
				//	SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);

				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, hb::magic::Ice);

				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (1 * 1000),
					iClientH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);


				//				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::Ice, 0, 0, 0);
			}

			m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
			break;

		case ItemEffectType::Lottery:
			// EV1(:  100) EV2( ) EV3( )
			iTemp = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1);
			if (iTemp == iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1)) {

			}
			else {

			}
			break;

		case ItemEffectType::Slates:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
				// Full Ancient Slate ??
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 867) {
					// Slates dont work on Heldenian Map
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
					case 2: // Bezerk slate
						m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Berserk] = true;
						SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, true);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Berserk, dwTime + (1000 * 600),
							iClientH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Berserk, 1, 0, 0);
						strcpy(cSlateType, "Berserk");
						break;

					case 1: // Invincible slate
						if (strlen(cSlateType) == 0) {
							strcpy(cSlateType, "Invincible");
						}
					case 3: // Mana slate
						if (strlen(cSlateType) == 0) {
							strcpy(cSlateType, "Mana");
						}
					case 4: // Exp slate
						if (strlen(cSlateType) == 0) {
							strcpy(cSlateType, "Exp");
						}
						SetSlateFlag(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, true);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_ANCIENT_TABLET, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2,
							dwTime + (1000 * 600), iClientH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
						switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
						case 1:
							iEffectResult = 4;
							break;
						case 3:
							iEffectResult = 5;
							break;
						case 4:
							iEffectResult = 6;
							break;
						}
					}
					//if (strlen(cSlateType) > 0)
					//	_bItemLog(DEF_ITEMLOG_USE, iClientH, strlen(cSlateType), m_pClientList[iClientH]->m_pItemList[sItemIndex]);
				}
			}
			break;
		case ItemEffectType::HP:
			iMax = iGetMaxHP(iClientH);
			if (m_pClientList[iClientH]->m_iHP < iMax) {

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iHP += (iDice(iV1, iV2) + iV3);
				if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
				if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;

				iEffectResult = 1;
			}
			break;

		case ItemEffectType::MP:
			iMax = iGetMaxMP(iClientH);

			if (m_pClientList[iClientH]->m_iMP < iMax) {

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else
				{
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iMP += (iDice(iV1, iV2) + iV3);
				if (m_pClientList[iClientH]->m_iMP > iMax)
					m_pClientList[iClientH]->m_iMP = iMax;

				iEffectResult = 2;
			}
			break;
		case ItemEffectType::CritKomm:
			//CritInc(iClientH);
			break;
		case ItemEffectType::SP:
			iMax = iGetMaxSP(iClientH);

			if (m_pClientList[iClientH]->m_iSP < iMax) {

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iSP += (iDice(iV1, iV2) + iV3);
				if (m_pClientList[iClientH]->m_iSP > iMax)
					m_pClientList[iClientH]->m_iSP = iMax;

				iEffectResult = 3;
			}

			if (m_pClientList[iClientH]->m_bIsPoisoned) {
				m_pClientList[iClientH]->m_bIsPoisoned = false;
				SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, false); // removes poison aura when using a revitalizing potion
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::Poison, 0, 0, 0);
			}
			break;

		case ItemEffectType::HPStock:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;

			m_pClientList[iClientH]->m_iHPstock += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
			if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

			m_pClientList[iClientH]->m_iHungerStatus += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
			if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
			break;

		case ItemEffectType::StudySkill:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
			// iV1  Skill . iV2  , iSEV1    ()
			if (iSEV1 == 0) {
				TrainSkillResponse(true, iClientH, iV1, iV2);
			}
			else {
				TrainSkillResponse(true, iClientH, iV1, iSEV1);
			}
			break;

		case ItemEffectType::StudyMagic:
			// iV1   .
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pMagicConfigList[iV1] != 0)
				RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, false);
			break;

			/*case ItemEffectType::Lottery:
				iLottery = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->
				break;*/

				// New 15/05/2004 Changed
		case ItemEffectType::Magic:
			if (m_pClientList[iClientH]->m_status.bInvisibility) {
				SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);

				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, hb::magic::Invisibility);
				m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Invisibility] = 0;
			}

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// Recall    .
				// testcode
				RequestTeleportHandler(iClientH, "1   ");
				break;

			case 2:
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, true);
				break;

			case 3:
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == false)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, true);
				break;

			case 4:
				// fixed location teleportation:
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
				case 1:
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
						//v1.42
						ItemDepleteHandler(iClientH, sItemIndex, true);
						RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
					}
					break;
				case 2: //lotery
					ItemDepleteHandler(iClientH, sItemIndex, true);
					LoteryHandler(iClientH);
					break;

				case 11:
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:
					SYSTEMTIME SysTime;

					GetLocalTime(&SysTime);
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour)) {
					}
					else {
						char cDestMapName[11];
						std::memset(cDestMapName, 0, sizeof(cDestMapName));
						std::snprintf(cDestMapName, sizeof(cDestMapName), "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
						if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
							//v1.42
							ItemDepleteHandler(iClientH, sItemIndex, true);
							RequestTeleportHandler(iClientH, "2   ", cDestMapName, -1, -1);
						}
					}
					break;
				}
				break;

			case 5:
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, true,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				break;
			}
			break;

		case ItemEffectType::FirmStamina:
			m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar > 20 * 30) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 20 * 30;
			break;

		case ItemEffectType::ChangeAttr:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				m_pClientList[iClientH]->m_cHairColor++;
				if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

				m_pClientList[iClientH]->m_appearance.iHairStyle = m_pClientList[iClientH]->m_cHairStyle;
				m_pClientList[iClientH]->m_appearance.iHairColor = m_pClientList[iClientH]->m_cHairColor;
				m_pClientList[iClientH]->m_appearance.iUnderwearType = m_pClientList[iClientH]->m_cUnderwear;
				break;

			case 2:
				m_pClientList[iClientH]->m_cHairStyle++;
				if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

				m_pClientList[iClientH]->m_appearance.iHairStyle = m_pClientList[iClientH]->m_cHairStyle;
				m_pClientList[iClientH]->m_appearance.iHairColor = m_pClientList[iClientH]->m_cHairColor;
				m_pClientList[iClientH]->m_appearance.iUnderwearType = m_pClientList[iClientH]->m_cUnderwear;
				break;

			case 3:
				// Appearance , .
				m_pClientList[iClientH]->m_cSkin++;
				if (m_pClientList[iClientH]->m_cSkin > 3)
					m_pClientList[iClientH]->m_cSkin = 1;

				if (m_pClientList[iClientH]->m_cSex == 1)      sTemp = 1;
				else if (m_pClientList[iClientH]->m_cSex == 2) sTemp = 4;

				switch (m_pClientList[iClientH]->m_cSkin) {
				case 2:	sTemp += 1; break;
				case 3:	sTemp += 2; break;
				}
				m_pClientList[iClientH]->m_sType = sTemp;
				break;

			case 4:
				sTemp = m_pClientList[iClientH]->m_appearance.iHelmType;
				if (sTemp == 0) {
					// sTemp 0  , ,     .    .
					if (m_pClientList[iClientH]->m_cSex == 1)
						m_pClientList[iClientH]->m_cSex = 2;
					else m_pClientList[iClientH]->m_cSex = 1;

					// Appearance , .
					if (m_pClientList[iClientH]->m_cSex == 1) {
						sTmpType = 1;
					}
					else if (m_pClientList[iClientH]->m_cSex == 2) {
						sTmpType = 4;
					}

					switch (m_pClientList[iClientH]->m_cSkin) {
					case 1:
						break;
					case 2:
						sTmpType += 1;
						break;
					case 3:
						sTmpType += 2;
						break;
					}

					m_pClientList[iClientH]->m_sType = sTmpType;
					m_pClientList[iClientH]->m_appearance.iHairStyle = m_pClientList[iClientH]->m_cHairStyle;
					m_pClientList[iClientH]->m_appearance.iHairColor = m_pClientList[iClientH]->m_cHairColor;
					m_pClientList[iClientH]->m_appearance.iUnderwearType = m_pClientList[iClientH]->m_cUnderwear;
				}
				break;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
			break;
		}
		// *** Request Teleport Handler           .
		ItemDepleteHandler(iClientH, sItemIndex, true);

		switch (iEffectResult) {
		case 1:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);
			break;
		case 2:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_MP, 0, 0, 0, 0);
			break;
		case 3:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			break;
		case 4: // Invincible
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_INVINCIBLE, 0, 0, 0, 0);
			break;
		case 5: // Mana
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_MANA, 0, 0, 0, 0);
			break;
		case 6: // EXP
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_EXP, 0, 0, 0, 0);
			break;
		default:
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::UseDepleteDest) {
		// dX, dY       .
		if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID))
			ItemDepleteHandler(iClientH, sItemIndex, true);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::Arrow) {
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::UsePerm) {
		// .     . (ex: )
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType()) {
		case ItemEffectType::ShowLocation:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			switch (iV1) {
			case 1:
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 1, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 2, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 3, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 4, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 5, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 6, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 7, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 8, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "arefarm") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 9, 0, 0);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvfarm") == 0)
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 10, 0, 0);
				else SendNotifyMsg(0, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 0, 0, 0);
				break;
			}
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemType() == ItemType::UseSkill) {

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) ||
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
			(m_pClientList[iClientH]->m_bSkillUsingStatus[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill])) {
			return;
		}
		else {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0) {
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CURLIFESPAN, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan, 0, 0);
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMLIFESPANEND, ToInt(EquipPos::None), sItemIndex, 0, 0);
				}
				else {
					// ID . v1.12
					int iSkillUsingTimeID = (int)GameClock::GetTimeMS();

					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill,
						dwTime + m_pSkillConfigList[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill]->m_sValue2 * 1000,
						iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY,
						m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill], iSkillUsingTimeID, 0);

					m_pClientList[iClientH]->m_bSkillUsingStatus[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill] = true;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill] = iSkillUsingTimeID; //v1.12
				}
			}
		}
	}
}

void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, bool bExp, int iAttr)
{
	int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack, iRepDamage;
	char cAttackerSide, cDamageMoveDir;
	uint32_t dwTime, iExp;
	double dTmp1, dTmp2, dTmp3;
	short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY, sItemIndex;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == 0) return;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) &&
		(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1) && (m_bHeldenianInitiated)) return;

	dwTime = GameClock::GetTimeMS();
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;
		if ((m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::LeftHand)] == -1) || (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] == -1)) {
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 732 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 738) {
					iDamage *= (int)1.2;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
					if (m_pClientList[sAttackerH]->m_iRating > 0) {
						iRepDamage = m_pClientList[sAttackerH]->m_iRating / 100;
						if (iRepDamage < 5) iRepDamage = 5;
						if (iRepDamage > 15) iRepDamage = 15;
						iDamage += iRepDamage;
					}
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != 0) {
							if (m_pClientList[sTargetH]->m_iRating < 0) {
								iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 10);
								if (iRepDamage > 10) iRepDamage = 10;
								iDamage += iRepDamage;
							}
						}
					}
				}
			}
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::Neck)];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != 0) {
							iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 20);
							if (iRepDamage > 5) iRepDamage = 5;
							iDamage += iRepDamage;
						}
					}
				}
			}
		}

		if ((m_bIsCrusadeMode == false) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

		dTmp1 = (double)iDamage;
		dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_iAngelicMag);
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 + 0.5f);

		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
		if (iDamage <= 0) iDamage = 0;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone)
			iDamage += iDamage / 3;

		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage / 3;
		}

		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
			if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
				iDamage += (iDamage * 7) / 10;
			}
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
				iDamage += iDamage / 2;
			}
			else
				iDamage += iDamage / 3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == false) return;
		if (m_pClientList[sTargetH]->m_bIsKilled) return;

		// GM mode damage immunity
		if (m_pClientList[sTargetH]->m_bIsGMMode)
		{
			uint32_t dwNow = GameClock::GetTimeMS();
			if (dwNow - m_pClientList[sTargetH]->m_dwLastGMImmuneNotifyTime > 2000)
			{
				m_pClientList[sTargetH]->m_dwLastGMImmuneNotifyTime = dwNow;
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, DEF_DAMAGE_IMMUNE, 0, 0);
			}
			return;
		}

		if (m_pClientList[sTargetH]->m_status.bSlateInvincible) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == false) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil)) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation)) return;

		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > (uint32_t)m_iLagProtectionInterval) return;
		if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == false)) return;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
		if ((m_pClientList[sTargetH]->m_iPartyID != 0) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);

		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < hb::limits::MaxItems)) {

			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 + 0.5f);
				break;

			case 337:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 + 0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;

			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, true);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iIndex, m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan, 0, 0);
			}
		}

		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2 / 100.0f) * dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect) &&
			(iDice(1, 10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect] == 2)
			iDamage = iDamage / 2;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		// Interrupt spell casting on damage
		if (iDamage > 0) {
			m_pClientList[sTargetH]->m_dwLastDamageTakenTime = GameClock::GetTimeMS();
			if (m_pClientList[sTargetH]->m_bMagicPauseTime) {
				m_pClientList[sTargetH]->m_bMagicPauseTime = false;
				m_pClientList[sTargetH]->m_iSpellCount = -1;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SPELLINTERRUPTED, 0, 0, 0, 0);
			}
		}
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);
		}
		else {
			if (iDamage > 0) {
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1 / 100.0f) * dTmp2 + 1.0f;

					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (iDice(1, 100) <= static_cast<uint32_t>(m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
					}
				}

				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}

				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) {
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::HoldObject, m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject], 0, 0);
					m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, hb::magic::HoldObject);
				}
			}
		}

		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;

		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
			return;

		case 4:
			if (sTgtX == sAtkX) {
				if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}
			else if (sTgtX > sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}
			else if (sTgtX < sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;
			}

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
				cDamageMoveDir = static_cast<char>(iDice(1, 8));
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) return;
			}

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX = dX;
			m_pNpcList[sTargetH]->m_sY = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
				cDamageMoveDir = static_cast<char>(iDice(1, 8));
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) return;
			}

			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX = dX;
			m_pNpcList[sTargetH]->m_sY = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType)) {
				// Use EntityManager for NPC deletion
				if (m_pEntityManager != NULL)
					m_pEntityManager->DeleteEntity(sTargetH);
			}
			return;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		switch (m_pNpcList[sTargetH]->m_sType) {
		case 67: // McGaffin
		case 68: // Perry
		case 69: // Devlin
			return;
		}

		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage) / 100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect] == 2)
			iDamage = iDamage / 2;

		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// Use EntityManager for NPC death handling
			if (m_pEntityManager != NULL)
				m_pEntityManager->OnEntityKilled(sTargetH, sAttackerH, cAttackerType, iDamage);
		}
		else {
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}

			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

			if ((iDice(1, 3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				if ((cAttackerType == DEF_OWNERTYPE_NPC) &&
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;

				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, hb::magic::HoldObject);
				}

				if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) &&
					(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > static_cast<uint32_t>(iDamage)) {
						iExp = iDamage;
						if ((m_bIsCrusadeMode) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;
							iExp += (uint32_t)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}

						if (bExp)
							GetExp(sAttackerH, iExp, true);
						else GetExp(sAttackerH, (iExp / 2), true);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;
							iExp += (uint32_t)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}

						if (bExp)
							GetExp(sAttackerH, iExp, true);
						else GetExp(sAttackerH, (iExp / 2), true);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}


void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, bool bExp, int iAttr)
{
	int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
	uint32_t dwTime, wWeaponType;
	char cAttackerSide, cDamageMoveDir;
	double dTmp1, dTmp2, dTmp3;
	int iPartyID, iMoveDamage;
	short sTgtX, sTgtY;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == 0) return;

	dwTime = GameClock::GetTimeMS();
	sTgtX = 0;
	sTgtY = 0;

	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		dTmp1 = (double)iDamage;
		dTmp2 = (double)(m_pClientList[sAttackerH]->m_iMag + m_pClientList[sAttackerH]->m_iAngelicMag);

		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 + 0.5f);
		if (iDamage <= 0) iDamage = 0;

		// v1.432 2001 4 7 13 7
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone)
			iDamage += iDamage / 3;

		// Crusade :     1.33
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1))
		{
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage * 7) / 10;
			}
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage / 2;
			}
			else iDamage += iDamage / 3;
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) {
			iDamage += 4;
		}

		wWeaponType = m_pClientList[sAttackerH]->m_appearance.iWeaponType;
		if (wWeaponType == 34) {
			iDamage += iDamage / 3;
		}

		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage / 3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;

		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == false) return;
		if (m_pClientList[sTargetH]->m_bIsKilled) return;

		// GM mode damage immunity
		if (m_pClientList[sTargetH]->m_bIsGMMode)
		{
			uint32_t dwNow = GameClock::GetTimeMS();
			if (dwNow - m_pClientList[sTargetH]->m_dwLastGMImmuneNotifyTime > 2000)
			{
				m_pClientList[sTargetH]->m_dwLastGMImmuneNotifyTime = dwNow;
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, DEF_DAMAGE_IMMUNE, 0, 0);
			}
			return;
		}

		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > (uint32_t)m_iLagProtectionInterval) return;
		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == false)) return;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		if ((m_bIsCrusadeMode == false) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsPlayerCivil)) return;
		if ((m_bIsCrusadeMode == false) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil)) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil)) return;

		// 01-12-17
		if ((m_pClientList[sTargetH]->m_iPartyID != 0) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {

			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);

		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2 / 100.0f) * dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < hb::limits::MaxItems)) {

			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 + 0.5f);
				break;

			case 337:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 + 0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;

			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, true);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iIndex, m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan, 0, 0);
			}
		}

		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2 / 100.0f) * dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect] == 2)
			iDamage = iDamage / 2;

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect) &&
			(iDice(1, 10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		// Interrupt spell casting on damage
		if (iDamage > 0) {
			m_pClientList[sTargetH]->m_dwLastDamageTakenTime = GameClock::GetTimeMS();
			if (m_pClientList[sTargetH]->m_bMagicPauseTime) {
				m_pClientList[sTargetH]->m_bMagicPauseTime = false;
				m_pClientList[sTargetH]->m_iSpellCount = -1;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SPELLINTERRUPTED, 0, 0, 0, 0);
			}
		}
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);
		}
		else {
			if (iDamage > 0) {
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1 / 100.0f) * dTmp2 + 1.0f;

					iTemp = iGetMaxMP(sTargetH);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (iDice(1, 100) <= static_cast<uint32_t>(m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
					}
				}

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone))
					iMoveDamage = 80;
				else iMoveDamage = 50;

				if (iDamage >= iMoveDamage) {
			///		char cDamageMoveDir;
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;

					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;
					}

					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, 0, 0);
				}
				else {
				EDSD_SKIPDAMAGEMOVE:
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
				}

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != true) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}

				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) {
					// Hold-Person    .     .
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::HoldObject, m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject], 0, 0);

					m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, hb::magic::HoldObject);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
			return;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		switch (m_pNpcList[sTargetH]->m_sType) {
		case 67: // McGaffin
		case 68: // Perry
		case 69: // Devlin
			iDamage = 0;
			break;
		}

		// (AbsDamage 0 )    .
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage) / 100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect] == 2)
			iDamage = iDamage / 2;

		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC .
			m_pEntityManager->OnEntityKilled(sTargetH, sAttackerH, cAttackerType, iDamage);
		}
		else {

			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}

			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

			if ((iDice(1, 3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				if ((cAttackerType == DEF_OWNERTYPE_NPC) &&
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit 1   .   .
				m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;


				// Damage    .
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) {
					// Hold    .
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, hb::magic::HoldObject);
				}

				//Crusade
				uint32_t iExp;

				// NPC           .
				if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) &&
					(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
					// ExpStock .      .
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > static_cast<uint32_t>(iDamage)) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;
							iExp += (uint32_t)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}

						if (bExp)
							GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
						else GetExp(sAttackerH, (iExp / 2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;
							iExp += (uint32_t)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}


						if (bExp)
							GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						else GetExp(sAttackerH, (iExp / 2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
	int iHP, iMaxHP;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	iHP = iDice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsKilled) return;
		iMaxHP = (3 * m_pClientList[sTargetH]->m_iVit) + (2 * m_pClientList[sTargetH]->m_iLevel) + ((m_pClientList[sTargetH]->m_iStr + m_pClientList[sTargetH]->m_iAngelicStr) / 2);
		if (m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown != 0)
			iMaxHP = iMaxHP - (iMaxHP / m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown);
		if (m_pClientList[sTargetH]->m_iHP < iMaxHP) {
			m_pClientList[sTargetH]->m_iHP += iHP;
			if (m_pClientList[sTargetH]->m_iHP > iMaxHP) m_pClientList[sTargetH]->m_iHP = iMaxHP;
			if (m_pClientList[sTargetH]->m_iHP <= 0)     m_pClientList[sTargetH]->m_iHP = 1;
			SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled) return;
		iMaxHP = m_pNpcList[sTargetH]->m_iHitDice * 4;
		if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) {
			m_pNpcList[sTargetH]->m_iHP += iHP;
			if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
			if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
		}
		break;
	}
}

void CGame::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
	int iSP, iMaxSP;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	iSP = iDice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsKilled) return;

		// New 19/05/2004
		// Is the user having an invincibility slate
		if (m_pClientList[sTargetH]->m_status.bSlateInvincible) return;

		iMaxSP = (2 * (m_pClientList[sTargetH]->m_iStr + m_pClientList[sTargetH]->m_iAngelicStr)) + (2 * m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP > 0) {

			//v1.42 
			if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[sTargetH]->m_iSP -= iSP;
				if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SP, 0, 0, 0, 0);
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC   .
		break;
	}
}


void CGame::Effect_SpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
	int iSP, iMaxSP;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == 0) return;

	iSP = iDice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return;
		if (m_pClientList[sTargetH]->m_bIsKilled) return;

		iMaxSP = (2 * (m_pClientList[sTargetH]->m_iStr + m_pClientList[sTargetH]->m_iAngelicStr)) + (2 * m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP < iMaxSP) {
			m_pClientList[sTargetH]->m_iSP += iSP;

			if (m_pClientList[sTargetH]->m_iSP > iMaxSP)
				m_pClientList[sTargetH]->m_iSP = iMaxSP;

			SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SP, 0, 0, 0, 0);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC   .
		break;
	}
}

/*********************************************************************************************************************
**  int bool CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio) **
**  description			:: calculates if a player resists magic														**
**  last updated		:: November 20, 2004; 8:42 PM; Hypnotoad													**
**	return value		:: bool																						**
**  commentary			::	-	hero armor for target mages adds 50 magic resistance								**
**							-	10000 or more it ratio will deduct 10000 hit ratio									**
**							-	invincible tablet is 100% magic resistance											**
**********************************************************************************************************************/
bool CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
	double dTmp1, dTmp2, dTmp3;
	int    iTargetMagicResistRatio, iDestHitRatio, iResult;
	char   cTargetDir, cProtect;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return false;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == false) return false;

		if (m_pClientList[sTargetH]->m_status.bSlateInvincible) return true;
		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pClientList[sTargetH]->m_cSkillMastery[3] + m_pClientList[sTargetH]->m_iAddMR;
		if ((m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_iAngelicMag) > 50)
			iTargetMagicResistRatio += ((m_pClientList[sTargetH]->m_iMag + m_pClientList[sTargetH]->m_iAngelicMag) - 50);
		iTargetMagicResistRatio += m_pClientList[sTargetH]->m_iAddResistMagic;
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect];
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return false;
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pNpcList[sTargetH]->m_cResistMagic;
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect];
		break;
	}

	if (cProtect == 5) return true;

	if ((iHitRatio < 1000) && (cProtect == 2)) return true;
	if (iHitRatio >= 10000) iHitRatio -= 10000;
	if (iTargetMagicResistRatio < 1) iTargetMagicResistRatio = 1;
	if (sTargetH < DEF_MAXCLIENTS)
	{
		if ((cAttackerDir != 0) && (m_pClientList[sTargetH] != 0) && (m_pClientList[sTargetH]->m_cHeroArmourBonus == 2)) {
			iHitRatio += 50;
		}
	}

	dTmp1 = (double)(iHitRatio);
	dTmp2 = (double)(iTargetMagicResistRatio);
	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3);

	if (iDestHitRatio < m_iMinimumHitRatio) iDestHitRatio = m_iMinimumHitRatio;
	if (iDestHitRatio > m_iMaximumHitRatio) iDestHitRatio = m_iMaximumHitRatio;
	if (iDestHitRatio >= 100) return false;

	iResult = iDice(1, 100);
	if (iResult <= iDestHitRatio) return false;

	if (cTargetType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sTargetH, 3, 1);
	return true;
}

bool CGame::bCheckResistingIceSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
	int    iTargetIceResistRatio, iResult;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == 0) return false;

		iTargetIceResistRatio = m_pClientList[sTargetH]->m_iAddAbsWater * 2;
		if (m_pClientList[sTargetH]->m_dwWarmEffectTime == 0) {
		}
		else if ((GameClock::GetTimeMS() - m_pClientList[sTargetH]->m_dwWarmEffectTime) < 1000 * 30) return true;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == 0) return false;
		iTargetIceResistRatio = (m_pNpcList[sTargetH]->m_cResistMagic) - (m_pNpcList[sTargetH]->m_cResistMagic / 3); // . NPC    70%
		break;
	}

	if (iTargetIceResistRatio < 1) iTargetIceResistRatio = 1;

	iResult = iDice(1, 100);
	if (iResult <= iTargetIceResistRatio) return true;

	return false;
}

bool CGame::bSetItemToBankItem(int iClientH, CItem* pItem)
{
	int iRet;

	if (m_pClientList[iClientH] == 0) return false;
	if (pItem == 0) return false;
	//wh remove
	//if (m_pClientList[iClientH]->m_bIsInsideWarehouse == false) return false;

	for(int i = 0; i < hb::limits::MaxBankItems; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == 0) {

			m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;

			{
				hb::net::PacketNotifyItemToBank pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = DEF_NOTIFY_ITEMTOBANK;
				pkt.bank_index = static_cast<uint8_t>(i);
				pkt.is_new = 1;
				memcpy(pkt.name, pItem->m_cName, sizeof(pkt.name));
				pkt.count = pItem->m_dwCount;
				pkt.item_type = pItem->m_cItemType;
				pkt.equip_pos = pItem->m_cEquipPos;
				pkt.is_equipped = 0;
				pkt.level_limit = pItem->m_sLevelLimit;
				pkt.gender_limit = pItem->m_cGenderLimit;
				pkt.cur_lifespan = pItem->m_wCurLifeSpan;
				pkt.weight = pItem->m_wWeight;
				pkt.sprite = pItem->m_sSprite;
				pkt.sprite_frame = pItem->m_sSpriteFrame;
				pkt.item_color = pItem->m_cItemColor;
				pkt.item_effect_value2 = pItem->m_sItemEffectValue2;
				pkt.attribute = pItem->m_dwAttribute;
				pkt.spec_effect_value2 = static_cast<uint8_t>(pItem->m_sItemSpecEffectValue2);
				pkt.item_id = pItem->m_sIDnum;
				pkt.max_lifespan = pItem->m_wMaxLifeSpan;
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// . v1.41  .
				// DeleteClient(iClientH, true, true);
				return true;
			}

			return true;
		}

	return false;
}

bool CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
	
	int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
	short sDownSkillIndex;

	if (m_pClientList[iClientH] == 0) return false;

	iTotalPoints = 0;
	for(int i = 0; i < DEF_MAXSKILLTYPE; i++)
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// .      SSN    .
		while (iRemainPoint > 0) {

			sDownSkillIndex = -1; // v1.4
			if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) {
				switch (m_pClientList[iClientH]->m_iDownSkillIndex) {
				case 3:

				default:
					// 20    0  .
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
						sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
					}
					else {
						iDownSkillSSN = 99999999;
						for(int i = 0; i < DEF_MAXSKILLTYPE; i++)
							if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) &&
								(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
								// V1.22     20    .
								iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
								sDownSkillIndex = i;
							}
					}
					break;
				}
			}
			// 1      SSN   sDownSkillIndex

			if (sDownSkillIndex != -1) {

				if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
					iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;

				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] + 1] - 1;
				iRemainPoint -= iDownPoint; // v1.4

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] != -1) {
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)] != -1) {
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], 0, 0);
			}
			else {
				return false;
			}
		}
		return true;
	}

	return false;
}


void CGame::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
	case VK_F1:
		m_bF1pressed = true;
		break;
	case VK_F4:
		m_bF4pressed = true;
		break;
	case VK_F5:
		m_bF5pressed = true;
		break;
	case VK_F12:
		m_bF12pressed = true;
		break;
	}
}

void CGame::OnKeyUp(WPARAM wParam, LPARAM lParam)
{
	

	switch (wParam) {
	case VK_F2:
		break;

	case VK_F1:
		m_bF1pressed = false;
		break;
	case VK_F4:
		m_bF4pressed = false;
		break;
	case VK_F5:
		m_bF5pressed = false;
		break;
	case VK_F12:
		m_bF12pressed = false;
		break;

	case VK_F6:
		if (m_bF1pressed) {
			PutLogList("(!) Send server shutdown announcement1...");
			for(int i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, 0, 0, 0);
				}
		}
		break;

	case VK_F7:
		if (m_bF1pressed) {
			PutLogList("(!) Send server shutdown announcement2...");
			for(int i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, 0, 0, 0);
				}
		}
		break;

	case VK_F9:
		if ((m_bF1pressed)) {
			PutLogList("(!!!) Resume Crusade Mode...");
			LocalStartCrusadeMode(0);
		}
		break;

	case VK_F11:
		if ((m_bF1pressed)) {
			PutLogList("(!!!) ManualEndCrusadeMode: side 0");
			ManualEndCrusadeMode(0);
		}
		break;

#define VK_1 0x31
	case VK_1:
		if ((m_bF1pressed)) {
			GlobalUpdateConfigs(1);
		}
		break;

#define VK_2 0x32
	case VK_2:
		if ((m_bF1pressed)) {
			GlobalUpdateConfigs(2);
		}
		break;

#define VK_3 0x33
	case VK_3:
		if ((m_bF1pressed)) {
			GlobalUpdateConfigs(3);
		}
		break;

#define VK_4 0x34
	case VK_4:
		if ((m_bF1pressed)) {
			GlobalUpdateConfigs(1);
		}
		break;

		/*#define VK_A 0x41 // a key
		case VK_A:
			if ((m_bF1pressed )) {
				GlobalStartApocalypseMode();
			}
			break;*/

			/*#define VK_H 0x49 // H key
			case VK_H:
				if ((m_bF1pressed )) {
					GlobalStartHeldenianMode();
				}
				break;*/

				//Crusade Testcode
	case VK_HOME:
		if ((m_bF1pressed)) {
			GlobalStartCrusadeMode();
		}
		break;

	case VK_INSERT:
		_GrandMagicLaunchMsgSend(1, 1);
		MeteorStrikeMsgHandler(1);
		break;

	case VK_DELETE:
		_GrandMagicLaunchMsgSend(1, 2);
		MeteorStrikeMsgHandler(2);
		break;
	}
}

int CGame::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{
	int iTotal;

	iTotal = 0;

	for(int i = 1; i < DEF_MAXNPCS; i++)
		if ((m_pNpcList[i] != 0) && (m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW)) {

			if ((m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) && (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType))
				iTotal++;
		}

	return iTotal;
}

/*********************************************************************************************************************
**  bool CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, uint32_t dwLastTime, int iTargetH,				**
**									   char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3) **
**  description			:: initiates the delayed event process														**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: bool																						**
**********************************************************************************************************************/
bool CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, uint32_t dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
	

	for(int i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] == 0) {
			m_pDelayEventList[i] = new class CDelayEvent;
			m_pDelayEventList[i]->m_iDelayType = iDelayType;
			m_pDelayEventList[i]->m_iEffectType = iEffectType;
			m_pDelayEventList[i]->m_cMapIndex = cMapIndex;
			m_pDelayEventList[i]->m_dX = dX;
			m_pDelayEventList[i]->m_dY = dY;
			m_pDelayEventList[i]->m_iTargetH = iTargetH;
			m_pDelayEventList[i]->m_cTargetType = cTargetType;
			m_pDelayEventList[i]->m_iV1 = iV1;
			m_pDelayEventList[i]->m_iV2 = iV2;
			m_pDelayEventList[i]->m_iV3 = iV3;
			m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;
			return true;
		}
	return false;
}

void CGame::DelayEventProcessor()
{
	int iSkillNum, iResult;
	uint32_t dwTime = GameClock::GetTimeMS();
	int iTemp;

	for(int i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if ((m_pDelayEventList[i] != 0) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

			switch (m_pDelayEventList[i]->m_iDelayType) {

			case DEF_DELAYEVENTTYPE_ANCIENT_TABLET:
				if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_status.bSlateInvincible) {
					iTemp = 1;
				}
				else if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_status.bSlateMana) {
					iTemp = 3;
				}
				else if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_status.bSlateExp) {
					iTemp = 4;
				}

				SendNotifyMsg(0, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SLATE_STATUS, iTemp, 0, 0, 0);
				SetSlateFlag(m_pDelayEventList[i]->m_iTargetH, iTemp, false);
				break;

			case DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
				CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
				DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DEF_DELAYEVENTTYPE_METEORSTRIKE:
				MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
				break;

			case DEF_DELAYEVENTTYPE_USEITEM_SKILL:
				switch (m_pDelayEventList[i]->m_cTargetType) {
				case DEF_OWNERTYPE_PLAYER:
					iSkillNum = m_pDelayEventList[i]->m_iEffectType;

					if (m_pClientList[m_pDelayEventList[i]->m_iTargetH] == 0) break;
					if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == false) break;
					// ID   v1.12
					if (m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;

					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = false;
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = 0;

					// Skill    .
					iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
						m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

					SendNotifyMsg(0, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SKILLUSINGEND, iResult, 0, 0, 0);
					break;
				}
				break;

			case DEF_DELAYEVENTTYPE_DAMAGEOBJECT:
				break;

			case DEF_DELAYEVENTTYPE_MAGICRELEASE:
				// Removes the aura after time
				switch (m_pDelayEventList[i]->m_cTargetType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[m_pDelayEventList[i]->m_iTargetH] == 0) break;

					SendNotifyMsg(0, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF,
						m_pDelayEventList[i]->m_iEffectType, m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_cMagicEffectStatus[m_pDelayEventList[i]->m_iEffectType], 0, 0);

					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_cMagicEffectStatus[m_pDelayEventList[i]->m_iEffectType] = 0;

					// Inbitition casting 
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Inhibition)
						m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bInhibition = false;

					// Invisibility
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Invisibility)
						SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);

					// Berserk
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Berserk)
						SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);

					// Haste
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Haste)
						SetHasteFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);

					// Confusion
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Confuse)
						switch (m_pDelayEventList[i]->m_iV1) {
						case 3: SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false); break;
						case 4: SetIllusionMovementFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false); break;
						}

					// Protection Magic
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Protect) {
						switch (m_pDelayEventList[i]->m_iV1) {
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
							break;
						}
					}


					// polymorph
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Polymorph) {
						m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
						SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}

					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Ice)
						SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, false);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[m_pDelayEventList[i]->m_iTargetH] == 0) break;

					m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_cMagicEffectStatus[m_pDelayEventList[i]->m_iEffectType] = 0;

					// Invisibility
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Invisibility)
						SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

					// Berserk
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Berserk)
						SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

					// polymorph
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Polymorph) {
						m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
						SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
					}

					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Ice)
						SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

					// Illusion
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Confuse)
						SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);

					// Protection Magic
					if (m_pDelayEventList[i]->m_iEffectType == hb::magic::Protect) {
						switch (m_pDelayEventList[i]->m_iV1) {
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, false);
							break;
						}
					}
					//	if (m_pDelayEventList[i]->m_iEffectType == /*notcoded*/)

					break;
				}
				break;
			}

			delete m_pDelayEventList[i];
			m_pDelayEventList[i] = 0;
		}
}
bool CGame::bRemoveFromDelayEventList(int iH, char cType, int iEffectType)
{
	

	for(int i = 0; i < DEF_MAXDELAYEVENTS; i++)
		if (m_pDelayEventList[i] != 0) {

			if (iEffectType == 0) {
				// Effect
				if ((m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType)) {
					delete m_pDelayEventList[i];
					m_pDelayEventList[i] = 0;
				}
			}
			else {
				// Effect .
				if ((m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) &&
					(m_pDelayEventList[i]->m_iEffectType == iEffectType)) {
					delete m_pDelayEventList[i];
					m_pDelayEventList[i] = 0;
				}
			}
		}

	return true;
}

void CGame::SendObjectMotionRejectMsg(int iClientH)
{
	int     iRet;

	m_pClientList[iClientH]->m_bIsMoveBlocked = true; // v2.171

	// Send motion reject response.
	hb::net::PacketResponseMotionReject pkt{};
	pkt.header.msg_id = MSGID_RESPONSE_MOTION;
	pkt.header.msg_type = DEF_OBJECTMOTION_REJECT;
	pkt.x = m_pClientList[iClientH]->m_sX;
	pkt.y = m_pClientList[iClientH]->m_sY;
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Socket error while sending motion reject.
		DeleteClient(iClientH, true, true);
		return;
	}
	return;
}


void CGame::DynamicObjectEffectProcessor()
{
	int iIndex;
	short sOwnerH, sType;
	int iDamage;
	char  cOwnerType;
	uint32_t dwTime = GameClock::GetTimeMS(), dwRegisterTime;

	for(int i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != 0) {
			switch (m_pDynamicObjectList[i]->m_sType) {

			case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
				for(int ix = m_pDynamicObjectList[i]->m_sX - 1; ix <= m_pDynamicObjectList[i]->m_sX + 1; ix++)
					for(int iy = m_pDynamicObjectList[i]->m_sY - 1; iy <= m_pDynamicObjectList[i]->m_sY + 1; iy++) {

						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != 0) {
							// Poison Damage .
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) break;
								if (m_pClientList[sOwnerH]->m_bIsKilled) break;
								//if ((m_pClientList[sOwnerH]->m_bIsNeutral ) && !m_pClientList[sOwnerH]->m_appearance.bIsWalking) break;

								if (m_pDynamicObjectList[i]->m_iV1 < 20)
									iDamage = iDice(1, 6);
								else iDamage = iDice(1, 8);

								// New 17/05/2004 Changed
								m_pClientList[sOwnerH]->m_iHP -= iDamage;

								if (m_pClientList[sOwnerH]->m_iHP <= 0) {
									ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
								}
								else {
									if (iDamage > 0) {
										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);

										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) {
											// 1: Hold-Person 
											// 2: Paralize
											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::HoldObject, m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject], 0, 0);

											m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
											bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::HoldObject);
										}
									}

									if ((bCheckResistingMagicSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, 100) == false) &&
										(m_pClientList[sOwnerH]->m_bIsPoisoned == false)) {

										m_pClientList[sOwnerH]->m_bIsPoisoned = true;
										m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
										m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
										SetPoisonFlag(sOwnerH, cOwnerType, true);// poison aura appears from dynamic objects
										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Poison, m_pClientList[sOwnerH]->m_iPoisonLevel, 0, 0);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) break;

								if (m_pDynamicObjectList[i]->m_iV1 < 20)
									iDamage = iDice(1, 6);
								else iDamage = iDice(1, 8);

								switch (m_pNpcList[sOwnerH]->m_sType) {
								case 40: // ESG
								case 41: // GMG
								case 67: // McGaffin
								case 68: // Perry
								case 69: // Devlin
									iDamage = 0;
									break;
								}

								// HP . Action Limit  .
								switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
								case 0:
								case 3:
								case 5:
									m_pNpcList[sOwnerH]->m_iHP -= iDamage;
									break;
								}
								//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
								//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

								if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
									// NPC .
									m_pEntityManager->OnEntityKilled(sOwnerH, sOwnerH, cOwnerType, 0);
								}
								else {
									// Damage    .
									if (iDice(1, 3) == 2)
										m_pNpcList[sOwnerH]->m_dwTime = dwTime;

									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) {
										// Hold    .
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
									}

									// NPC   .
									SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
								}
								break;
							}
						}
					}
				break;

			case DEF_DYNAMICOBJECT_ICESTORM:
				for(int ix = m_pDynamicObjectList[i]->m_sX - 2; ix <= m_pDynamicObjectList[i]->m_sX + 2; ix++)
					for(int iy = m_pDynamicObjectList[i]->m_sY - 2; iy <= m_pDynamicObjectList[i]->m_sY + 2; iy++) {

						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != 0) {
							switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) break;
								if (m_pClientList[sOwnerH]->m_bIsKilled) break;

								iDamage = iDice(3, 3) + 5;

								m_pClientList[sOwnerH]->m_iHP -= iDamage;

								if (m_pClientList[sOwnerH]->m_iHP <= 0) {
									ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
								}
								else {
									if (iDamage > 0) {

										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);

										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] == 1) {

											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::HoldObject, m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject], 0, 0);

											m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
											bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::HoldObject);
										}
									}

									if ((bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1) == false) &&
										(m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0)) {

										m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
										SetIceFlag(sOwnerH, cOwnerType, true);
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (20 * 1000),
											sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);

										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) break;

								iDamage = iDice(3, 3) + 5;

								switch (m_pNpcList[sOwnerH]->m_sType) {
								case 40: // ESG
								case 41: // GMG
								case 67: // McGaffin
								case 68: // Perry
								case 69: // Devlin
									iDamage = 0;
									break;
								}

								switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
								case 0:
								case 3:
								case 5:
									m_pNpcList[sOwnerH]->m_iHP -= iDamage;
									break;
								}

								if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
									// NPC .
									m_pEntityManager->OnEntityKilled(sOwnerH, sOwnerH, cOwnerType, 0);
								}
								else {
									// Damage    .
									if (iDice(1, 3) == 2)
										m_pNpcList[sOwnerH]->m_dwTime = dwTime;

									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) {
										// Hold    .
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
									}

									// NPC   .
									SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

									if ((bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1) == false) &&
										(m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] == 0)) {

										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
										SetIceFlag(sOwnerH, cOwnerType, true);
										bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + (20 * 1000),
											sOwnerH, cOwnerType, 0, 0, 0, 1, 0, 0);
									}
								}
								break;
							}
						}

						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0)) {
							iDamage = iDice(3, 2);
							m_pClientList[sOwnerH]->m_iHP -= iDamage;

							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
								}
							}
						}

						// Fire Object   .
						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
						if (((sType == DEF_DYNAMICOBJECT_FIRE) || (sType == DEF_DYNAMICOBJECT_FIRE3)) && (m_pDynamicObjectList[iIndex] != 0))
							m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime / 10);
					}
				break;

			case DEF_DYNAMICOBJECT_FIRE3:
			case DEF_DYNAMICOBJECT_FIRE:
				// Fire-Wall
				if (m_pDynamicObjectList[i]->m_iCount == 1) {
					CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
				}
				m_pDynamicObjectList[i]->m_iCount++;
				if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10;


				for(int ix = m_pDynamicObjectList[i]->m_sX - 1; ix <= m_pDynamicObjectList[i]->m_sX + 1; ix++)
					for(int iy = m_pDynamicObjectList[i]->m_sY - 1; iy <= m_pDynamicObjectList[i]->m_sY + 1; iy++) {

						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (sOwnerH != 0) {
							// Fire Damage .
							switch (cOwnerType) {

							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == 0) break;
								if (m_pClientList[sOwnerH]->m_bIsKilled) break;
								//if ((m_pClientList[sOwnerH]->m_bIsNeutral ) && !m_pClientList[sOwnerH]->m_appearance.bIsWalking) break;

								iDamage = iDice(1, 6);
								// New 17/05/2004
								m_pClientList[sOwnerH]->m_iHP -= iDamage;

								if (m_pClientList[sOwnerH]->m_iHP <= 0) {
									ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
								}
								else {
									if (iDamage > 0) {
										SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);

										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) {
											// Hold-Person    . Fire Field   .
											// 1: Hold-Person 
											// 2: Paralize	
											SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::HoldObject, m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject], 0, 0);

											m_pClientList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
											bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, hb::magic::HoldObject);
										}
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == 0) break;

								iDamage = iDice(1, 6);

								switch (m_pNpcList[sOwnerH]->m_sType) {
								case 40: // ESG
								case 41: // GMG
								case 67: // McGaffin
								case 68: // Perry
								case 69: // Devlin
									iDamage = 0;
									break;
								}

								// HP . Action Limit  .
								switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
								case 0:
								case 3:
								case 5:
									m_pNpcList[sOwnerH]->m_iHP -= iDamage;
									break;
								}
								//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
								//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

								if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
									// NPC .
									m_pEntityManager->OnEntityKilled(sOwnerH, sOwnerH, cOwnerType, 0);
								}
								else {
									// Damage    .
									if (iDice(1, 3) == 2)
										m_pNpcList[sOwnerH]->m_dwTime = dwTime;

									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) {
										// Hold    .
										m_pNpcList[sOwnerH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
									}

									// NPC   .
									SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
								}
								break;
							}
						}

						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0) &&
							(m_pClientList[sOwnerH]->m_iHP > 0)) {
							iDamage = iDice(1, 6);
							m_pClientList[sOwnerH]->m_iHP -= iDamage;

							if (m_pClientList[sOwnerH]->m_iHP <= 0) {
								ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);
							}
							else {
								if (iDamage > 0) {
									SendNotifyMsg(0, sOwnerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
								}
							}
						}

						// Ice Object   .
						m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
						if ((sType == DEF_DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != 0))
							m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime / 10);
					}
				break;
			}
		}
}

char _tmp_cCorpseX[] = { 0,  1, 1, 1, 0, -1, -1, -1, 0, 0, 0, 0 };
char _tmp_cCorpseY[] = { -1, -1, 0, 1, 1,  1,  0, -1, 0, 0, 0 };

void CGame::ClearSkillUsingStatus(int iClientH)
{
	
	short tX, fX, tY, fY;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) {
		tX = m_pClientList[iClientH]->m_sX;
		tY = m_pClientList[iClientH]->m_sY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(tX, tY, 0) == false) {
			fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
			fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX, fY, 0) == false) {
				m_pClientList[iClientH]->m_cDir = static_cast<char>(iDice(1, 8));
				fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
				fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX, fY, 0) == false) {
					return;
				}
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_DAMAGEMOVE, m_pClientList[iClientH]->m_cDir, 0, 0, 0);
		}
	}
	for(int i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_bSkillUsingStatus[i] = false;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = 0;
	}

	if (m_pClientList[iClientH]->m_iAllocatedFish != 0) {
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != 0)
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		m_pClientList[iClientH]->m_iAllocatedFish = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FISHCANCELED, 0, 0, 0, 0);
	}

}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
	CItem* pItem;
	char  cItemName[DEF_ITEMNAME];
	short lX, lY;
	int   iResult, iFish;

	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == 0) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == 0) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	if (cOwnerSkill == 0) return 0;

	// 100       1D105
	iResult = iDice(1, 105);
	if (cOwnerSkill <= iResult)	return 0;

	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == false) return 0;

	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case DEF_SKILLEFFECTTYPE_TAMING:
		// : dX, dY   .
		_TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY);
		break;

	case DEF_SKILLEFFECTTYPE_GET:
		std::memset(cItemName, 0, sizeof(cItemName));
		bool bIsFish = false;
		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:
			std::snprintf(cItemName, sizeof(cItemName), "Meat");
			break;

		case 2:
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
				if (iFish == 0) {
					std::snprintf(cItemName, sizeof(cItemName), "Fish");
					bIsFish = true;
				}
			}
			else {
				std::snprintf(cItemName, sizeof(cItemName), "Fish");
				bIsFish = true;
			}
			break;
		}

		if (strlen(cItemName) != 0) {

			if (bIsFish) {
				SendNotifyMsg(0, iOwnerH, DEF_NOTIFY_FISHSUCCESS, 0, 0, 0, 0);
				m_pClientList[iOwnerH]->m_iExpStock += iDice(1, 2);
			}

			pItem = new CItem;
			if (pItem == 0) return 0;
			if (_bInitItemAttr(pItem, cItemName)) {
				m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, cMapIndex,
					lX, lY, pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4
			}
		}
		break;
	}

	return 1;
}


void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
	char  cOwnerType;
	short sAttackerWeapon, sOwnerH;
	int   iResult, iPlayerSkillLevel;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((iV1 < 0) || (iV1 >= DEF_MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1] == 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1]) return;

	/*
	if (iV1 != 19) {
		m_pClientList[iClientH]->m_iAbuseCount++;
		if ((m_pClientList[iClientH]->m_iAbuseCount % 30) == 0) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!)  (%s) Skill(%d) Tries(%d)",m_pClientList[iClientH]->m_cCharName,
																	   iV1, m_pClientList[iClientH]->m_iAbuseCount);
			PutLogFileList(G_cTxt);
		}
	}
	*/

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
		return;
	}

	switch (m_pSkillConfigList[iV1]->m_sType) {
	case DEF_SKILLEFFECTTYPE_PRETEND:
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1:

			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
				return;
			}

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != 0) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
				return;
			}

			iResult = 0;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY - 1);
			iResult += sOwnerH;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY + 1);
			iResult += sOwnerH;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX - 1, m_pClientList[iClientH]->m_sY);
			iResult += sOwnerH;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX + 1, m_pClientList[iClientH]->m_sY);
			iResult += sOwnerH;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX - 1, m_pClientList[iClientH]->m_sY - 1);
			iResult += sOwnerH;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX + 1, m_pClientList[iClientH]->m_sY - 1);
			iResult += sOwnerH;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX - 1, m_pClientList[iClientH]->m_sY + 1);
			iResult += sOwnerH;
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX + 1, m_pClientList[iClientH]->m_sY + 1);
			iResult += sOwnerH;

			if (iResult != 0) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILLUSINGEND, 0, 0, 0, 0);
				return;
			}

			CalculateSSN_SkillIndex(iClientH, iV1, 1);

			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, sAttackerWeapon, 0);
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(14, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			break;
		}
		break;

	}

	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = true;
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, const char* pItemName)
{
	char cItemCategory;
	short sRemainLife;
	int   iPrice;
	double d1, d2, d3;
	bool   bNeutral;
	uint32_t  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;
	CItem* m_pGold;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < static_cast<uint32_t>(iNum)) return;

	iCalcTotalWeight(iClientH);

	m_pGold = new CItem;
	_bInitItemAttr(m_pGold, hb::item::ItemId::Gold);

	// v1.42
	bNeutral = false;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = true;
	switch (cSellToWhom) {
	case 15:
	case 24:
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
		// 12-22
		if ((cItemCategory >= 11) && (cItemCategory <= 50)) {

			iPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) * iNum;
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;


			if (bNeutral) iPrice = iPrice / 2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > _iCalcMaxLoad(iClientH)) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else SendNotifyMsg(0, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
		}
		else if ((cItemCategory >= 1) && (cItemCategory <= 10)) {
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			if (sRemainLife == 0) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 2, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice;
				d3 = d3 * d2;

				iPrice = (int)d3;
				iPrice = iPrice * iNum;

				dwAddPrice1 = 0;
				dwAddPrice2 = 0;
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;

					switch (dwSWEType) {
					case 6: dwMul1 = 2; break;
					case 8: dwMul1 = 2; break;
					case 5: dwMul1 = 3; break;
					case 1: dwMul1 = 4; break;
					case 7: dwMul1 = 5; break;
					case 2: dwMul1 = 6; break;
					case 3: dwMul1 = 15; break;
					case 9: dwMul1 = 20; break;
					default: dwMul1 = 1; break;
					}

					d1 = (double)iPrice * dwMul1;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1 * (d2 / 100.0f);

					dwAddPrice1 = (int)(d1 + d3);
				}

				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;

					switch (dwSWEType) {
					case 1:
					case 12: dwMul2 = 2; break;

					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7: dwMul2 = 4; break;

					case 8:
					case 9:
					case 10:
					case 11: dwMul2 = 6; break;
					}

					d1 = (double)iPrice * dwMul2;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1 * (d2 / 100.0f);

					dwAddPrice2 = (int)(d1 + d3);
				}

				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1 / 3)) + (dwAddPrice2 - (dwAddPrice2 / 3));

				if (bNeutral) iPrice = iPrice / 2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;

				if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > _iCalcMaxLoad(iClientH)) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				}
				else SendNotifyMsg(0, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
			}
		}
		else SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 1, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;


	default:
		break;
	}
	if (m_pGold != 0) delete m_pGold;
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, const char* pString)
{
	CItem* pItemGold;
	short sRemainLife;
	int   iPrice;
	double d1, d2, d3;
	char cItemCategory;
	uint32_t dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
	int    iEraseReq, iRet;
	bool   bNeutral;


	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < static_cast<uint32_t>(iNum)) return;

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	iCalcTotalWeight(iClientH);
	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// v1.42
	bNeutral = false;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = true;

	iPrice = 0;
	if ((cItemCategory >= 1) && (cItemCategory <= 10)) {
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

		if (sRemainLife <= 0) {
			return;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice;
			d3 = d3 * d2;

			iPrice = (short)d3;
			iPrice = iPrice * iNum;

			dwAddPrice1 = 0;
			dwAddPrice2 = 0;
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != 0) {
				dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;

				// 0-None 1- 2- 3- 4-
				// 5- 6- 7- 8- 9-
				switch (dwSWEType) {
				case 6: dwMul1 = 2; break;
				case 8: dwMul1 = 2; break;
				case 5: dwMul1 = 3; break;
				case 1: dwMul1 = 4; break;
				case 7: dwMul1 = 5; break;
				case 2: dwMul1 = 6; break;
				case 3: dwMul1 = 15; break;
				case 9: dwMul1 = 20; break;
				default: dwMul1 = 1; break;
				}

				d1 = (double)iPrice * dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1 * (d2 / 100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}

			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != 0) {
				dwSWEType = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;

				// (1),  (2),  (3), HP  (4), SP  (5)
				// MP  (6),  (7),   (8),   (9)
				// (10),   (11),  Gold(12)
				switch (dwSWEType) {
				case 1:
				case 12: dwMul2 = 2; break;

				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;

				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}

				d1 = (double)iPrice * dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1 * (d2 / 100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}

			iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1 / 3)) + (dwAddPrice2 - (dwAddPrice2 / 3));

			if (bNeutral) iPrice = iPrice / 2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000; // New 06/05/2004

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, 0, 0, 0);

			_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[cItemID]);

			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->GetItemType() == ItemType::Consume) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->GetItemType() == ItemType::Arrow)) {
				// v1.41 !!!
				SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}
			else ItemDepleteHandler(iClientH, cItemID, false);
		}
	}
	else
		if ((cItemCategory >= 11) && (cItemCategory <= 50)) {
			iPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
			iPrice = iPrice * iNum;

			if (bNeutral) iPrice = iPrice / 2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000; // New 06/05/2004

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, 0, 0, 0);

			_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[cItemID]);

			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->GetItemType() == ItemType::Consume) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->GetItemType() == ItemType::Arrow)) {
				// v1.41 !!!
				SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}
			else ItemDepleteHandler(iClientH, cItemID, false);
		}

	// Gold .    0     .
	if (iPrice <= 0) return;

	pItemGold = new CItem;
	_bInitItemAttr(pItemGold, hb::item::ItemId::Gold);
	pItemGold->m_dwCount = iPrice;

	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq)) {

		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItemGold, 0);

		iCalcTotalWeight(iClientH);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			break;
		}
	}
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY, pItemGold);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItemGold->m_sIDnum, 0, pItemGold->m_cItemColor, pItemGold->m_dwAttribute); // v1.4 color

		iCalcTotalWeight(iClientH);

		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return;
		}
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, const char* pString)
{
	char cItemCategory;
	short sRemainLife, sPrice;
	double d1, d2, d3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	if ((cItemCategory >= 1) && (cItemCategory <= 10)) {

		if (cRepairWhom != 24) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}

		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			sPrice = static_cast<short>(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2);
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice;
			d3 = d3 * d2;

			sPrice = static_cast<short>((m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - d3);
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else if (((cItemCategory >= 43) && (cItemCategory <= 50)) || ((cItemCategory >= 11) && (cItemCategory <= 12))) {

		if (cRepairWhom != 15) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}

		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			sPrice = static_cast<short>(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2);
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice;
			d3 = d3 * d2;

			sPrice = static_cast<short>((m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - d3);
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, 0, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, const char* pString)
{
	short    sRemainLife, sPrice;
	char cItemCategory;
	double   d1, d2, d3;
	uint32_t dwGoldCount;
	int      iRet, iGoldWeight;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == 0) return;

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	//testcode
	//PutLogList("Repair!");

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	if (((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) ||
		((cItemCategory >= 11) && (cItemCategory <= 12))) {

		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			sPrice = static_cast<short>(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2);
		}
		else {
			d1 = (double)abs(sRemainLife);
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)abs(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan);
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice;
			d3 = d3 * d2;

			sPrice = static_cast<short>((m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - d3);
		}

		// sPrice         .
		dwGoldCount = dwGetItemCountByID(iClientH, hb::item::ItemId::Gold);

		if (dwGoldCount < (uint32_t)sPrice) {
			// Gold     .   .
			{
				hb::net::PacketNotifyNotEnoughGold pkt{};
				pkt.header.msg_id = MSGID_NOTIFY;
				pkt.header.msg_type = DEF_NOTIFY_NOTENOUGHGOLD;
				pkt.item_index = static_cast<int8_t>(cItemID);
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
			}
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return;
			}
			return;
		}
		else {

			// . !BUG POINT  .      .
			m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMREPAIRED, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan, 0, 0);

			iGoldWeight = SetItemCountByID(iClientH, hb::item::ItemId::Gold, dwGoldCount - sPrice);

			iCalcTotalWeight(iClientH);

			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += sPrice;
		}
	}
	else {
	}
}

int CGame::iCalcTotalWeight(int iClientH)
{
	int iWeight;
	short sItemIndex;

	if (m_pClientList[iClientH] == 0) return 0;

	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	for (sItemIndex = 0; sItemIndex < hb::limits::MaxItems; sItemIndex++)
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType()) {
			case ItemEffectType::AlterItemDrop:
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
					m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
				}
				break;
			}
		}

	iWeight = 0;
	for(int i = 0; i < hb::limits::MaxItems; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {

			iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
		}

	m_pClientList[iClientH]->m_iCurWeightLoad = iWeight;

	return iWeight;
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char* pMsg, uint32_t dwSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cName[DEF_CHARNAME], cBuff[256], cPlayerLocation[120];
	

	if (m_pClientList[iClientH] == 0) return;
	if (dwSize <= 0) return;

	std::memset(cPlayerLocation, 0, sizeof(cPlayerLocation));
	std::memset(cName, 0, sizeof(cName));
	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);

	token = strtok(cBuff, seps);
	token = strtok(NULL, seps);

	if (token == 0) {
		return;
	}

	if (strlen(token) > DEF_CHARNAME - 1)
		memcpy(cName, token, DEF_CHARNAME - 1);
	else memcpy(cName, token, strlen(token));

	// cName     .
	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (_strnicmp(cName, m_pClientList[i]->m_cCharName, DEF_CHARNAME - 1) == 0)) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERONGAME, 0, 0, 0, m_pClientList[i]->m_cCharName, 0, 0, 0, 0, 0, 0, cPlayerLocation);

			return;
		}

}


void CGame::SetPlayerProfile(int iClientH, char* pMsg, size_t dwMsgSize)
{
	char cTemp[256];
	


	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize - 7) <= 0) return;

	std::memset(cTemp, 0, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);

	for(int i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';

	cTemp[255] = 0;

	std::memset(m_pClientList[iClientH]->m_cProfile, 0, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char* pMsg, size_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cName[DEF_CHARNAME], cBuff[256], cBuff2[500];
	

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;

	std::memset(cName, 0, sizeof(cName));
	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	token = strtok(cBuff, seps);
	token = strtok(NULL, seps);

	if (token != 0) {
		// token
		if (strlen(token) > DEF_CHARNAME - 1)
			memcpy(cName, token, DEF_CHARNAME - 1);
		else memcpy(cName, token, strlen(token));

		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (_strnicmp(m_pClientList[i]->m_cCharName, cName, DEF_CHARNAME - 1) == 0)) {

				std::memset(cBuff2, 0, sizeof(cBuff2));
				std::snprintf(cBuff2, sizeof(cBuff2), "%s Profile: %s", cName, m_pClientList[i]->m_cProfile);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERPROFILE, 0, 0, 0, cBuff2);

				return;
			}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cName);
	}

	return;
}

void CGame::___RestorePlayerCharacteristics(int iClientH)
{
	int iStr, iDex, iInt, iVit, iMag, iCharisma;
	int iOriginalPoint, iCurPoint, iVerifyPoint, iToBeRestoredPoint;
	int iMax, iA, iB;
	bool bFlag;
	char cTxt[120];
	return;
	if (m_pClientList[iClientH] == 0) return;

	iStr = m_pClientList[iClientH]->m_iStr;
	iDex = m_pClientList[iClientH]->m_iDex;
	iInt = m_pClientList[iClientH]->m_iInt;
	iVit = m_pClientList[iClientH]->m_iVit;
	iMag = m_pClientList[iClientH]->m_iMag;
	iCharisma = m_pClientList[iClientH]->m_iCharisma;


	iCurPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt +
		m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex +
		m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	iOriginalPoint = (m_pClientList[iClientH]->m_iLevel - 1) * 3 + 70;

	iToBeRestoredPoint = iOriginalPoint - iCurPoint;

	if (iToBeRestoredPoint == 0) return;

	if (iToBeRestoredPoint > 0) {
		// iToBeRestoredPoint   .
		while (1) {
			bFlag = false;

			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < 10)) {
				m_pClientList[iClientH]->m_iStr++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < 10)) {
				m_pClientList[iClientH]->m_iMag++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < 10)) {
				m_pClientList[iClientH]->m_iInt++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < 10)) {
				m_pClientList[iClientH]->m_iDex++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iVit < 10)) {
				m_pClientList[iClientH]->m_iVit++;
				iToBeRestoredPoint--;
				bFlag = true;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iCharisma < 10)) {
				m_pClientList[iClientH]->m_iCharisma++;
				iToBeRestoredPoint--;
				bFlag = true;
			}

			if (bFlag == false)          break;
			if (iToBeRestoredPoint <= 0) break;
		}

		// iMax, Str iMax/2   .
		iMax = m_pClientList[iClientH]->m_cSkillMastery[5];

		if (m_pClientList[iClientH]->m_iStr < (iMax / 2)) {

			while (1) {
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < (iMax / 2))) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iStr == (iMax / 2)) break;
				if (iToBeRestoredPoint <= 0) break;
			}
		}

		// iMax, Dex iMax/2   .
		iA = m_pClientList[iClientH]->m_cSkillMastery[7];
		iB = m_pClientList[iClientH]->m_cSkillMastery[8];
		if (iA > iB)
			iMax = iA;
		else iMax = iB;
		iA = m_pClientList[iClientH]->m_cSkillMastery[9];
		if (iA > iMax) iMax = iA;
		iA = m_pClientList[iClientH]->m_cSkillMastery[6];
		if (iA > iMax) iMax = iA;


		if (m_pClientList[iClientH]->m_iDex < (iMax / 2)) {

			while (1) {
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < (iMax / 2))) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iDex == (iMax / 2)) break;
				if (iToBeRestoredPoint <= 0) break;
			}
		}

		// iMax, Int iMax/2   .
		iMax = m_pClientList[iClientH]->m_cSkillMastery[19];

		if (m_pClientList[iClientH]->m_iInt < (iMax / 2)) {

			while (1) {
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < (iMax / 2))) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iInt == (iMax / 2)) break;
				if (iToBeRestoredPoint <= 0) break;
			}
		}

		// iMax, Mag iMax/2   .
		iA = m_pClientList[iClientH]->m_cSkillMastery[3];
		iB = m_pClientList[iClientH]->m_cSkillMastery[4];
		if (iA > iB)
			iMax = iA;
		else iMax = iB;

		if (m_pClientList[iClientH]->m_iMag < (iMax / 2)) {

			while (1) {
				if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < (iMax / 2))) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iMag == (iMax / 2)) break;
				if (iToBeRestoredPoint <= 0) break;
			}
		}

		while (iToBeRestoredPoint != 0) {
			switch (iDice(1, 6)) {
			case 1:
				if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}
				break;
			case 2:
				if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iVit++;
					iToBeRestoredPoint--;
				}
				break;
			case 3:
				if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}
				break;
			case 4:
				if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}
				break;
			case 5:
				if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}
				break;
			case 6:
				if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iCharisma++;
					iToBeRestoredPoint--;
				}
				break;
			}
		}

		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt +
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex +
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint) {
			std::snprintf(cTxt, sizeof(cTxt), "(T_T) RestorePlayerCharacteristics(Minor) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
		}
		else {
			std::snprintf(cTxt, sizeof(cTxt), "(^o^) RestorePlayerCharacteristics(Minor) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
	else {
		// .   . iToBeRestoredPoint !

		while (1) {
			bFlag = false;
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iStr--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iDex--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iVit--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iInt--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iMag--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) {
				bFlag = true;
				m_pClientList[iClientH]->m_iCharisma--;
				iToBeRestoredPoint++;
			}

			if (bFlag == false)	break;
			if (iToBeRestoredPoint >= 0) break;
		}

		if (iToBeRestoredPoint < 0) {
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1, 6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr > 10) {
						m_pClientList[iClientH]->m_iStr--;
						iToBeRestoredPoint++;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit > 10) {
						m_pClientList[iClientH]->m_iVit--;
						iToBeRestoredPoint++;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex > 10) {
						m_pClientList[iClientH]->m_iDex--;
						iToBeRestoredPoint++;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag > 10) {
						m_pClientList[iClientH]->m_iMag--;
						iToBeRestoredPoint++;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt > 10) {
						m_pClientList[iClientH]->m_iInt--;
						iToBeRestoredPoint++;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma > 10) {
						m_pClientList[iClientH]->m_iCharisma--;
						iToBeRestoredPoint++;
					}
					break;
				}
			}
		}
		else {
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1, 6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iStr++;
						iToBeRestoredPoint--;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iVit++;
						iToBeRestoredPoint--;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iDex++;
						iToBeRestoredPoint--;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iMag++;
						iToBeRestoredPoint--;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iInt++;
						iToBeRestoredPoint--;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iCharisma++;
						iToBeRestoredPoint--;
					}
					break;
				}
			}
		}

		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt +
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex +
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint) {
			std::snprintf(cTxt, sizeof(cTxt), "(T_T) RestorePlayerCharacteristics(Over) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

		}
		else {
			std::snprintf(cTxt, sizeof(cTxt), "(^o^) RestorePlayerCharacteristics(Over) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
}

void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, bool bNotify)
{
	short sItemIndex;
	int iArrowIndex, iPrevSAType, iTemp;
	EquipPos cEquipPos;
	double dV1, dV2, dV3;
	uint32_t  dwSWEType, dwSWEValue;

	if (m_pClientList[iClientH] == 0) return;

	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)] != -1) &&
		(m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] != -1)) {

		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)]] != 0) {
			m_pClientList[iClientH]->m_bIsItemEquipped[m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)]] = false;
			m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)] = -1;
		}
	}

	m_pClientList[iClientH]->m_iAngelicStr = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicInt = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicDex = 0; // By Snoopy81
	m_pClientList[iClientH]->m_iAngelicMag = 0; // By Snoopy81	
	SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 0, 0);

	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
	m_pClientList[iClientH]->m_cAttackBonus_SM = 0;

	m_pClientList[iClientH]->m_cAttackDiceThrow_L = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_L = 0;
	m_pClientList[iClientH]->m_cAttackBonus_L = 0;

	m_pClientList[iClientH]->m_iHitRatio = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = m_pClientList[iClientH]->m_iDex * 2;
	m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 0;

	for(int i = 0; i < DEF_MAXITEMEQUIPPOS; i++) {
		m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i] = 0;
	}

	m_pClientList[iClientH]->m_iManaSaveRatio = 0;
	m_pClientList[iClientH]->m_iAddResistMagic = 0;

	m_pClientList[iClientH]->m_iAddPhysicalDamage = 0;
	m_pClientList[iClientH]->m_iAddMagicalDamage = 0;

	m_pClientList[iClientH]->m_bIsLuckyEffect = false;
	m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = -1;
	m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 0;

	m_pClientList[iClientH]->m_iAddAbsAir = 0;
	m_pClientList[iClientH]->m_iAddAbsEarth = 0;
	m_pClientList[iClientH]->m_iAddAbsFire = 0;
	m_pClientList[iClientH]->m_iAddAbsWater = 0;

	m_pClientList[iClientH]->m_iCustomItemValue_Attack = 0;
	m_pClientList[iClientH]->m_iCustomItemValue_Defense = 0;

	m_pClientList[iClientH]->m_iMinAP_SM = 0;
	m_pClientList[iClientH]->m_iMinAP_L = 0;

	m_pClientList[iClientH]->m_iMaxAP_SM = 0;
	m_pClientList[iClientH]->m_iMaxAP_L = 0;

	m_pClientList[iClientH]->m_iSpecialWeaponEffectType = 0;	// : 0-None 1- 2- 3- 4-
	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = 0;

	m_pClientList[iClientH]->m_iAddHP = m_pClientList[iClientH]->m_iAddSP = m_pClientList[iClientH]->m_iAddMP = 0;
	m_pClientList[iClientH]->m_iAddAR = m_pClientList[iClientH]->m_iAddPR = m_pClientList[iClientH]->m_iAddDR = 0;
	m_pClientList[iClientH]->m_iAddMR = m_pClientList[iClientH]->m_iAddAbsPD = m_pClientList[iClientH]->m_iAddAbsMD = 0;
	m_pClientList[iClientH]->m_iAddCD = m_pClientList[iClientH]->m_iAddExp = m_pClientList[iClientH]->m_iAddGold = 0;

	iPrevSAType = m_pClientList[iClientH]->m_iSpecialAbilityType;

	m_pClientList[iClientH]->m_iSpecialAbilityType = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = 0;

	m_pClientList[iClientH]->m_iAddTransMana = 0;
	m_pClientList[iClientH]->m_iAddChargeCritical = 0;

	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	for (sItemIndex = 0; sItemIndex < hb::limits::MaxItems; sItemIndex++)
	{
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType()) {
			case ItemEffectType::AlterItemDrop:
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
					m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
				}
				break;
			}
		}
	}

	for (sItemIndex = 0; sItemIndex < hb::limits::MaxItems; sItemIndex++)
	{
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != 0) &&
			(m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex])) {

			cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetEquipPos();

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType()) {

			case ItemEffectType::MagicDamageSave:
				m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = sItemIndex;
				break;

			case ItemEffectType::AttackSpecAbility:
			case ItemEffectType::AttackDefense:
			case ItemEffectType::AttackManaSave:
			case ItemEffectType::AttackMaxHPDown:
			case ItemEffectType::Attack:
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1);
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				m_pClientList[iClientH]->m_cAttackBonus_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3);
				m_pClientList[iClientH]->m_cAttackDiceThrow_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4);
				m_pClientList[iClientH]->m_cAttackDiceRange_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5);
				m_pClientList[iClientH]->m_cAttackBonus_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);

				iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
				//testcode
				//std::snprintf(G_cTxt, sizeof(G_cTxt), "Add Damage: %d", iTemp);
				//PutLogList(G_cTxt);

				m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;
				m_pClientList[iClientH]->m_iAddMagicalDamage += iTemp;

				m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill];

				//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
				//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
				m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;

				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != 0) {
					m_pClientList[iClientH]->m_iCustomItemValue_Attack += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 100)
						m_pClientList[iClientH]->m_iCustomItemValue_Attack = 100;

					if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < -100)
						m_pClientList[iClientH]->m_iCustomItemValue_Attack = -100;

					if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 0) {
						dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
						dV1 = (dV2 / 100.0f) * (5.0f);
						m_pClientList[iClientH]->m_iMinAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM +
							m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;

						m_pClientList[iClientH]->m_iMinAP_L = m_pClientList[iClientH]->m_cAttackDiceThrow_L +
							m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

						if (m_pClientList[iClientH]->m_iMinAP_SM < 1) m_pClientList[iClientH]->m_iMinAP_SM = 1;
						if (m_pClientList[iClientH]->m_iMinAP_L < 1)  m_pClientList[iClientH]->m_iMinAP_L = 1;

						if (m_pClientList[iClientH]->m_iMinAP_SM > (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM))
							m_pClientList[iClientH]->m_iMinAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);

						if (m_pClientList[iClientH]->m_iMinAP_L > (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L))
							m_pClientList[iClientH]->m_iMinAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);

						//testcode
						//std::snprintf(G_cTxt, sizeof(G_cTxt), "MinAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMinAP_SM, m_pClientList[iClientH]->m_iMinAP_L, (int)dV1);
						//PutLogList(G_cTxt);
					}
					else if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < 0) {
						dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
						dV1 = (dV2 / 100.0f) * (5.0f);
						m_pClientList[iClientH]->m_iMaxAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM
							+ m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;

						m_pClientList[iClientH]->m_iMaxAP_L = m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L
							+ m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

						if (m_pClientList[iClientH]->m_iMaxAP_SM < 1) m_pClientList[iClientH]->m_iMaxAP_SM = 1;
						if (m_pClientList[iClientH]->m_iMaxAP_L < 1)  m_pClientList[iClientH]->m_iMaxAP_L = 1;

						if (m_pClientList[iClientH]->m_iMaxAP_SM < (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM))
							m_pClientList[iClientH]->m_iMaxAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);

						if (m_pClientList[iClientH]->m_iMaxAP_L < (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L))
							m_pClientList[iClientH]->m_iMaxAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);

						//testcode
						//std::snprintf(G_cTxt, sizeof(G_cTxt), "MaxAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMaxAP_SM, m_pClientList[iClientH]->m_iMaxAP_L, (int)dV1);
						//PutLogList(G_cTxt);
					}
				}

				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;

					// 0-None 1- 2- 3- 4-
					// 5- 6- 7- 8- 9- 10-
					m_pClientList[iClientH]->m_iSpecialWeaponEffectType = (int)dwSWEType;
					m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = (int)dwSWEValue;

					switch (dwSWEType) {
					case 7:
						m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
						m_pClientList[iClientH]->m_cAttackDiceRange_L++;
						break;

					case 9:
						m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
						m_pClientList[iClientH]->m_cAttackDiceRange_L += 2;
						break;
					}
				}

				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;

					// (1),  (2),  (3), HP  (4), SP  (5)
					// MP  (6),  (7),   (8),   (9)
					// (10),   (11),  Gold(12)

					switch (dwSWEType) {
					case 0:  break;
					case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue * 7; break;
					case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue * 7; break;
					case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue * 7; break;
					case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue * 7; break;
					case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue * 7; break;
					case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue * 7; break;
					case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue * 7; break;
					case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue * 3; break;
					case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue * 3; break;
					case 10: m_pClientList[iClientH]->m_iAddCD += (int)dwSWEValue; break;
					case 11: m_pClientList[iClientH]->m_iAddExp += (int)dwSWEValue * 10; break;
					case 12: m_pClientList[iClientH]->m_iAddGold += (int)dwSWEValue * 10; break;
					}

					switch (dwSWEType) {
					case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break;
					}
				}

				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType()) {
				case ItemEffectType::AttackMaxHPDown:
					m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
					break;

				case ItemEffectType::AttackManaSave:
					// :    80%
					m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
					if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
					break;

				case ItemEffectType::AttackDefense:
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Body)] += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
					break;

				case ItemEffectType::AttackSpecAbility:
					m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
					m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1;
					m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = ToInt(cEquipPos);

					if ((bNotify) && (iEquipItemID == (int)sItemIndex))
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, 0);
					break;
				}
				break;

			case ItemEffectType::AddEffect:
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
				case 1:
					m_pClientList[iClientH]->m_iAddResistMagic += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 2:
					m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
					break;

				case 3:
					m_pClientList[iClientH]->m_iAddPhysicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 4:
					m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 5:
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 != 0)
						m_pClientList[iClientH]->m_bIsLuckyEffect = true;
					else m_pClientList[iClientH]->m_bIsLuckyEffect = false;
					break;

				case 6:
					m_pClientList[iClientH]->m_iAddMagicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 7:
					m_pClientList[iClientH]->m_iAddAbsAir += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 8:
					m_pClientList[iClientH]->m_iAddAbsEarth += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 9:
					m_pClientList[iClientH]->m_iAddAbsFire += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 10:
					// . (2  )
					m_pClientList[iClientH]->m_iAddAbsWater += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 11:
					m_pClientList[iClientH]->m_iAddPR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 12:
					m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					break;

				case 13: // Magin Ruby		Characters Hp recovery rate(% applied) added by the purity formula.
					m_pClientList[iClientH]->m_iAddHP += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 5);
					break;

				case 14: // Magin Diamond	Attack probability(physical&magic) added by the purity formula.
					m_pClientList[iClientH]->m_iAddAR += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 5);
					break;


				case 15: // Magin Emerald	Magical damage decreased(% applied) by the purity formula.	
					m_pClientList[iClientH]->m_iAddAbsMD += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 10);
					if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80;
					break;

				case 30: // Magin Sapphire	Phisical damage decreased(% applied) by the purity formula.	
					iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 / 10);
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Head)] += iTemp;
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Body)] += iTemp;
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Arms)] += iTemp;
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Pants)] += iTemp;
					break;

					/*Functions rates confirm.
					Magic Diamond: Completion rate / 5 = Functions rate. ? Maximum 20. (not%)
					Magic Ruby: Completion rate / 5 = Functions rate.(%) ? Maximum 20%.
					Magic Emerald: Completion rate / 10 = Functions rate.(%) ? Maximum 10%.
					Magic Sapphire: Completion rate / 10 = Functions rate.(%) ? Maximum 10%.*/

					// ******* Angel Code - Begin ******* //			
				case 16: // Angel STR//AngelicPandent(STR)
					iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					m_pClientList[iClientH]->m_iAngelicStr = iTemp + 1;
					SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 1, iTemp);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
					break;
				case 17: // Angel DEX //AngelicPandent(DEX)
					iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					m_pClientList[iClientH]->m_iAngelicDex = iTemp + 1;
					SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 2, iTemp);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
					break;
				case 18: // Angel INT//AngelicPandent(INT)
					iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					m_pClientList[iClientH]->m_iAngelicInt = iTemp + 1;
					SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 3, iTemp);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
					break;
				case 19: // Angel MAG//AngelicPandent(MAG)
					iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					m_pClientList[iClientH]->m_iAngelicMag = iTemp + 1;
					SetAngelFlag(iClientH, DEF_OWNERTYPE_PLAYER, 4, iTemp);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_SETTING_SUCCESS, 0, 0, 0, 0);
					break;

				}
				break;

			case ItemEffectType::AttackArrow:
				if ((m_pClientList[iClientH]->m_cArrowIndex != -1) &&
					(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cArrowIndex] == 0)) {
					// ArrowIndex  . ( )
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
				}
				else if (m_pClientList[iClientH]->m_cArrowIndex == -1)
					m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

				if (m_pClientList[iClientH]->m_cArrowIndex == -1) {
					m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
					m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
					m_pClientList[iClientH]->m_cAttackBonus_SM = 0;
					m_pClientList[iClientH]->m_cAttackDiceThrow_L = 0;
					m_pClientList[iClientH]->m_cAttackDiceRange_L = 0;
					m_pClientList[iClientH]->m_cAttackBonus_L = 0;
				}
				else {
					iArrowIndex = m_pClientList[iClientH]->m_cArrowIndex;
					m_pClientList[iClientH]->m_cAttackDiceThrow_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1);
					m_pClientList[iClientH]->m_cAttackDiceRange_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
					m_pClientList[iClientH]->m_cAttackBonus_SM = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3);
					m_pClientList[iClientH]->m_cAttackDiceThrow_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4);
					m_pClientList[iClientH]->m_cAttackDiceRange_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5);
					m_pClientList[iClientH]->m_cAttackBonus_L = static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6);
				}

				m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill];
				break;

			case ItemEffectType::DefenseSpecAbility:
			case ItemEffectType::Defense:
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;

				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != 0) {
					m_pClientList[iClientH]->m_iCustomItemValue_Defense += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;

					dV2 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					dV3 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					dV1 = (double)(dV2 / 100.0f) * dV3;

					dV1 = dV1 / 2.0f;
					m_pClientList[iClientH]->m_iDefenseRatio += (int)dV1;
					if (m_pClientList[iClientH]->m_iDefenseRatio <= 0) m_pClientList[iClientH]->m_iDefenseRatio = 1;

					//testcode
					//std::snprintf(G_cTxt, sizeof(G_cTxt), "Custom-Defense: %d", (int)dV1);
					//PutLogList(G_cTxt);
				}

				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;

					// 0-None 1- 2- 3- 4-
					// 5- 6- 7- 8- 9- 10- 11- 12-

					switch (dwSWEType) {
					case 7:
						m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
						m_pClientList[iClientH]->m_cAttackDiceRange_L++;
						break;

					case 9:
						m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
						m_pClientList[iClientH]->m_cAttackDiceRange_L += 2;
						break;

						// v2.04 
					case 11:
						m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;
						if (m_pClientList[iClientH]->m_iAddTransMana > 13) m_pClientList[iClientH]->m_iAddTransMana = 13;
						break;

					case 12:
						m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
						if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
						break;
					}
				}

				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != 0) {
					dwSWEType = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;

					// (1),  (2),  (3), HP  (4), SP  (5)
					// MP  (6),  (7),   (8),   (9)
					// (10),   (11),  Gold(12)

					switch (dwSWEType) {
					case 0:  break;
					case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue * 7; break;
					case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue * 7; break;
					case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue * 7; break;
					case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue * 7; break;
					case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue * 7; break;
					case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue * 7; break;
					case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue * 7; break;
					case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue * 3; break;
					case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue * 3; break;
					case 10: m_pClientList[iClientH]->m_iAddCD += (int)dwSWEValue; break;
					case 11: m_pClientList[iClientH]->m_iAddExp += (int)dwSWEValue * 10; break;
					case 12: m_pClientList[iClientH]->m_iAddGold += (int)dwSWEValue * 10; break;
					}

					switch (dwSWEType) {
					case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break;
					}
				}

				switch (cEquipPos) {
				case EquipPos::LeftHand:
					// .  70%
					m_pClientList[iClientH]->m_iDamageAbsorption_Shield = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) - (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) / 3;
					break;
				default:
					// .  70%  <- v1.43 100% . V2!
					m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
					break;
				}

				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType()) {
				case ItemEffectType::DefenseSpecAbility:
					m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
					m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1;
					m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = ToInt(cEquipPos);

					if ((bNotify) && (iEquipItemID == (int)sItemIndex))
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, 0);
					break;
				}
				break;
			}
		}
	}

	// Snoopy: Bonus for Angels	
	m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_iAngelicDex * 2;
	if (m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
	if (m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	if (m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);


	//v1.432
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) && (bNotify)) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 4, 0, 0, 0);
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled) {
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = false;
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			m_pClientList[iClientH]->m_appearance.iEffectType = 0;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		}
	}

	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) &&
		(iPrevSAType != m_pClientList[iClientH]->m_iSpecialAbilityType) && (bNotify)) {
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled) {
			SendNotifyMsg(0, iClientH , DEF_NOTIFY_SPECIALABILITYSTATUS, 3, 0, 0, 0);
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = false;
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			m_pClientList[iClientH]->m_appearance.iEffectType = 0;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		}
	}
}

int CGame::_iGetPlayerNumberOnSpot(short dX, short dY, char cMapIndex, char cRange)
{
	int iSum = 0;
	short sOwnerH;
	char  cOwnerType;

	for(int ix = dX - cRange; ix <= dX + cRange; ix++)
		for(int iy = dY - cRange; iy <= dY + cRange; iy++) {
			m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
				iSum++;
		}

	return iSum;
}


bool CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, bool bIsCheck)
{
	int   iNamingValue, tX, tY;
	short sOwnerH;
	char  cOwnerType, cName[DEF_CHARNAME], cNpcName[DEF_NPCNAME];
	char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return false;
	if (m_bIsCrusadeMode) return false;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != 0)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != true) {
			if (bIsCheck) return true;

			std::memset(cNpcName, 0, sizeof(cNpcName));
			if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
				strcpy(cNpcName, "Guard-Aresden");
			else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
				strcpy(cNpcName, "Guard-Elvine");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
				strcpy(cNpcName, "Guard-Neutral");

			iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {

			}
			else {
				std::memset(cNpcWaypoint, 0, sizeof(cNpcWaypoint));
				std::memset(cName, 0, sizeof(cName));
				std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM,
					&tX, &tY, cNpcWaypoint, 0, 0, -1, false, true) == false) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				}
				else {
					if (m_pEntityManager != 0) m_pEntityManager->bSetNpcAttackMode(cName, iClientH, DEF_OWNERTYPE_PLAYER, true);
				}
			}
		}
	}
	return false;
}

bool CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[sOwnerH] == 0) return false;

	if (iClientH == sOwnerH) return true;

	if (m_pClientList[iClientH]->m_cSide == 0) {
		if (m_pClientList[sOwnerH]->m_iPKCount != 0)
			return true;
		else return false;
	}
	else {
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
			if (m_pClientList[sOwnerH]->m_cSide == 0) {
				if (m_pClientList[sOwnerH]->m_iPKCount != 0)
					return true;
				else return false;
			}
			else return true;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0)
				return true;
			else return false;
		}
	}

	return false;
}


void CGame::PoisonEffect(int iClientH, int iV1)
{
	int iPoisonLevel, iDamage, iPrevHP, iProb;

	if (m_pClientList[iClientH] == 0)     return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

	iDamage = iDice(1, iPoisonLevel);

	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);


	iProb = m_pClientList[iClientH]->m_cSkillMastery[23] - 10 + m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (iDice(1, 100) <= static_cast<uint32_t>(iProb)) {
		m_pClientList[iClientH]->m_bIsPoisoned = false;
		SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, false); // remove poison aura after effect complete
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::Poison, 0, 0, 0);
	}
}
bool CGame::bCheckResistingPoisonSuccess(short sOwnerH, char cOwnerType)
{
	int iResist, iResult;

	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return false;
		iResist = m_pClientList[sOwnerH]->m_cSkillMastery[23] + m_pClientList[sOwnerH]->m_iAddPR;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return false;
		iResist = 0;
		break;
	}

	iResult = iDice(1, 100);
	if (iResult >= iResist)
		return false;

	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sOwnerH, 23, 1);

	return true;
}

void CGame::CheckDayOrNightMode()
{
	SYSTEMTIME SysTime;
	char cPrevMode;

	// DEBUG: Force night mode for testing light effects
	// Set to 0 to use normal day/night cycle, 1 for forced day, 2 for forced night
	constexpr int DEBUG_FORCE_TIME = 0;

	cPrevMode = m_cDayOrNight;

	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= m_iNighttimeDuration)
		m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	if (cPrevMode != m_cDayOrNight) {
		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
				if ((m_pClientList[i]->m_cMapIndex >= 0) &&
					(m_pMapList[m_pClientList[i]->m_cMapIndex] != 0) &&
					(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == false))
					SendNotifyMsg(0, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, 0, 0, 0);
			}
	}
}


void CGame::SetPlayerReputation(int iClientH, char* pMsg, char cValue, size_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cName[DEF_CHARNAME], cBuff[256];
	

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 40) return;

	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, 0, 0, 0);
		return;
	}
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTRATING, 0, 0, 0, 0);
		return;
	}

	std::memset(cName, 0, sizeof(cName));
	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	token = strtok(cBuff, seps);
	token = strtok(NULL, seps);

	if (token != 0) {
		// token
		if (strlen(token) > DEF_CHARNAME - 1)
			memcpy(cName, token, DEF_CHARNAME - 1);
		else memcpy(cName, token, strlen(token));

		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (_strnicmp(m_pClientList[i]->m_cCharName, cName, DEF_CHARNAME - 1) == 0)) {

				if (i != iClientH) {
					if (cValue == 0)
						m_pClientList[i]->m_iRating--;
					else if (cValue == 1)
						m_pClientList[i]->m_iRating++;

					if (m_pClientList[i]->m_iRating > 500)  m_pClientList[i]->m_iRating = 500;
					if (m_pClientList[i]->m_iRating < -500) m_pClientList[i]->m_iRating = -500;
					m_pClientList[iClientH]->m_iTimeLeft_Rating = 20 * 60;

					SendNotifyMsg(0, i, DEF_NOTIFY_RATINGPLAYER, cValue, 0, 0, cName);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_RATINGPLAYER, cValue, 0, 0, cName);

					return;
				}
			}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cName);
	}

	return;
}

bool CGame::bReadNotifyMsgListFile(char* cFn)
{
	FILE* pFile;
	HANDLE hFile;
	uint32_t  dwFileSize;
	char* cp, * token, cReadMode;
	char seps[] = "=\t\n;";

	cReadMode = 0;
	m_iTotalNoticeMsg = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		PutLogList("(!) Notify Message list file not found!...");
		return false;
	}
	else {
		PutLogList("(!) Reading Notify Message list file...");
		cp = new char[dwFileSize + 2];
		std::memset(cp, 0, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok(cp, seps);
		while (token != 0) {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					for(int i = 0; i < DEF_MAXNOTIFYMSGS; i++)
						if (m_pNoticeMsgList[i] == 0) {
							m_pNoticeMsgList[i] = new class CMsg;
							m_pNoticeMsgList[i]->bPut(0, token, strlen(token), 0, 0);
							m_iTotalNoticeMsg++;
							goto LNML_NEXTSTEP1;
						}
				LNML_NEXTSTEP1:
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "notify_msg", 10) == 0) cReadMode = 1;
			}

			token = strtok(NULL, seps);
		}

		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}
void CGame::NoticeHandler()
{
	char  cTemp, cBuffer[1000], cKey;
	size_t dwSize = 0;
	uint32_t dwTime = GameClock::GetTimeMS();
	int iMsgIndex, iTemp;

	if (m_iTotalNoticeMsg <= 1) return;

	if ((dwTime - m_dwNoticeTime) > DEF_NOTICETIME) {
		m_dwNoticeTime = dwTime;
		do {
			iMsgIndex = iDice(1, m_iTotalNoticeMsg) - 1;
		} while (iMsgIndex == m_iPrevSendNoticeMsg);

		m_iPrevSendNoticeMsg = iMsgIndex;

		std::memset(cBuffer, 0, sizeof(cBuffer));
		if (m_pNoticeMsgList[iMsgIndex] != 0) {
			m_pNoticeMsgList[iMsgIndex]->Get(&cTemp, cBuffer, &dwSize, &iTemp, &cKey);
		}

		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != 0) {
				SendNotifyMsg(0, i, DEF_NOTIFY_NOTICEMSG, 0, 0, 0, cBuffer);
			}
	}
}


void CGame::ResponseSavePlayerDataReplyHandler(char* pData, size_t dwMsgSize)
{
	char* cp, cCharName[DEF_CHARNAME];


	std::memset(cCharName, 0, sizeof(cCharName));

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader));
	memcpy(cCharName, cp, DEF_CHARNAME - 1);

	for(int i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			if (_strnicmp(m_pClientList[i]->m_cCharName, cCharName, DEF_CHARNAME - 1) == 0) {
				SendNotifyMsg(0, i, DEF_NOTIFY_SERVERCHANGE, 0, 0, 0, 0);
			}
		}
}

void CGame::CalcExpStock(int iClientH)
{
	bool bIsLevelUp;
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;
	//if ((m_pClientList[iClientH]->m_iLevel >= m_iMaxLevel) && (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_iMaxLevel])) return;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) {
		m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}

	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;

	if (bCheckLimitedUser(iClientH) == false) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXP, 0, 0, 0, 0);
	}
	bIsLevelUp = bCheckLevelUp(iClientH);

	if ((bIsLevelUp) && (m_pClientList[iClientH]->m_iLevel <= 5)) {
		// Gold .  1~5 100 Gold .
		pItem = new CItem;
		if (_bInitItemAttr(pItem, hb::item::ItemId::Gold) == false) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (uint32_t)100000;
		bAddItem(iClientH, pItem, 0);
	}

	if ((bIsLevelUp) && (m_pClientList[iClientH]->m_iLevel > 5) && (m_pClientList[iClientH]->m_iLevel <= 20)) {
		// Gold .  5~20 300 Gold .
		pItem = new CItem;
		if (_bInitItemAttr(pItem, hb::item::ItemId::Gold) == false) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (uint32_t)100000;
		bAddItem(iClientH, pItem, 0);
	}
}

void CGame::___RestorePlayerRating(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iRating < -10000) m_pClientList[iClientH]->m_iRating = 0;
	if (m_pClientList[iClientH]->m_iRating > 10000) m_pClientList[iClientH]->m_iRating = 0;
}

int CGame::iGetExpLevel(uint32_t iExp)
{
	

	for(int i = 1; i < 1000; i++)
		if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i + 1] > iExp)) return i;

	return 0;
}


void CGame::UserCommand_BanGuildsman(int iClientH, char* pData, size_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cTargetName[11], cBuff[256];
	

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;

	if (m_pClientList[iClientH]->m_iGuildRank != 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, 0, 0, 0, 0);
		return;
	}

	std::memset(cTargetName, 0, sizeof(cTargetName));
	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	token = strtok(cBuff, seps);
	token = strtok(NULL, seps);

	if (token != 0) {
		if (strlen(token) > DEF_CHARNAME - 1)
			memcpy(cTargetName, token, DEF_CHARNAME - 1);
		else memcpy(cTargetName, token, strlen(token));

		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (_strnicmp(m_pClientList[i]->m_cCharName, cTargetName, DEF_CHARNAME - 1) == 0)) {

				if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0) {

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTBANGUILDMAN, 0, 0, 0, 0);
					return;
				}
				//bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);

				SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, 0, 0, 0);

				std::memset(m_pClientList[i]->m_cGuildName, 0, sizeof(m_pClientList[i]->m_cGuildName));
				strcpy(m_pClientList[i]->m_cGuildName, "NONE");
				m_pClientList[i]->m_iGuildRank = -1;
				m_pClientList[i]->m_iGuildGUID = -1;

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SUCCESSBANGUILDMAN, 0, 0, 0, 0);

				SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_BANGUILD, 0, 0, 0, 0);

				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);

				return;
			}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cTargetName);
	}

	return;
}


void CGame::UserCommand_DissmissGuild(int iClientH, char* pData, size_t dwMsgSize)
{

}

void CGame::RequestCreateNewGuild(int iClientH, char* pData)
{
	char cFileName[255];
	char cTxt[500];
	char cTxt2[100];
	char cGuildMasterName[DEF_CHARNAME], cGuildLocation[11], cDir[255], cGuildName[21];
	char* cp;
	uint32_t* dwp, dwGuildGUID;
	SYSTEMTIME SysTime;
	FILE* pFile;

	if (m_pClientList[iClientH] == 0) return;
	std::memset(cFileName, 0, sizeof(cFileName));
	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cTxt2, 0, sizeof(cTxt2));
	std::memset(cDir, 0, sizeof(cDir));
	std::memset(cGuildMasterName, 0, sizeof(cGuildMasterName));
	std::memset(cGuildName, 0, sizeof(cGuildName));
	std::memset(cGuildLocation, 0, sizeof(cGuildLocation));

	cp = (char*)pData;

	memcpy(cGuildMasterName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	memcpy(cGuildLocation, cp, 10);
	cp += 10;

	dwp = (uint32_t*)cp;
	dwGuildGUID = *dwp;
	cp += 4;

	strcat(cFileName, "Guilds");
	strcat(cFileName, "\\");
	std::snprintf(cTxt2, sizeof(cTxt2), "AscII%d", *cGuildName);
	strcat(cFileName, cTxt2);
	strcat(cDir, cFileName);
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cGuildName);
	strcat(cFileName, ".txt");

#ifdef _WIN32
	_mkdir("Guilds");
	_mkdir(cDir);
#endif

	pFile = fopen(cFileName, "rt");
	if (pFile != 0) {
		std::snprintf(cTxt2, sizeof(cTxt2), "(X) Cannot create new guild - Already existing guild name: Name(%s)", cFileName);
		PutLogList(cTxt2);

		ResponseCreateNewGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
		fclose(pFile);
	}
	else {
		pFile = fopen(cFileName, "wt");
		if (pFile == 0) {
			std::snprintf(cTxt2, sizeof(cTxt2), "(X) Cannot create new guild - cannot create file : Name(%s)", cFileName);
			PutLogList(cTxt2);

			ResponseCreateNewGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
		}
		else {
			std::snprintf(cTxt2, sizeof(cTxt2), "(O) New guild created : Name(%s)", cFileName);
			PutLogList(cTxt2);

			std::memset(cTxt2, 0, sizeof(cTxt2));
			std::memset(cTxt, 0, sizeof(cTxt));
			GetLocalTime(&SysTime);

			std::snprintf(cTxt, sizeof(cTxt), ";Guild file - Updated %4d/%2d/%2d/%2d/%2d", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
			strcat(cTxt, "\n");
			strcat(cTxt, ";Just created\n\n");

			strcat(cTxt, "[GUILD-INFO]\n\n");

			strcat(cTxt, "guildmaster-name     = ");
			strcat(cTxt, cGuildMasterName);
			strcat(cTxt, "\n");

			strcat(cTxt, "guild-GUID           = ");
			std::snprintf(cTxt2, sizeof(cTxt2), "%d", dwGuildGUID);
			strcat(cTxt, cTxt2);
			strcat(cTxt, "\n");

			strcat(cTxt, "guild-location       = ");
			strcat(cTxt, cGuildLocation);
			strcat(cTxt, "\n\n");

			strcat(cTxt, "[GUILDSMAN]\n\n");

			fwrite(cTxt, 1, strlen(cTxt), pFile);

			ResponseCreateNewGuildHandler(cGuildMasterName, 1); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
			fclose(pFile);
		}
	}
	/*switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, 0);
		delete m_pClientList[iClientH];
		m_pClientList[iClientH] = 0;
		return;
	}*/
}

void CGame::RequestDisbandGuild(int iClientH, char* pData)
{
	char cTemp[500];
	char* cp;
	char cFileName[255], cTxt[100], cDir[100];
	char cGuildMasterName[DEF_CHARNAME], cGuildName[21];
	FILE* pFile;

	if (m_pClientList[iClientH] == 0) return;
	std::memset(cFileName, 0, sizeof(cFileName));
	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cDir, 0, sizeof(cDir));
	std::memset(cTemp, 0, sizeof(cTemp));
	std::memset(cGuildMasterName, 0, sizeof(cGuildMasterName));
	std::memset(cGuildName, 0, sizeof(cGuildName));

	cp = (char*)(pData);
	memcpy(cGuildMasterName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	strcat(cFileName, "Guilds");
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	std::snprintf(cTxt, sizeof(cTxt), "AscII%d", *cGuildName);
	strcat(cFileName, cTxt);
	strcat(cDir, cFileName);
	strcat(cFileName, "\\");
	strcat(cFileName, "\\");
	strcat(cFileName, cGuildName);
	strcat(cFileName, ".txt");

	pFile = fopen(cFileName, "rt");
	if (pFile != 0) {
		fclose(pFile);
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(O) Disband Guild - Deleting guild file... : Name(%s)", cFileName);
		PutLogList(G_cTxt);
		if (DeleteFile(cFileName) != 0) {
			ResponseDisbandGuildHandler(cGuildMasterName, 1); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16, DEF_USE_ENCRYPTION);
		}
		else {

			ResponseDisbandGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16, DEF_USE_ENCRYPTION);
		}
	}
	else {

		ResponseDisbandGuildHandler(cGuildMasterName, 0); //iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, 16, DEF_USE_ENCRYPTION);
	}

	/*switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, 0);
		delete m_pClientList[iClientH];
		m_pClientList[iClientH] = 0;
		return;
	}*/
}


int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, CItem* pItem, int iDifficulty, uint32_t dwLastTime)
{
	int iDynamicHandle;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == 0) return 0;
	if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == false) return 0;

	for(int i = 1; i < DEF_MAXFISHS; i++)
		if (m_pFish[i] == 0) {
			m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
			if (m_pFish[i] == 0) return 0;

			// Dynamic Object . Owner Fish  .
			switch (pItem->m_sIDnum) {
			case 101:
			case 102:
			case 103:
			case 570:
			case 571:
			case 572:
			case 573:
			case 574:
			case 575:
			case 576:
			case 577:
				iDynamicHandle = iAddDynamicObjectList(i, 0, DEF_DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
				break;
			default:
				iDynamicHandle = iAddDynamicObjectList(i, 0, DEF_DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
				break;
			}

			if (iDynamicHandle == 0) {
				delete m_pFish[i];
				m_pFish[i] = 0;
				return 0;
			}
			m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
			m_pMapList[cMapIndex]->m_iCurFish++;

			return i;
		}

	return 0;
}


bool CGame::bDeleteFish(int iHandle, int iDelMode)
{
	int iH;
	uint32_t dwTime;

	if (m_pFish[iHandle] == 0) return false;

	dwTime = GameClock::GetTimeMS();

	// DynamicObject .
	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;

	if (m_pDynamicObjectList[iH] != 0) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, 0, (short)0);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = 0;
	}

	for(int i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
			SendNotifyMsg(0, i, DEF_NOTIFY_FISHCANCELED, iDelMode, 0, 0, 0);
			ClearSkillUsingStatus(i);
		}
	}

	delete m_pFish[iHandle];
	m_pFish[iHandle] = 0;

	return true;
}


int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
	
	short sDistX, sDistY;

	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return 0;

	for(int i = 1; i < DEF_MAXDYNAMICOBJECTS; i++)
		if (m_pDynamicObjectList[i] != 0) {
			sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
			sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);

			if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) &&
				((m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISHOBJECT)) &&
				(sDistX <= 2) && (sDistY <= 2)) {
				// .       Fish  .

				if (m_pFish[m_pDynamicObjectList[i]->m_sOwner] == 0) return 0;
				if (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_sEngagingCount >= DEF_MAXENGAGINGFISH) return 0;

				if (m_pClientList[iClientH]->m_iAllocatedFish != 0) return 0;
				if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
				m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
				m_pClientList[iClientH]->m_iFishChance = 1;
				m_pClientList[iClientH]->m_bSkillUsingStatus[1] = true;

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice / 2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
					m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);

				m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_sEngagingCount++;

				return i;
			}
		}

	return 0;
}

void CGame::FishProcessor()
{
	int iSkillLevel, iResult, iChangeValue;

	for(int i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete) &&
			(m_pClientList[i]->m_iAllocatedFish != 0)) {

			if (m_pFish[m_pClientList[i]->m_iAllocatedFish] == 0) break;

			iSkillLevel = m_pClientList[i]->m_cSkillMastery[1];
			iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
			if (iSkillLevel <= 0) iSkillLevel = 1;

			iChangeValue = iSkillLevel / 10;
			if (iChangeValue <= 0) iChangeValue = 1;
			iChangeValue = iDice(1, iChangeValue);

			iResult = iDice(1, 100);
			if (iSkillLevel > iResult) {
				m_pClientList[i]->m_iFishChance += iChangeValue;
				if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

				SendNotifyMsg(0, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, 0, 0, 0);
			}
			else if (iSkillLevel < iResult) {
				m_pClientList[i]->m_iFishChance -= iChangeValue;
				if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

				SendNotifyMsg(0, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, 0, 0, 0);
			}
		}
	}
}


void CGame::ReqGetFishThisTimeHandler(int iClientH)
{
	int iResult, iFishH;
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == 0) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == 0) return;

	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = false;

	iResult = iDice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) {

		GetExp(iClientH, iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5)); //m_pClientList[iClientH]->m_iExpStock += iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		CalculateSSN_SkillIndex(iClientH, 1, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);

		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = 0;

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY,
			pItem);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4 color

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FISHSUCCESS, 0, 0, 0, 0);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = 0;

		bDeleteFish(iFishH, 1);
		return;
	}

	m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_FISHFAIL, 0, 0, 0, 0);

	m_pClientList[iClientH]->m_iAllocatedFish = 0;
}


void CGame::FishGenerator()
{
	int iP, tX, tY, iRet;
	char  cItemName[DEF_ITEMNAME];
	int sDifficulty;
	uint32_t dwLastTime;
	CItem* pItem;

	for(int i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1, 10) == 5) && (m_pMapList[i] != 0) &&
			(m_pMapList[i]->m_iCurFish < m_pMapList[i]->m_iMaxFish)) {

			iP = iDice(1, m_pMapList[i]->m_iTotalFishPoint) - 1;
			if ((m_pMapList[i]->m_FishPointList[iP].x == -1) || (m_pMapList[i]->m_FishPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_FishPointList[iP].x + (iDice(1, 3) - 2);
			tY = m_pMapList[i]->m_FishPointList[iP].y + (iDice(1, 3) - 2);

			pItem = new CItem;
			if (pItem == 0) break;

			std::memset(cItemName, 0, sizeof(cItemName));
			switch (iDice(1, 9)) {
			case 1:   strcpy(cItemName, "RedCarp"); sDifficulty = iDice(1, 10) + 20; break;
			case 2:   strcpy(cItemName, "GreenCarp"); sDifficulty = iDice(1, 5) + 10; break;
			case 3:   strcpy(cItemName, "GoldCarp"); sDifficulty = iDice(1, 10) + 1;  break;
			case 4:   strcpy(cItemName, "CrucianCarp"); sDifficulty = 1;  break;
			case 5:   strcpy(cItemName, "BlueSeaBream"); sDifficulty = iDice(1, 15) + 1;  break;
			case 6:   strcpy(cItemName, "RedSeaBream"); sDifficulty = iDice(1, 18) + 1;  break;
			case 7:   strcpy(cItemName, "Salmon"); sDifficulty = iDice(1, 12) + 1;  break;
			case 8:   strcpy(cItemName, "GrayMullet"); sDifficulty = iDice(1, 10) + 1;  break;
			case 9:
				switch (iDice(1, 150)) {
				case 1:
				case 2:
				case 3:
					strcpy(cItemName, "PowerGreenPotion");
					sDifficulty = iDice(5, 4) + 30;
					break;

				case 10:
				case 11:
					strcpy(cItemName, "SuperPowerGreenPotion");
					sDifficulty = iDice(5, 4) + 50;
					break;

				case 20:
					strcpy(cItemName, "Dagger+2");
					sDifficulty = iDice(5, 4) + 30;
					break;

				case 30:
					strcpy(cItemName, "LongSword+2");
					sDifficulty = iDice(5, 4) + 40;
					break;

				case 40:
					strcpy(cItemName, "Scimitar+2");
					sDifficulty = iDice(5, 4) + 50;
					break;

				case 50:
					strcpy(cItemName, "Rapier+2");
					sDifficulty = iDice(5, 4) + 60;
					break;

				case 60:
					strcpy(cItemName, "Flameberge+2");
					sDifficulty = iDice(5, 4) + 60;
					break;

				case 70:
					strcpy(cItemName, "WarAxe+2");
					sDifficulty = iDice(5, 4) + 50;
					break;

				case 90:
					strcpy(cItemName, "Ruby");
					sDifficulty = iDice(5, 4) + 40;
					break;

				case 95:
					strcpy(cItemName, "Diamond");
					sDifficulty = iDice(5, 4) + 40;
					break;
				}
				break;
			}
			dwLastTime = (60000 * 10) + (iDice(1, 3) - 1) * (60000 * 10);

			if (_bInitItemAttr(pItem, cItemName)) {
				iRet = iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime);
			}
			else {
				delete pItem;
				pItem = 0;
			}
		}
	}
}


int CGame::_iCalcPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
	int iRet;
	class CTile* pTile;

	if ((cMapIndex < 0) || (cMapIndex > DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == 0) return 0;

	iRet = 0;
	for(int ix = dX - cRadius; ix <= dX + cRadius; ix++)
		for(int iy = dY - cRadius; iy <= dY + cRadius; iy++) {
			if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) ||
				(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			}
			else {
				pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + ix + iy * m_pMapList[cMapIndex]->m_sSizeY);
				if ((pTile->m_sOwner != 0) && (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER))
					iRet++;
			}
		}

	return iRet;
}


void CGame::WhetherProcessor()
{
	char cPrevMode;
	int j;
	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	for(int i = 0; i < DEF_MAXMAPS; i++) {
		if ((m_pMapList[i] != 0) && (m_pMapList[i]->m_bIsFixedDayMode == false)) {
			cPrevMode = m_pMapList[i]->m_cWhetherStatus;
			if (m_pMapList[i]->m_cWhetherStatus != 0) {
				if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime)
					m_pMapList[i]->m_cWhetherStatus = 0;
			}
			else {
				if (iDice(1, 300) == 13) {
					m_pMapList[i]->m_cWhetherStatus = static_cast<char>(iDice(1, 3)); //This looks better or else we only get snow :(
					//m_pMapList[i]->m_cWhetherStatus = iDice(1,3)+3; <- This original code looks fucked
					m_pMapList[i]->m_dwWhetherStartTime = dwTime;
					m_pMapList[i]->m_dwWhetherLastTime = 60000 * 3 + 60000 * iDice(1, 7);
				}
			}

			if (m_pMapList[i]->m_bIsSnowEnabled) {
				m_pMapList[i]->m_cWhetherStatus = static_cast<char>(iDice(1, 3) + 3);
				m_pMapList[i]->m_dwWhetherStartTime = dwTime;
				m_pMapList[i]->m_dwWhetherLastTime = 60000 * 3 + 60000 * iDice(1, 7);
			}

			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) {
				for (j = 1; j < DEF_MAXCLIENTS; j++)
					if ((m_pClientList[j] != 0) && (m_pClientList[j]->m_bIsInitComplete) && (m_pClientList[j]->m_cMapIndex == i))
						SendNotifyMsg(0, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, 0, 0, 0);
			}
		}
	} //for Loop
}


void CGame::FightzoneReserveProcessor()
{
}

/*********************************************************************************************************************
**  int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)										**
**  description			:: checks for a weather bonus when magic is cast											**
**  last updated		:: November 20, 2004; 10:34 PM; Hypnotoad													**
**	return value		:: int																						**
*********************************************************************************************************************/
int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
	int iWheatherBonus;

	iWheatherBonus = 0;
	switch (cWheatherStatus) {
	case 0: break;
	case 1:
	case 2:
	case 3:
		switch (sType) {
		case 10:
		case 37:
		case 43:
		case 51:
			iWheatherBonus = 1;
			break;

		case 20:
		case 30:
			iWheatherBonus = -1;
			break;
		}
		break;
	}
	return iWheatherBonus;
}


int CGame::iGetPlayerRelationship(int iClientH, int iOpponentH)
{
	int iRet;

	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	if (m_pClientList[iOpponentH] == 0) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == false) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (memcmp(m_pClientList[iOpponentH]->m_cLocation, "NONE", 4) != 0)) {
			iRet = 7;
		}
		else iRet = 2;
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0))
			iRet = 6;
		else iRet = 2;
	}
	else {
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[iOpponentH]->m_cSide != 0)) {
				// 0(Traveler)  .
				iRet = 2;
			}
			else {
				iRet = 0;
			}
		}
		else {
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
				if (m_pClientList[iOpponentH]->m_iGuildRank == 0)
					iRet = 5;
				else iRet = 3;
			}
			else
				if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
					(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
					(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
					(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
					iRet = 4;
				}
				else iRet = 1;
		}
	}

	return iRet;
}

EntityRelationship CGame::GetPlayerRelationship(int iOwnerH, int iViewerH)
{
	if (m_pClientList[iOwnerH] == 0 || m_pClientList[iViewerH] == 0)
		return EntityRelationship::Neutral;

	// Viewer is PK  everyone is enemy to them
	if (m_pClientList[iViewerH]->m_iPKCount != 0)
		return EntityRelationship::Enemy;

	// Target is PK
	if (m_pClientList[iOwnerH]->m_iPKCount != 0)
		return EntityRelationship::PK;

	// No faction = neutral
	if (m_pClientList[iOwnerH]->m_cSide == 0 || m_pClientList[iViewerH]->m_cSide == 0)
		return EntityRelationship::Neutral;

	// Same faction = friendly
	if (m_pClientList[iOwnerH]->m_cSide == m_pClientList[iViewerH]->m_cSide)
		return EntityRelationship::Friendly;

	// Different factions
	if (m_bIsCrusadeMode)
		return EntityRelationship::Enemy;

	// Both are combatants (non-hunter) = enemy
	if (!m_pClientList[iViewerH]->m_bIsPlayerCivil && !m_pClientList[iOwnerH]->m_bIsPlayerCivil)
		return EntityRelationship::Enemy;

	return EntityRelationship::Neutral;
}

int CGame::iGetMapIndex(char* pMapName)
{
	int iMapIndex;
	char cTmpName[256];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);

	iMapIndex = -1;
	for(int i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) {
			if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0)
				iMapIndex = i;
		}

	return iMapIndex;
}


int CGame::_iForcePlayerDisconect(int iNum)
{
	int iCnt;

	iCnt = 0;
	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsInitComplete)
				DeleteClient(i, true, true);
			else DeleteClient(i, false, false);
			iCnt++;
			if (iCnt >= iNum) break;
		}

	return iCnt;
}

void CGame::SpecialEventHandler()
{
	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	if ((dwTime - m_dwSpecialEventTime) < DEF_SPECIALEVENTTIME) return; // DEF_SPECIALEVENTTIME
	m_dwSpecialEventTime = dwTime;
	m_bIsSpecialEventTime = true;

	switch (iDice(1, 180)) {
	case 98: m_cSpecialEventType = 2; break; // 30 1 1/30
	default: m_cSpecialEventType = 1; break;
	}
}

void CGame::ToggleSafeAttackModeHandler(int iClientH) //v1.1
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_bIsKilled) return;

	if (m_pClientList[iClientH]->m_bIsSafeAttackMode)
		m_pClientList[iClientH]->m_bIsSafeAttackMode = false;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = true;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SAFEATTACKMODE, 0, 0, 0, 0);
}


void CGame::ForceDisconnectAccount(char* pAccountName, uint16_t wCount)
{
	

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (_strnicmp(m_pClientList[i]->m_cAccountName, pAccountName, DEF_ACCOUNT_NAME - 1) == 0)) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Force disconnect account: CharName(%s) AccntName(%s) Count(%d)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, wCount);
			PutLogList(G_cTxt);

			//DeleteClient(i, true, true);

			//v1.4312
			SendNotifyMsg(0, i, DEF_NOTIFY_FORCEDISCONN, wCount, 0, 0, 0);
		}
}

bool CGame::bOnClose()
{
	if (m_bIsServerShutdowned == false)
	{
#ifdef _WIN32
		if (MessageBox(0, "Player data not saved! Shutdown server now?", m_cRealmName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return true;
		return false;
#else
		return false;
#endif
	}
	else return true;

	return false;
}

// 05/24/2004 - Hypnotoad - Hammer and Wand train to 100% fixed
void CGame::_CheckAttackType(int iClientH, short* spType)
{
	uint16_t wType;

	if (m_pClientList[iClientH] == 0) return;
	wType = m_pClientList[iClientH]->m_appearance.iWeaponType;

	switch (*spType) {
	case 2:
		// Effect  .
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		if (wType < 40) *spType = 1;
		break;

	case 20:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100) *spType = 1;
		break;

	case 21:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100) *spType = 1;
		break;

	case 22:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100) *spType = 1;
		break;

	case 23:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100) *spType = 1;
		break;

	case 24:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100) *spType = 1;
		break;

	case 25:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		if (wType < 40) *spType = 1;
		break;

	case 26:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100) *spType = 1;
		break;

	case 27:
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100) *spType = 1;
		break;
	}
}

void CGame::ReqCreatePortionHandler(int iClientH, char* pData)
{
	char cI[6], cPortionName[DEF_ITEMNAME];
	int    iRet, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
	short sItemIndex[6], sTemp;
	short  sItemNumber[6], sItemArray[12];
	bool   bDup, bFlag;
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for(int i = 0; i < 6; i++) {
		cI[i] = -1;
		sItemIndex[i] = -1;
		sItemNumber[i] = 0;
	}

	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandCommonItems>(
		pData, sizeof(hb::net::PacketCommandCommonItems));
	if (!pkt) return;
	for(int i = 0; i < 6; i++) {
		cI[i] = static_cast<char>(pkt->item_ids[i]);
	}

	for(int i = 0; i < 6; i++) {
		if (cI[i] >= hb::limits::MaxItems) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == 0)) return;
	}

	for(int i = 0; i < 6; i++)
		if (cI[i] >= 0) {
			bDup = false;
			for (j = 0; j < 6; j++)
				if (sItemIndex[j] == cI[i]) {
					sItemNumber[j]++;
					bDup = true;
				}
			if (bDup == false) {
				for (j = 0; j < 6; j++)
					if (sItemIndex[j] == -1) {
						sItemIndex[j] = cI[i];
						sItemNumber[j]++;
						goto RCPH_LOOPBREAK;
					}
			RCPH_LOOPBREAK:;
			}
		}

	for(int i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) {
			if (sItemIndex[i] < 0) return;
			if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= hb::limits::MaxItems)) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == 0) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < static_cast<uint32_t>(sItemNumber[i])) return;
		}

	// . Bubble Sort
	bFlag = true;
	while (bFlag) {
		bFlag = false;
		for(int i = 0; i < 5; i++)
			if ((sItemIndex[i] != -1) && (sItemIndex[i + 1] != -1)) {
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
					(m_pClientList[iClientH]->m_pItemList[sItemIndex[i + 1]]->m_sIDnum)) {
					sTemp = sItemIndex[i + 1];
					sItemIndex[i + 1] = sItemIndex[i];
					sItemIndex[i] = sTemp;
					sTemp = sItemNumber[i + 1];
					sItemNumber[i + 1] = sItemNumber[i];
					sItemNumber[i] = sTemp;
					bFlag = true;
				}
			}
	}

	j = 0;
	for(int i = 0; i < 6; i++) {
		if (sItemIndex[i] != -1)
			sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j + 1] = sItemNumber[i];
		j += 2;
	}

	std::memset(cPortionName, 0, sizeof(cPortionName));

	for(int i = 0; i < DEF_MAXPORTIONTYPES; i++)
		if (m_pPortionConfigList[i] != 0) {
			bFlag = false;
			for (j = 0; j < 12; j++)
				if (m_pPortionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = true;

			if (bFlag == false) {
				std::memset(cPortionName, 0, sizeof(cPortionName));
				memcpy(cPortionName, m_pPortionConfigList[i]->m_cName, DEF_ITEMNAME - 1);
				iSkillLimit = m_pPortionConfigList[i]->m_iSkillLimit;
				iDifficulty = m_pPortionConfigList[i]->m_iDifficulty;
			}
		}

	if (strlen(cPortionName) == 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOMATCHINGPORTION, 0, 0, 0, 0);
		return;
	}

	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[12];
	if (iSkillLimit > iSkillLevel) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_LOWPORTIONSKILL, 0, 0, 0, cPortionName);
		return;
	}

	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;

	iResult = iDice(1, 100);
	if (iResult > iSkillLevel) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PORTIONFAIL, 0, 0, 0, cPortionName);
		return;
	}

	CalculateSSN_SkillIndex(iClientH, 12, 1);

	if (strlen(cPortionName) != 0) {
		pItem = 0;
		pItem = new CItem;
		if (pItem == 0) return;

		for(int i = 0; i < 6; i++)
			if (sItemIndex[i] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->GetItemType() == ItemType::Consume)
					// v1.41 !!!
					SetItemCount(iClientH, sItemIndex[i], //     m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName,
						m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
				else ItemDepleteHandler(iClientH, sItemIndex[i], false);
			}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PORTIONSUCCESS, 0, 0, 0, cPortionName);
		m_pClientList[iClientH]->m_iExpStock += iDice(1, (iDifficulty / 3));

		if ((_bInitItemAttr(pItem, cPortionName))) {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}

				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
					m_pClientList[iClientH]->m_sY, pItem);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}
			}
		}
		else {
			delete pItem;
			pItem = 0;
		}
	}
}

// char * pContents, * token, cTxt[120];
// char seps[] = "= \t\r\n";
// char cReadModeA = 0;
// char cReadModeB = 0;
// int  iPortionConfigListIndex = 0;
//	pContents = new char[dwMsgSize+1];
//	std::memset(pContents, 0, dwMsgSize+1);
//	memcpy(pContents, pData, dwMsgSize);
//	while( token != 0 ) {
//		if (cReadModeA != 0) {
//			switch (cReadModeA) {
//			case 1:
//				switch (cReadModeB) {
//				case 1:
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
//						delete[] pContents;
//					//						return false;
//					if (m_pPortionConfigList[atoi(token)] != 0) {
//						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate portion number.");
//						delete[] pContents;
//					//						return false;
//					m_pPortionConfigList[atoi(token)] = new class CPortion;
//					iPortionConfigListIndex = atoi(token);
//					cReadModeB = 2;
//					break;
//				case 2:
//					std::memset(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, 0, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
//					memcpy(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
//					cReadModeB = 3;
//					break;
//				default:
// //   m_sArray[0~10]
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//					//						return false;
//					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
//					cReadModeB++;
//					break;
//				case 14:
// //  m_sArray[11]
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//					//						return false;
//					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
//					cReadModeB = 15;
//					break;
//				case 15:
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//					//						return false;
//					m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
//					cReadModeB = 16;
//					break;
//				case 16:
//					if (_bGetIsStringIsNumber(token) == false) {
//						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
//						delete[] pContents;
//					//						return false;
//					m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
//					cReadModeA = 0;
//					cReadModeB = 0;
//					break;
//				break;
//			default: 
//				break;
//		else {
//			if (memcmp(token, "potion", 5) == 0) {
//				cReadModeA = 1;
//				cReadModeB = 1;
////	delete[] pContents;
//	if ((cReadModeA != 0) || (cReadModeB != 0)) {
//		PutLogList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
//		return false;
//	std::snprintf(cTxt, sizeof(cTxt), "(!) POTION(Total:%d) configuration - success!", iPortionConfigListIndex);
//	PutLogList(cTxt);
//	return true;

///		Snoopy: Added Crafting to the same file than potions
void CGame::ReqCreateCraftingHandler(int iClientH, char* pData)
{
	char cI[6], cCraftingName[DEF_ITEMNAME];
	int    iRet, j, iEraseReq, iRiskLevel, iDifficulty, iNeededContrib = 0;
	short sTemp;
	short  sItemIndex[6], sItemPurity[6], sItemNumber[6], sItemArray[12];
	bool   bDup, bFlag, bNeedLog;
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for(int i = 0; i < 6; i++)
	{
		cI[i] = -1;
		sItemIndex[i] = -1;
		sItemNumber[i] = 0;
		sItemPurity[i] = -1;
	}
	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandCommonBuild>(
		pData, sizeof(hb::net::PacketCommandCommonBuild));
	if (!pkt) return;
	for(int i = 0; i < 6; i++) {
		cI[i] = static_cast<char>(pkt->item_ids[i]);
	}

	for(int i = 0; i < 6; i++)
	{
		if (cI[i] >= hb::limits::MaxItems) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == 0)) return;
	}

	for(int i = 0; i < 6; i++)
		if (cI[i] >= 0)
		{
			bDup = false;
			for (j = 0; j < 6; j++)
				if (sItemIndex[j] == cI[i])
				{
					sItemNumber[j]++;
					bDup = true;
				}
			if (bDup == false)
			{
				for (j = 0; j < 6; j++)
					if (sItemIndex[j] == -1)
					{
						sItemIndex[j] = cI[i];
						sItemNumber[j]++;
						goto RCPH_LOOPBREAK;
					}
			RCPH_LOOPBREAK:;
			}
		}


	for(int i = 0; i < 6; i++)
		if (sItemIndex[i] != -1)
		{
			if (sItemIndex[i] < 0) return;
			if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= hb::limits::MaxItems)) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == 0) return;
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < static_cast<uint32_t>(sItemNumber[i])) return;
			sItemPurity[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sItemSpecEffectValue2;
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->GetItemType() == ItemType::None)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
			{
				sItemPurity[i] = 100; // Merien stones considered 100% purity.
			}
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->GetItemType() == ItemType::Consume)
			{
				sItemPurity[i] = -1; // Diamonds / Emeralds.etc.. never have purity
			}
			if (sItemNumber[i] > 1) // No purity for stacked items
			{
				sItemPurity[i] = -1;
			}
			/*std::snprintf(G_cTxt, sizeof(G_cTxt), "Crafting: %d x %s (%d)"
				, sItemNumber[i]
				, m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName
				, m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum);
			PutLogList(G_cTxt);*/

			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->GetItemType() == ItemType::Equip)
				&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->GetEquipPos() == EquipPos::Neck))
			{
				iNeededContrib = 10; // Necks Crafting requires 10 contrib
			}
		}

	// Bubble Sort
	bFlag = true;
	while (bFlag)
	{
		bFlag = false;
		for(int i = 0; i < 5; i++)
			if ((sItemIndex[i] != -1) && (sItemIndex[i + 1] != -1))
			{
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) < (m_pClientList[iClientH]->m_pItemList[sItemIndex[i + 1]]->m_sIDnum))
				{
					sTemp = sItemIndex[i + 1];
					sItemIndex[i + 1] = sItemIndex[i];
					sItemIndex[i] = sTemp;
					sTemp = sItemPurity[i + 1];
					sItemPurity[i + 1] = sItemPurity[i];
					sItemPurity[i] = sTemp;
					sTemp = sItemNumber[i + 1];
					sItemNumber[i + 1] = sItemNumber[i];
					sItemNumber[i] = sTemp;
					bFlag = true;
				}
			}
	}
	j = 0;
	for(int i = 0; i < 6; i++)
	{
		if (sItemIndex[i] != -1)
			sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j + 1] = sItemNumber[i];
		j += 2;
	}

	// Search Crafting you wanna build
	std::memset(cCraftingName, 0, sizeof(cCraftingName));
	for(int i = 0; i < DEF_MAXPORTIONTYPES; i++)
		if (m_pCraftingConfigList[i] != 0)
		{
			bFlag = false;
			for (j = 0; j < 12; j++)
			{
				if (m_pCraftingConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = true; // one item mismatch	
			}
			if (bFlag == false) // good Crafting receipe
			{
				std::memset(cCraftingName, 0, sizeof(cCraftingName));
				memcpy(cCraftingName, m_pCraftingConfigList[i]->m_cName, DEF_ITEMNAME - 1);
				iRiskLevel = m_pCraftingConfigList[i]->m_iSkillLimit;			// % to loose item if crafting fails
				iDifficulty = m_pCraftingConfigList[i]->m_iDifficulty;
			}
		}


	// Check if recipe is OK
	if (strlen(cCraftingName) == 0)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 1, 0, 0, 0); // "There is not enough material"
		return;
	}
	// Check for Contribution
	if (m_pClientList[iClientH]->m_iContribution < iNeededContrib)
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 2, 0, 0, 0); // "There is not enough Contribution Point"	
		return;
	}
	// Check possible Failure
	if (iDice(1, 100) > static_cast<uint32_t>(iDifficulty))
	{
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_FAIL, 3, 0, 0, 0); // "Crafting failed"
		// Remove parts...
		pItem = 0;
		pItem = new CItem;
		if (pItem == 0) return;
		for(int i = 0; i < 6; i++)
			if (sItemIndex[i] != -1)
			{	// Deplete any Merien Stone
				if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->GetItemType() == ItemType::None)
					&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSprite == 6)
					&& (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sSpriteFrame == 129))
				{
					ItemDepleteHandler(iClientH, sItemIndex[i], false);
				}
				else
					// Risk to deplete any other items (not stackable ones) // DEF_ITEMTYPE_CONSUME
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->GetItemType() == ItemType::Equip)
						|| (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->GetItemType() == ItemType::Material))
					{
						if (iDice(1, 100) < static_cast<uint32_t>(iRiskLevel))
						{
							ItemDepleteHandler(iClientH, sItemIndex[i], false);
						}
					}
			}
		return;
	}

	// Purity
	int iPurity, iTot = 0, iCount = 0;
	for(int i = 0; i < 6; i++)
	{
		if (sItemIndex[i] != -1)
		{
			if (sItemPurity[i] != -1)
			{
				iTot += sItemPurity[i];
				iCount++;
			}
		}
	}
	if (iCount == 0)
	{
		iPurity = 20 + iDice(1, 80);			// Wares have random purity (20%..100%)
		bNeedLog = false;
	}
	else
	{
		iPurity = iTot / iCount;
		iTot = (iPurity * 4) / 5;
		iCount = iPurity - iTot;
		iPurity = iTot + iDice(1, iCount);	// Jewel completion depends off Wares purity
		bNeedLog = true;
	}
	if (iNeededContrib != 0)
	{
		iPurity = 0;						// Necks require contribution but no purity/completion
		bNeedLog = true;
	}
	CalculateSSN_SkillIndex(iClientH, 18, 1);

	if (strlen(cCraftingName) != 0)
	{
		pItem = 0;
		pItem = new CItem;
		if (pItem == 0) return;
		for(int i = 0; i < 6; i++)
		{
			if (sItemIndex[i] != -1)
			{
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->GetItemType() == ItemType::Consume)
				{
					SetItemCount(iClientH, sItemIndex[i],
						m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
				}
				else // So if item is not Type 5 (stackable items), you deplete item
				{
					ItemDepleteHandler(iClientH, sItemIndex[i], false);
				}
			}
		}
		if (iNeededContrib != 0)
		{
			m_pClientList[iClientH]->m_iContribution -= iNeededContrib;
			// No known msg to send info to client, so client will compute shown Contrib himself.		
		}

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRAFTING_SUCCESS, 0, 0, 0, 0);

		m_pClientList[iClientH]->m_iExpStock += iDice(2, 100);

		if ((_bInitItemAttr(pItem, cCraftingName)))
		{	// // Snoopy: Added Purity to Oils/Elixirs
			if (iPurity != 0)
			{
				pItem->m_sItemSpecEffectValue2 = iPurity;
				pItem->m_dwAttribute = 1;
			}
			pItem->SetTouchEffectType(TouchEffectType::ID);
			pItem->m_sTouchEffectValue1 = static_cast<short>(iDice(1, 100000));
			pItem->m_sTouchEffectValue2 = static_cast<short>(iDice(1, 100000));
			// pItem->m_sTouchEffectValue3 = GameClock::GetTimeMS();	
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			std::memset(cTemp, 0, sizeof(cTemp));
			std::snprintf(cTemp, sizeof(cTemp), "%d%2d", (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);

			// SNOOPY log anything above WAREs
			if (bNeedLog)
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "PC(%s) Crafting (%s) Purity(%d)"
					, m_pClientList[iClientH]->m_cCharName
					, pItem->m_cName
					, pItem->m_sItemSpecEffectValue2);
				PutLogFileList(G_cTxt);
			}
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq))
			{
				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else
			{
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
					m_pClientList[iClientH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					break;
				}
			}
		}
		else
		{
			delete pItem;
			pItem = 0;
		}
	}
}

void CGame::MineralGenerator()
{
	int iP, tX, tY, iRet;

	for(int i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1, 4) == 1) && (m_pMapList[i] != 0) &&
			(m_pMapList[i]->m_bMineralGenerator) &&
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {

			iP = iDice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
			if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_MineralPointList[iP].x;
			tY = m_pMapList[i]->m_MineralPointList[iP].y;

			iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
	int iDynamicHandle, iMineralType;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == 0) return 0;

	for(int i = 1; i < DEF_MAXMINERALS; i++)
		if (m_pMineral[i] == 0) {
			iMineralType = iDice(1, cLevel);
			m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
			if (m_pMineral[i] == 0) return 0;

			iDynamicHandle = 0;
			switch (iMineralType) {
			case 1:
			case 2:
			case 3:
			case 4:
				iDynamicHandle = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, 0, i);
				break;

			case 5:
			case 6:
				iDynamicHandle = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, 0, i);
				break;

			default:
				iDynamicHandle = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, 0, i);
				break;
			}

			if (iDynamicHandle == 0) {
				delete m_pMineral[i];
				m_pMineral[i] = 0;
				return 0;
			}
			m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
			m_pMineral[i]->m_cMapIndex = cMapIndex;

			switch (iMineralType) {
			case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
			case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
			case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
			case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
			case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
			case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
			default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
			}

			m_pMapList[cMapIndex]->m_iCurMineral++;

			return i;
		}

	return 0;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
{
	short sType;
	uint32_t dwRegisterTime;
	int   iDynamicIndex, iSkillLevel, iResult, iItemID;
	CItem* pItem;
	uint16_t  wWeaponType;

	iItemID = 0;

	if (m_pClientList[iClientH] == 0)  return;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);

	if (m_pClientList[iClientH]->m_status.bInvisibility) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, false);
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, hb::magic::Invisibility);
		m_pClientList[iClientH]->m_cMagicEffectStatus[hb::magic::Invisibility] = 0;
	}

	switch (sType) {
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		wWeaponType = m_pClientList[iClientH]->m_appearance.iWeaponType;
		if (wWeaponType == 25) {
		}
		else return;

		if (!m_pClientList[iClientH]->m_appearance.bIsWalking) return;

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[0];
		if (iSkillLevel == 0) break;

		if (m_pDynamicObjectList[iDynamicIndex] == 0) break;
		iSkillLevel -= m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		iResult = iDice(1, 100);
		if (iResult <= iSkillLevel) {
			CalculateSSN_SkillIndex(iClientH, 0, 1);

			switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) {
			case 1:
				switch (iDice(1, 5)) {
				case 1:
				case 2:
				case 3:
					iItemID = 355; // Coal
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 4:
					iItemID = 357; // IronOre
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 5:
					iItemID = 507; // BlondeStone
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				}
				break;

			case 2:
				switch (iDice(1, 5)) {
				case 1:
				case 2:
					iItemID = 355; // Coal
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 3:
				case 4:
					iItemID = 357; // IronOre
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 5:
					if (iDice(1, 3) == 2) {
						iItemID = 356; // SilverNugget
						m_pClientList[iClientH]->m_iExpStock += iDice(1, 4);
					}
					else {
						iItemID = 507; // BlondeStone
						m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					}
					break;
				}
				break;

			case 3:
				switch (iDice(1, 6)) {
				case 1:
					iItemID = 355; // Coal
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 2:
				case 3:
				case 4:
				case 5:
					iItemID = 357; // IronOre
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 6:
					if (iDice(1, 8) == 3) {
						if (iDice(1, 2) == 1) {
							iItemID = 356; // SilverNugget
							m_pClientList[iClientH]->m_iExpStock += iDice(1, 4);
						}
						else {
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
						}
						break;
					}
					else {
						iItemID = 357; // IronOre
						m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					}
					break;
				}
				break;

			case 4:
				switch (iDice(1, 6)) {
				case 1:
					iItemID = 355; // Coal
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 2:
					if (iDice(1, 3) == 2) {
						iItemID = 356; // SilverNugget
						m_pClientList[iClientH]->m_iExpStock += iDice(1, 4);
					}
					break;
				case 3:
				case 4:
				case 5:
					iItemID = 357; // IronOre
					m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
					break;
				case 6:
					if (iDice(1, 8) == 3) {
						if (iDice(1, 4) == 3) {
							if (iDice(1, 4) < 3) {
								iItemID = 508; // Mithral
								m_pClientList[iClientH]->m_iExpStock += iDice(1, 15);
							}
							else {
								iItemID = 354; // GoldNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(1, 5);
							}
							break;
						}
						else {
							iItemID = 356; // SilverNugget
							m_pClientList[iClientH]->m_iExpStock += iDice(1, 4);
						}
						break;
					}
					else {
						if (iDice(1, 2) == 1) {
							iItemID = 354; // GoldNugget
							m_pClientList[iClientH]->m_iExpStock += iDice(1, 5);
						}
						else {
							iItemID = 357;  // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1, 3);
						}
						break;
					}
					break;
				}
				break;

			case 5:
				switch (iDice(1, 19)) {
				case 3:
					iItemID = 352; // Sapphire
					m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					break;
				default:
					iItemID = 358; // Crystal
					m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					break;
				}
				break;

			case 6:
				switch (iDice(1, 5)) {
				case 1:
					if (iDice(1, 6) == 3) {
						iItemID = 353; // Emerald 
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 4);
					}
					else {
						iItemID = 358; // Crystal
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					}
					break;
				case 2:
					if (iDice(1, 6) == 3) {
						iItemID = 352; // Saphire
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 4);
					}
					else {
						iItemID = 358; // Crystal
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					}
					break;
				case 3:
					if (iDice(1, 6) == 3) {
						iItemID = 351; // Ruby
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 4);
					}
					else {
						iItemID = 358; // Crystal 
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					}
					break;
				case 4:
					iItemID = 358; // Crystal 
					m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					break;
				case 5:
					if (iDice(1, 12) == 3) {
						iItemID = 350; // Diamond
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 5);
					}
					else {
						iItemID = 358; // Crystal
						m_pClientList[iClientH]->m_iExpStock += iDice(2, 3);
					}
					break;
				}
				break;

			}

			pItem = new CItem;
			if (_bInitItemAttr(pItem, iItemID) == false) {
				delete pItem;
			}
			else {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
					m_pClientList[iClientH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
					pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); // v1.4
				// testcode
				// std::snprintf(G_cTxt, sizeof(G_cTxt), "Mining Success: %d", iItemID); 
				// PutLogList(G_cTxt);
			}

			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				// . Delete Mineral
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);

				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = 0;
			}
		}
		break;

	default:
		break;
	}
}

bool CGame::bDeleteMineral(int iIndex)
{
	int iDynamicIndex;
	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	if (m_pMineral[iIndex] == 0) return false;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == 0) return false;

	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex,
		m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY,
		m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, 0, (short)0);
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, true);

	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = 0;

	return true;
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
	char cRewardName[DEF_ITEMNAME], cTargetName[DEF_NPCNAME];
	int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	std::memset(cTargetName, 0, sizeof(cTargetName));
	if (m_pClientList[iClientH] == 0) return;
	switch (iWho) {
	case 1: break;
	case 2:	break;
	case 3:	break;
	case 4:
		iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange);
		break;
	case 5: break;
	case 6:	break;
	case 32: break;
	case 21:
		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange);
		if (iQuestNum >= 1000) return;
		break;
	}

	std::memset(cRewardName, 0, sizeof(cRewardName));
	if (iQuestNum > 0) {
		if (iRewardType > 1) {
			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			case -10: strcpy(cRewardName, "F-"); break;
			}
		}

		m_pClientList[iClientH]->m_iAskedQuest = iQuestNum;
		m_pClientList[iClientH]->m_iQuestRewardType = iRewardType;
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else {
		switch (iQuestNum) {
		case  0: SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (iWho + 130), 0, 0, 0, 0); break;
		case -1:
		case -2:
		case -3:
		case -4: SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, abs(iQuestNum) + 100, 0, 0, 0, 0); break;
		case -5: break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{
	int iItemNum;
	char  cItemColor;
	CItem* pItem;
	short sIDNum;
	uint32_t dwAttr;

	for(int ix = sX - 1; ix <= sX + 1; ix++)
		for(int iy = sY - 1; iy <= sY + 1; iy++) {
			iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);

			switch (iItemNum) {
			case 355:
				pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sIDNum, &cItemColor, &dwAttr);
				if (pItem != 0) delete pItem;
				iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);

				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, cMapIndex,
					ix, iy, sIDNum, 0, cItemColor, dwAttr);
				break;
			}
		}
}


int CGame::_iGetWeaponSkillType(int iClientH)
{
	uint16_t wWeaponType;

	if (m_pClientList[iClientH] == 0) return 0;

	wWeaponType = m_pClientList[iClientH]->m_appearance.iWeaponType;

	if (wWeaponType == 0) {
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7)
			return 9;
		else return 8;
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {
		return 14;
	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {
		return 21;
	}
	else if (wWeaponType >= 40) {
		return 6;
	}

	return 1;
}

static int ___iCAB5[] = { 0,0, 0,1,2 };
static int ___iCAB6[] = { 0,0, 0,0,0 };
static int ___iCAB7[] = { 0,0, 1,2,3 };
static int ___iCAB8[] = { 0,0, 1,3,5 };
static int ___iCAB9[] = { 0,0, 2,4,8 };
static int ___iCAB10[] = { 0,0, 1,2,3 };

int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{
	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5:
		return ___iCAB5[iComboCount];
		break;
	case 6:
		return ___iCAB6[iComboCount];
		break;
	case 7:
		return ___iCAB7[iComboCount];
		break;
	case 8:
		return ___iCAB8[iComboCount];
		break;
	case 9:
		return ___iCAB9[iComboCount];
		break;
	case 10:
		return ___iCAB10[iComboCount];
		break;
	case 14:
		return ___iCAB6[iComboCount];
		break;
	case 21:
		return ___iCAB10[iComboCount];
		break;
	}

	return 0;
}

void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
	if (m_pClientList[iClientH] == 0) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= DEF_MAXSKILLTYPE)) return;

	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, 0, 0, 0);
}


bool CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
	int bRet;

	if (m_pClientList[iClientH] == 0) return false;
	if ((sItemIndex < 0) || (sItemIndex >= hb::limits::MaxItems)) return false;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return false;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->GetItemEffectType()) {
	case ItemEffectType::OccupyFlag:
		bRet = __bSetOccupyFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
			0, iClientH);
		if (bRet) {
			GetExp(iClientH, (iDice(m_pClientList[iClientH]->m_iLevel, 10)));
		}
		else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOTFLAGSPOT, 0, 0, 0, 0);
		}
		return bRet;

		// crusade
	case ItemEffectType::ConstructionKit:
		// .   . m_sItemEffectValue1:  , m_sItemEffectValue2:
		bRet = __bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
			iClientH);
		if (bRet) {
		}
		else {
		}
		return bRet;

	case ItemEffectType::Dye:
		if ((sDestItemID >= 0) && (sDestItemID < hb::limits::MaxItems)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12)) {
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor =
						static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 0, 0);
					return true;
				}
				else {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, 0, 0);
					return false;
				}
			}
		}
		break;

	case ItemEffectType::ArmorDye:
		if ((sDestItemID >= 0) && (sDestItemID < hb::limits::MaxItems)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 6) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 15) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 13)) {
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor =
						static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 0, 0);
					return true;
				}
				else {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, 0, 0);
					return false;
				}
			}
		}
		break;

	case ItemEffectType::WeaponDye:
		if ((sDestItemID >= 0) && (sDestItemID < hb::limits::MaxItems)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 1) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 3) ||
					(m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 8)) {
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor =
						static_cast<char>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, 0, 0);
					return true;
				}
				else {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, 0, 0);
					return false;
				}
			}
		}
		break;

	case ItemEffectType::Farming:
		bRet = bPlantSeedBag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
			iClientH);
		return bRet;

	default:
		break;
	}

	return true;
}


bool CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH)
{
	int   iDynamicObjectIndex, iIndex;
	class CTile* pTile;
	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	if (m_pMapList[cMapIndex] == 0) return false;
	if (((m_bIsHeldenianMode == false) || (static_cast<char>(m_bIsHeldenianMode) != m_cHeldenianType)) &&
		(m_bHeldenianInitiated == 1)) return false;
	if ((m_cHeldenianType == 1) && (m_iBTFieldMapIndex == -1)) return false;
	if ((m_cHeldenianType == 2) && (m_iGodHMapIndex == -1)) return false;
	if ((m_pClientList[iClientH]->m_iGuildRank == 0)) return false;

	pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + dX + dY * m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iAttribute != 0) return false;
	iSide = m_sLastHeldenianWinner;
	if ((dX < 25) || (dX >= m_pMapList[cMapIndex]->m_sSizeX - 25) ||
		(dY < 25) || (dY >= m_pMapList[cMapIndex]->m_sSizeY - 25)) return false;

	if ((iClientH > 0) && (m_pClientList[iClientH] != 0)) {
		if (m_pClientList[iClientH]->m_cSide != iSide) return false;
	}

	pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + dX + dY * m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iOccupyFlagIndex != 0) return false;
	if (pTile->m_bIsMoveAllowed == false)  return false;

	for(int ix = dX - 3; ix <= dX + 3; ix++)
		for(int iy = dY - 3; iy <= dY + 3; iy++) {
			if ((ix == dX) && (iy == dY)) {

			}
			else {
				pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + ix + iy * m_pMapList[cMapIndex]->m_sSizeY);
				if ((pTile->m_iOccupyFlagIndex != 0) && (pTile->m_iOccupyFlagIndex > 0) &&
					(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != 0)) {
					if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide == iSide) return false;
				}
			}
		}

	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) {
		return false;
	}

	switch (iSide) {
	case 1:	iDynamicObjectIndex = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, 0, 0);	break;
	case 2:	iDynamicObjectIndex = iAddDynamicObjectList(0, 0, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, 0, 0);	break;
	default: iDynamicObjectIndex = 0;
	}

	iEKNum = 1;
	iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
	if (iIndex < 0) {
		if (iDynamicObjectIndex > DEF_MAXGUILDS)
			return true;
	}

	pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + dX + dY * m_pMapList[cMapIndex]->m_sSizeY);
	pTile->m_iOccupyFlagIndex = iIndex;

	m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

	if (m_cHeldenianType == 1) {
		for(int ix = dX - 3; ix <= dX + 3; ix++)
			for(int iy = dY - 3; iy <= dY + 3; iy++) {
				if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) ||
					(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
				}
				else {
					pTile = (class CTile*)(m_pMapList[cMapIndex]->m_pTile + ix + iy * m_pMapList[cMapIndex]->m_sSizeY);
					switch (iSide) {
					case 1:
						pTile->m_iOccupyStatus -= iEKNum;
						break;
					case 2:
						pTile->m_iOccupyStatus += iEKNum;
						break;
					}
				}
			}
	}

	if (m_cHeldenianType == 2) {
		if (iSide == m_sLastHeldenianWinner) {
			m_cHeldenianVictoryType = iSide;
			//sub_4AB9D0
		}
	}
	return true;
}

void CGame::SetSummonMobAction(int iClientH, int iMode, size_t dwMsgSize, char* pData)
{
	int iTargetIndex;
	char   seps[] = "= \t\r\n";
	char* token, cTargetName[11], cBuff[256];

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	switch (iMode) {
	case 0: // Free
	case 1: // Hold
		// iClientH   .
		for(int i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != 0) {
				if ((m_pNpcList[i]->m_bIsSummoned) &&
					(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
					(m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER)) {

					m_pNpcList[i]->m_iSummonControlMode = iMode;
					m_pNpcList[i]->m_bIsPermAttackMode = false;
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_sBehaviorTurnCount = 0;
					m_pNpcList[i]->m_iTargetIndex = 0;
				}
			}
		break;

	case 2:
		if ((dwMsgSize) <= 0) return;
		memcpy(cBuff, pData, dwMsgSize);

		token = strtok(NULL, seps);
		token = strtok(NULL, seps);

		iTargetIndex = 0;
		if (token != 0) {
			// token
			if (strlen(token) > DEF_CHARNAME - 1)
				memcpy(cTargetName, token, DEF_CHARNAME - 1);
			else memcpy(cTargetName, token, strlen(token));

			// 2002.8.17
			for(int i = 1; i < DEF_MAXCLIENTS; i++)
			{
				// if ((m_pClientList[i] != 0) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) { // original
				if ((m_pClientList[i] != 0) &&
					(_strnicmp(m_pClientList[i]->m_cCharName, cTargetName, DEF_CHARNAME - 1) == 0) &&
					(strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0)) // adamas(map  .)
				{
					iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}

	SSMA_SKIPSEARCH:

		if ((iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0) &&
			(m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
			for(int i = 0; i < DEF_MAXNPCS; i++)
				if (m_pNpcList[i] != 0) {
					if ((m_pNpcList[i]->m_bIsSummoned) &&
						(m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
						(m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER)) {

						m_pNpcList[i]->m_iSummonControlMode = iMode;
						m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[i]->m_sBehaviorTurnCount = 0;
						m_pNpcList[i]->m_iTargetIndex = iTargetIndex;
						m_pNpcList[i]->m_cTargetType = DEF_OWNERTYPE_PLAYER;
						m_pNpcList[i]->m_bIsPermAttackMode = true;
					}
				}
		}
		break;
	}
}

void CGame::GetOccupyFlagHandler(int iClientH)
{
	int   iNum, iRet, iEraseReq, iEKNum;
	char cItemName[DEF_ITEMNAME];
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 3) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	std::memset(cItemName, 0, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: strcpy(cItemName, ""); break;
	case 2: strcpy(cItemName, "");   break;
	}

	// ReqPurchaseItemHandler   .
	iNum = 1;
	for(int i = 1; i <= iNum; i++) {

		pItem = new CItem;
		if (_bInitItemAttr(pItem, cItemName) == false) {
			delete pItem;
		}
		else {

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				if (m_pClientList[iClientH]->m_iEnemyKillCount > 12) {
					iEKNum = 12;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 12;
				}
				else {
					iEKNum = m_pClientList[iClientH]->m_iEnemyKillCount;
					m_pClientList[iClientH]->m_iEnemyKillCount = 0;
				}

				// EKNum .
				pItem->m_sItemSpecEffectValue1 = iEKNum;

				// testcode  .
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)", m_pClientList[iClientH]->m_cCharName, iEKNum, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogFileList(G_cTxt);

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

				iCalcTotalWeight(iClientH);

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
				}

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, 0, 0, 0);
			}
			else
			{
				delete pItem;

				iCalcTotalWeight(iClientH);

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
				}
			}
		}
	}
}


void CGame::GetFightzoneTicketHandler(int iClientH)
{
	int   iRet, iEraseReq, iMonth, iDay, iHour;
	char cItemName[DEF_ITEMNAME];
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) {
		m_pClientList[iClientH]->m_iFightzoneNumber *= -1;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -1, 0, 0, 0);
		return;
	}

	std::memset(cItemName, 0, sizeof(cItemName));

	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1)
		strcpy(cItemName, "ArenaTicket");
	else  std::snprintf(cItemName, sizeof(cItemName), "ArenaTicket(%d)", m_pClientList[iClientH]->m_iFightzoneNumber);

	pItem = new CItem;
	if (_bInitItemAttr(pItem, cItemName) == false) {
		delete pItem;
		return;
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
		if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber - 1;

		pItem->SetTouchEffectType(TouchEffectType::Date);

		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth * 10000) / 100;
		iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth * 10000 - iDay * 100;

		pItem->m_sTouchEffectValue1 = iMonth;
		pItem->m_sTouchEffectValue2 = iDay;
		pItem->m_sTouchEffectValue3 = iHour;


		std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)(%d)(%d)", m_pClientList[iClientH]->m_cCharName, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);


		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

		iCalcTotalWeight(iClientH);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return;
		}
	}
	else {
		delete pItem;

		iCalcTotalWeight(iClientH);

		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			return;
		}
	}
}

size_t CGame::_iComposeFlagStatusContents(char* pData)
{
	SYSTEMTIME SysTime;
	char cTxt[120];
	

	if (m_iMiddlelandMapIndex < 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");

	std::snprintf(cTxt, sizeof(cTxt), "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	for(int i = 1; i < DEF_MAXOCCUPYFLAG; i++)
		if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != 0) {

			std::snprintf(cTxt, sizeof(cTxt), "flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_cSide,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
				m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
			strcat(pData, cTxt);
			strcat(pData, "\n");
		}

	strcat(pData, "\n\n");

	return strlen(pData);
}


//Hero Code by Zabuza
void CGame::GetHeroMantleHandler(int iClientH, int iItemID, const char* pString)
{
	int   iNum, iRet, iEraseReq;
	char cItemName[DEF_ITEMNAME];
	CItem* pItem;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
		return;
	}

	//Prevents a crash if item dosent exist
	if (m_pItemConfigList[iItemID] == 0)  return;

	switch (iItemID) {
		// Hero Cape
	case 400: //Aresden HeroCape
	case 401: //Elvine HeroCape
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 300) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300;
		break;

		// Hero Helm
	case 403: //Aresden HeroHelm(M)
	case 404: //Aresden HeroHelm(W)
	case 405: //Elvine HeroHelm(M)
	case 406: //Elvine HeroHelm(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 150) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 150;
		if (m_pClientList[iClientH]->m_iContribution < 20) return;
		m_pClientList[iClientH]->m_iContribution -= 20;
		break;

		// Hero Cap
	case 407: //Aresden HeroCap(M)
	case 408: //Aresden HeroCap(W)
	case 409: //Elvine HeroHelm(M)
	case 410: //Elvine HeroHelm(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 100;
		if (m_pClientList[iClientH]->m_iContribution < 20) return;
		m_pClientList[iClientH]->m_iContribution -= 20;
		break;

		// Hero Armour
	case 411: //Aresden HeroArmour(M)
	case 412: //Aresden HeroArmour(W)
	case 413: //Elvine HeroArmour(M)
	case 414: //Elvine HeroArmour(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 300) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300;
		if (m_pClientList[iClientH]->m_iContribution < 30) return;
		m_pClientList[iClientH]->m_iContribution -= 30;
		break;

		// Hero Robe
	case 415: //Aresden HeroRobe(M)
	case 416: //Aresden HeroRobe(W)
	case 417: //Elvine HeroRobe(M)
	case 418: //Elvine HeroRobe(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 200) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 200;
		if (m_pClientList[iClientH]->m_iContribution < 20) return;
		m_pClientList[iClientH]->m_iContribution -= 20;
		break;

		// Hero Hauberk
	case 419: //Aresden HeroHauberk(M)
	case 420: //Aresden HeroHauberk(W)
	case 421: //Elvine HeroHauberk(M)
	case 422: //Elvine HeroHauberk(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 100;
		if (m_pClientList[iClientH]->m_iContribution < 10) return;
		m_pClientList[iClientH]->m_iContribution -= 10;
		break;

		// Hero Leggings
	case 423: //Aresden HeroLeggings(M)
	case 424: //Aresden HeroLeggings(W)
	case 425: //Elvine HeroLeggings(M)
	case 426: //Elvine HeroLeggings(W)
		if (m_pClientList[iClientH]->m_iEnemyKillCount < 150) return;
		m_pClientList[iClientH]->m_iEnemyKillCount -= 150;
		if (m_pClientList[iClientH]->m_iContribution < 15) return;
		m_pClientList[iClientH]->m_iContribution -= 15;
		break;

	default:
		return;
		break;
	}

	std::memset(cItemName, 0, sizeof(cItemName));
	memcpy(cItemName, m_pItemConfigList[iItemID]->m_cName, DEF_ITEMNAME - 1);
	// ReqPurchaseItemHandler
	iNum = 1;
	for(int i = 1; i <= iNum; i++)
	{
		pItem = new CItem;
		if (_bInitItemAttr(pItem, cItemName) == false)
		{
			delete pItem;
		}
		else {

			if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get HeroItem : Char(%s) Player-EK(%d) Player-Contr(%d) Hero Obtained(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iEnemyKillCount, m_pClientList[iClientH]->m_iContribution, cItemName);
				PutLogFileList(G_cTxt);

				pItem->SetTouchEffectType(TouchEffectType::UniqueOwner);
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

				iCalcTotalWeight(iClientH);

				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					DeleteClient(iClientH, true, true);
					return;
				}

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, 0, 0, 0);
			}
			else
			{
				delete pItem;

				iCalcTotalWeight(iClientH);

				iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:

					DeleteClient(iClientH, true, true);
					return;
				}
			}
		}
	}
}

void CGame::_SetItemPos(int iClientH, char* pData)
{
	char cItemIndex;
	short sX, sY;

	if (m_pClientList[iClientH] == 0) return;

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestSetItemPos>(pData, sizeof(hb::net::PacketRequestSetItemPos));
	if (!req) return;
	cItemIndex = static_cast<char>(req->dir);
	sX = req->x;
	sY = req->y;

	if (sY < -10) sY = -10;

	if ((cItemIndex < 0) || (cItemIndex >= hb::limits::MaxItems)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != 0) {
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{
	int iDamage;

	if (m_pClientList[iClientH] == 0) return;

	for(int i = 0; i < hb::limits::MaxItems; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			if ((m_pClientList[iClientH]->m_pItemList[i]->GetTouchEffectType() == TouchEffectType::UniqueOwner) &&
				(m_pClientList[iClientH]->m_bIsItemEquipped[i])) {
				// Touch Effect Type DEF_ITET_OWNER Touch Effect Value 1, 2, 3    .

				if ((m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
					(m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
				}
				else {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, 0, 0);
					ReleaseItemHandler(iClientH, i, true);
					iDamage = iDice(10, 10);
					m_pClientList[iClientH]->m_iHP -= iDamage;
					if (m_pClientList[iClientH]->m_iHP <= 0) {
						ClientKilledHandler(iClientH, 0, 0, iDamage);
					}
				}
			}
		}
}

void CGame::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, uint16_t wObjectID, const char* pItemName)
{
	short sOwnerH;
	char  cOwnerType;

	if (m_pClientList[iClientH] == 0) return;
	if ((sItemIndex < 0) || (sItemIndex >= hb::limits::MaxItems)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == 0) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < static_cast<uint32_t>(iAmount)) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;
	if (m_pClientList[iClientH]->m_bIsExchangeMode) return;
	if (wObjectID >= DEF_MAXCLIENTS) return;

	// dX, dY     .
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);


	if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {

		if (wObjectID != 0) {
			if (wObjectID < 10000) {
				if (m_pClientList[wObjectID] != 0) {
					if ((uint16_t)sOwnerH != wObjectID) sOwnerH = 0;
				}
			}
			else sOwnerH = 0;
		}

		if ((sOwnerH == 0) || (m_pClientList[sOwnerH] == 0)) {
			_ClearExchangeStatus(iClientH);
		}
		else {
			if ((m_pClientList[sOwnerH]->m_bIsExchangeMode) || (m_pClientList[sOwnerH]->m_appearance.bIsWalking) ||
				(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone)) {
				_ClearExchangeStatus(iClientH);
			}
			else {
				m_pClientList[iClientH]->m_bIsExchangeMode = true;
				m_pClientList[iClientH]->m_iExchangeH = sOwnerH;
				std::memset(m_pClientList[iClientH]->m_cExchangeName, 0, sizeof(m_pClientList[iClientH]->m_cExchangeName));
				strcpy(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[sOwnerH]->m_cCharName);


				//Clear items in the list
				m_pClientList[iClientH]->iExchangeCount = 0;
				m_pClientList[sOwnerH]->iExchangeCount = 0;
				for(int i = 0; i < 4; i++) {
					//Clear the trader
					m_pClientList[iClientH]->m_sExchangeItemID[i] = 0;
					m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
					m_pClientList[iClientH]->m_iExchangeItemAmount[i] = 0;
					//Clear the guy we're trading with
					m_pClientList[sOwnerH]->m_sExchangeItemID[i] = 0;
					m_pClientList[sOwnerH]->m_cExchangeItemIndex[i] = -1;
					m_pClientList[sOwnerH]->m_iExchangeItemAmount[i] = 0;
				}

				m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount] = (char)sItemIndex;
				m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

				m_pClientList[iClientH]->m_sExchangeItemID[m_pClientList[iClientH]->iExchangeCount] = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum;

				m_pClientList[sOwnerH]->m_bIsExchangeMode = true;
				m_pClientList[sOwnerH]->m_iExchangeH = iClientH;
				std::memset(m_pClientList[sOwnerH]->m_cExchangeName, 0, sizeof(m_pClientList[sOwnerH]->m_cExchangeName));
				strcpy(m_pClientList[sOwnerH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName);

				m_pClientList[iClientH]->iExchangeCount++;
				SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex + 1000, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 + 100,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute,
					reinterpret_cast<char*>(static_cast<intptr_t>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum)));

				SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 + 100,
					m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute,
					reinterpret_cast<char*>(static_cast<intptr_t>(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum)));
			}
		}
	}
	else {
		// NPC    .
		_ClearExchangeStatus(iClientH);

	}
}

void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{
	int iExH;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;
	if (m_pClientList[iClientH]->iExchangeCount > 4) return;	//only 4 items trade

	if ((m_pClientList[iClientH]->m_bIsExchangeMode) && (m_pClientList[iClientH]->m_iExchangeH != 0)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		if ((m_pClientList[iExH] == 0) || (_strnicmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, DEF_CHARNAME - 1) != 0)) {

		}
		else {
			if ((iItemIndex < 0) || (iItemIndex >= hb::limits::MaxItems)) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < static_cast<uint32_t>(iAmount)) return;

			//No Duplicate items
			for(int i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
				if (m_pClientList[iClientH]->m_cExchangeItemIndex[i] == (char)iItemIndex) {
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(iClientH);
					return;
				}
			}

			m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount] = (char)iItemIndex;
			m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

			m_pClientList[iClientH]->m_sExchangeItemID[m_pClientList[iClientH]->iExchangeCount] = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum;

			m_pClientList[iClientH]->iExchangeCount++;
			SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex + 1000, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 + 100,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute,
				reinterpret_cast<char*>(static_cast<intptr_t>(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum)));

			SendNotifyMsg(iClientH, iExH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 + 100,
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute,
				reinterpret_cast<char*>(static_cast<intptr_t>(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum)));
		}
	}
	else {
	}
}

void CGame::ConfirmExchangeItem(int iClientH)
{
	int iExH;
	int iItemWeightA, iItemWeightB, iWeightLeftA, iWeightLeftB, iAmountLeft;
	CItem* pItemA[4], * pItemB[4], * pItemAcopy[4], * pItemBcopy[4];

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;

	if ((m_pClientList[iClientH]->m_bIsExchangeMode) && (m_pClientList[iClientH]->m_iExchangeH != 0)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;

		if (iClientH == iExH) return;

		if (m_pClientList[iExH] != 0) {
			if ((_strnicmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, DEF_CHARNAME - 1) != 0) ||
				(m_pClientList[iExH]->m_bIsExchangeMode != true) ||
				(_strnicmp(m_pClientList[iExH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1) != 0)) {
				_ClearExchangeStatus(iClientH);
				_ClearExchangeStatus(iExH);
				return;
			}
			else {
				m_pClientList[iClientH]->m_bIsExchangeConfirm = true;
				if (m_pClientList[iExH]->m_bIsExchangeConfirm) {

					//Check all items
					for(int i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
						if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] == 0) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_sIDnum != m_pClientList[iClientH]->m_sExchangeItemID[i])) {
							_ClearExchangeStatus(iClientH);
							_ClearExchangeStatus(iExH);
							return;
						}
					}
					for(int i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
						if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] == 0) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_sIDnum != m_pClientList[iExH]->m_sExchangeItemID[i])) {
							_ClearExchangeStatus(iClientH);
							_ClearExchangeStatus(iExH);
							return;
						}
					}

					iWeightLeftA = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
					iWeightLeftB = _iCalcMaxLoad(iExH) - iCalcTotalWeight(iExH);

					//Calculate weight for items
					iItemWeightA = 0;
					for(int i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
						iItemWeightA = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]],
							m_pClientList[iClientH]->m_iExchangeItemAmount[i]);
					}
					iItemWeightB = 0;
					for(int i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
						iItemWeightB = iGetItemWeight(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]],
							m_pClientList[iExH]->m_iExchangeItemAmount[i]);
					}

					//See if the other person can take the item weightload
					if ((iWeightLeftA < iItemWeightB) || (iWeightLeftB < iItemWeightA)) {
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}

					for(int i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
						if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->GetItemType() == ItemType::Consume) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->GetItemType() == ItemType::Arrow)) {

							if (static_cast<uint32_t>(m_pClientList[iClientH]->m_iExchangeItemAmount[i]) >
								m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount) {
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
							}
							pItemA[i] = new CItem;
							_bInitItemAttr(pItemA[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];

							pItemAcopy[i] = new CItem;
							_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemAcopy[i], pItemA[i]);
							pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
						}
						else {
							pItemA[i] = (CItem*)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]];
							pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];

							pItemAcopy[i] = new CItem;
							_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemAcopy[i], pItemA[i]);
							pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
						}
					}

					for(int i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
						if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->GetItemType() == ItemType::Consume) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->GetItemType() == ItemType::Arrow)) {

							if (static_cast<uint32_t>(m_pClientList[iExH]->m_iExchangeItemAmount[i]) >
								m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount) {
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
							}
							pItemB[i] = new CItem;
							_bInitItemAttr(pItemB[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];

							pItemBcopy[i] = new CItem;
							_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemBcopy[i], pItemB[i]);
							pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
						}
						else {
							pItemB[i] = (CItem*)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]];
							pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];

							pItemBcopy[i] = new CItem;
							_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemBcopy[i], pItemB[i]);
							pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
						}
					}

					for(int i = 0; i < m_pClientList[iExH]->iExchangeCount; i++) {
						bAddItem(iClientH, pItemB[i], 0);
						_bItemLog(DEF_ITEMLOG_EXCHANGE, iExH, iClientH, pItemBcopy[i]);
						delete pItemBcopy[i];
						pItemBcopy[i] = 0;
						if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->GetItemType() == ItemType::Consume) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->GetItemType() == ItemType::Arrow)) {
							iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iExH]->m_iExchangeItemAmount[i];
							if (iAmountLeft < 0) iAmountLeft = 0;
							// v1.41 !!!
							SetItemCount(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], iAmountLeft);
							// m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
						}
						else {
							ReleaseItemHandler(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], true);
							SendNotifyMsg(0, iExH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_cExchangeItemIndex[i], m_pClientList[iExH]->m_iExchangeItemAmount[i], 0, m_pClientList[iClientH]->m_cCharName);
							m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] = 0;
						}
					}

					for(int i = 0; i < m_pClientList[iClientH]->iExchangeCount; i++) {
						bAddItem(iExH, pItemA[i], 0);
						_bItemLog(DEF_ITEMLOG_EXCHANGE, iClientH, iExH, pItemAcopy[i]);
						delete pItemAcopy[i];
						pItemAcopy[i] = 0;

						if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->GetItemType() == ItemType::Consume) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->GetItemType() == ItemType::Arrow)) {
							iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iClientH]->m_iExchangeItemAmount[i];
							if (iAmountLeft < 0) iAmountLeft = 0;
							// v1.41 !!!
							SetItemCount(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], iAmountLeft);
							// m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
						}
						else {
							ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], true);
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_cExchangeItemIndex[i], m_pClientList[iClientH]->m_iExchangeItemAmount[i], 0, m_pClientList[iExH]->m_cCharName);
							m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] = 0;
						}
					}

					m_pClientList[iClientH]->m_bIsExchangeMode = false;
					m_pClientList[iClientH]->m_bIsExchangeConfirm = false;
					std::memset(m_pClientList[iClientH]->m_cExchangeName, 0, sizeof(m_pClientList[iClientH]->m_cExchangeName));
					m_pClientList[iClientH]->m_iExchangeH = 0;
					m_pClientList[iClientH]->iExchangeCount = 0;

					m_pClientList[iExH]->m_bIsExchangeMode = false;
					m_pClientList[iExH]->m_bIsExchangeConfirm = false;
					std::memset(m_pClientList[iExH]->m_cExchangeName, 0, sizeof(m_pClientList[iExH]->m_cExchangeName));
					m_pClientList[iExH]->m_iExchangeH = 0;
					m_pClientList[iExH]->iExchangeCount = 0;

					for(int i = 0; i < 4; i++) {
						m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
						m_pClientList[iExH]->m_cExchangeItemIndex[i] = -1;
					}

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_EXCHANGEITEMCOMPLETE, 0, 0, 0, 0);
					SendNotifyMsg(0, iExH, DEF_NOTIFY_EXCHANGEITEMCOMPLETE, 0, 0, 0, 0);

					iCalcTotalWeight(iClientH);
					iCalcTotalWeight(iExH);
					return;
				}
			}
		}
		else {
			_ClearExchangeStatus(iClientH);
			return;
		}
	}
}

int CGame::_iGetItemSpaceLeft(int iClientH)
{
	int iTotalItem;

	iTotalItem = 0;
	for(int i = 0; i < hb::limits::MaxItems; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) iTotalItem++;

	return (hb::limits::MaxItems - iTotalItem);
}

bool CGame::bAddItem(int iClientH, CItem* pItem, char cMode)
{
	int iRet, iEraseReq;


	if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

		return true;
	}
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY,
			pItem);

		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute); //v1.4 color

		iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


		return true;
	}

	return false;
}


int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int* pQuestType, int* pMode, int* pRewardType, int* pRewardAmount, int* pContribution, char* pTargetName, int* pTargetType, int* pTargetCount, int* pX, int* pY, int* pRange)
{
	int iQuest, iEraseReq;
	CItem* pItem;
	uint32_t iExp;

	if (m_pClientList[iClientH] == 0) return 0;

	if (m_pClientList[iClientH]->m_iQuest != 0) {
		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest] == 0) return -4;
		else if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iFrom == 4) {
			if (m_pClientList[iClientH]->m_bIsQuestCompleted) {
				if ((m_pClientList[iClientH]->m_iQuestRewardType > 0) &&
					(m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType] != 0)) {
					pItem = new CItem;
					_bInitItemAttr(pItem, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName);
					pItem->m_dwCount = m_pClientList[iClientH]->m_iQuestRewardAmount;
					if (_bCheckItemReceiveCondition(iClientH, pItem)) {
						_bAddClientItemList(iClientH, pItem, &iEraseReq);
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
						if (iEraseReq == 1) delete pItem;

						m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount,
							m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

						_ClearQuestStatus(iClientH);
						return -5;
					}
					else {
						delete pItem;
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);

						SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 0, m_pClientList[iClientH]->m_iQuestRewardAmount,
							m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

						return -5;
					}
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -1) {
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iQuestRewardAmount;
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount,
						"              ", m_pClientList[iClientH]->m_iContribution);

					_ClearQuestStatus(iClientH);
					return -5;
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -2) {
					iExp = iDice(1, (10 * m_pClientList[iClientH]->m_iLevel));
					iExp = iExp * m_pClientList[iClientH]->m_iQuestRewardAmount;

					m_pClientList[iClientH]->m_iExpStock += iExp;
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, iExp,
						"              ", m_pClientList[iClientH]->m_iContribution);

					_ClearQuestStatus(iClientH);
					return -5;
				}
				else {
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, 0,
						"                     ", m_pClientList[iClientH]->m_iContribution);

					_ClearQuestStatus(iClientH);
					return -5;
				}
			}
			else return -1;
		}

		return -4;
	}

	if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) == 0) {
		if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;

		iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
		if (iQuest <= 0) return -4;

		return iQuest;
	}
	else return -2;

	return -4;
}


int CGame::_iTalkToNpcResult_Guard(int iClientH, int* pQuestType, int* pMode, int* pRewardType, int* pRewardAmount, int* pContribution, char* pTargetName, int* pTargetType, int* pTargetCount, int* pX, int* pY, int* pRange)
{
	if (m_pClientList[iClientH] == 0) return 0;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (200), 0, 0, 0, 0);
			return 1000;
		}
		else
			if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (201), 0, 0, 0, 0);
				return 1001;
			}
	}
	else
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
			if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (202), 0, 0, 0, 0);
				return 1002;
			}
			else
				if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (203), 0, 0, 0, 0);
					return 1003;
				}
		}
		else
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (204), 0, 0, 0, 0);
					return 1004;
				}
				else
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (205), 0, 0, 0, 0);
						return 1005;
					}
					else
						if (memcmp(m_pClientList[iClientH]->m_cMapName, "default", 7) == 0) {
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_NPCTALK, (206), 0, 0, 0, 0);
							return 1006;
						}
			}

	return 0;
}


int CGame::__iSearchForQuest(int iClientH, int iWho, int* pQuestType, int* pMode, int* pRewardType, int* pRewardAmount, int* pContribution, char* pTargetName, int* pTargetType, int* pTargetCount, int* pX, int* pY, int* pRange)
{
	int iQuestList[DEF_MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;

	if (m_pClientList[iClientH] == 0) return -1;

	iIndex = 0;
	for(int i = 0; i < DEF_MAXQUESTTYPE; i++)
		iQuestList[i] = -1;

	for(int i = 1; i < DEF_MAXQUESTTYPE; i++)
		if (m_pQuestConfigList[i] != 0) {

			if (m_pQuestConfigList[i]->m_iFrom != iWho) goto SFQ_SKIP;
			if (m_pQuestConfigList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) goto SFQ_SKIP;
			if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
			if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
			if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

			if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
				if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] <
					m_pQuestConfigList[i]->m_iRequiredSkillLevel) goto SFQ_SKIP;
			}

			if ((m_bIsCrusadeMode) && (m_pQuestConfigList[i]->m_iAssignType != 1)) goto SFQ_SKIP;
			if ((m_bIsCrusadeMode == false) && (m_pQuestConfigList[i]->m_iAssignType == 1)) goto SFQ_SKIP;

			if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

			iQuestList[iIndex] = i;
			iIndex++;

		SFQ_SKIP:;
		}

	// iIndex     .    1 .
	if (iIndex == 0) return -1;
	iQuest = (iDice(1, iIndex)) - 1;
	iQuestIndex = iQuestList[iQuest];
	iReward = iDice(1, 3);
	*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;
	*pRewardType = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];
	*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];
	*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;

	strcpy(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);
	*pX = m_pQuestConfigList[iQuestIndex]->m_sX;
	*pY = m_pQuestConfigList[iQuestIndex]->m_sY;
	*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;

	*pTargetType = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
	*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
	*pQuestType = m_pQuestConfigList[iQuestIndex]->m_iType;

	return iQuestIndex;
}

// New 14/05/2004
void CGame::QuestAcceptedHandler(int iClientH)
{
	int iIndex;

	if (m_pClientList[iClientH] == 0) return;

	// Does the quest exist ??
	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest] == 0) return;

	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) {
		switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
		case 10:
			_ClearQuestStatus(iClientH);
			RequestTeleportHandler(iClientH, "2   ", m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
				m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
			return;
		}
	}

	m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[iIndex]->m_iQuestID;
	m_pClientList[iClientH]->m_iCurQuestCount = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = false;

	_CheckQuestEnvironment(iClientH);
	_SendQuestContents(iClientH);
}


void CGame::_SendQuestContents(int iClientH)
{
	int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
	char cTargetName[DEF_NPCNAME];

	if (m_pClientList[iClientH] == 0) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == 0) {
		// Quest .
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCONTENTS, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0);
	}
	else {
		// Quest  .
		iWho = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX = m_pQuestConfigList[iIndex]->m_sX;
		iY = m_pQuestConfigList[iIndex]->m_sY;
		iRange = m_pQuestConfigList[iIndex]->m_iRange;
		std::memset(cTargetName, 0, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, DEF_NPCNAME - 1);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, 0,
			iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
	}
}

void CGame::_CheckQuestEnvironment(int iClientH)
{
	int iIndex;
	char cTargetName[DEF_NPCNAME];

	if (m_pClientList[iClientH] == 0) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == 0) return;
	if (m_pQuestConfigList[iIndex] == 0) return;

	if (iIndex >= 35 && iIndex <= 40) {
		m_pClientList[iClientH]->m_iQuest = 0;
		m_pClientList[iClientH]->m_iQuestID = 0;
		m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
		m_pClientList[iClientH]->m_iQuestRewardType = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTABORTED, 0, 0, 0, 0);
		return;
	}

	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {
		m_pClientList[iClientH]->m_iQuest = 0;
		m_pClientList[iClientH]->m_iQuestID = 0;
		m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
		m_pClientList[iClientH]->m_iQuestRewardType = 0;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTABORTED, 0, 0, 0, 0);
		return;
	}

	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case DEF_QUESTTYPE_MONSTERHUNT:
	case DEF_QUESTTYPE_GOPLACE:
		std::memset(cTargetName, 0, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, DEF_NPCNAME - 1);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = true;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = false;
		break;
	}

}

bool CGame::_bCheckIsQuestCompleted(int iClientH)
{
	int iQuestIndex;

	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted) return false;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == 0) return false;

	if (m_pQuestConfigList[iQuestIndex] != 0) {
		switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case DEF_QUESTTYPE_MONSTERHUNT:
			if ((m_pClientList[iClientH]->m_bQuestMatchFlag_Loc) &&
				(m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount)) {
				m_pClientList[iClientH]->m_bIsQuestCompleted = true;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOMPLETED, 0, 0, 0, 0);
				return true;
			}
			break;

		case DEF_QUESTTYPE_GOPLACE:
			if ((m_pClientList[iClientH]->m_bQuestMatchFlag_Loc) &&
				(m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				(m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				(m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				(m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange)) {
				m_pClientList[iClientH]->m_bIsQuestCompleted = true;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTCOMPLETED, 0, 0, 0, 0);
				return true;
			}
			break;
		}
	}

	return false;
}


int CGame::SendItemNotifyMsg(int iClientH, uint16_t wMsgType, CItem* pItem, int iV1)
{
	int iRet = 0;

	if (m_pClientList[iClientH] == 0) return 0;

	switch (wMsgType) {
	case DEF_NOTIFY_ITEMOBTAINED:
	{
		hb::net::PacketNotifyItemObtained pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.is_new = 1;
		memcpy(pkt.name, pItem->m_cName, sizeof(pkt.name));
		pkt.count = pItem->m_dwCount;
		pkt.item_type = pItem->m_cItemType;
		pkt.equip_pos = pItem->m_cEquipPos;
		pkt.is_equipped = 0;
		pkt.level_limit = pItem->m_sLevelLimit;
		pkt.gender_limit = pItem->m_cGenderLimit;
		pkt.cur_lifespan = pItem->m_wCurLifeSpan;
		pkt.weight = pItem->m_wWeight;
		pkt.sprite = pItem->m_sSprite;
		pkt.sprite_frame = pItem->m_sSpriteFrame;
		pkt.item_color = pItem->m_cItemColor;
		pkt.spec_value2 = static_cast<uint8_t>(pItem->m_sItemSpecEffectValue2);
		pkt.attribute = pItem->m_dwAttribute;
		pkt.item_id = pItem->m_sIDnum;
		pkt.max_lifespan = pItem->m_wMaxLifeSpan;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_ITEMPURCHASED:
	{
		hb::net::PacketNotifyItemPurchased pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		pkt.is_new = 1;
		memcpy(pkt.name, pItem->m_cName, sizeof(pkt.name));
		pkt.count = pItem->m_dwCount;
		pkt.item_type = pItem->m_cItemType;
		pkt.equip_pos = pItem->m_cEquipPos;
		pkt.is_equipped = 0;
		pkt.level_limit = pItem->m_sLevelLimit;
		pkt.gender_limit = pItem->m_cGenderLimit;
		pkt.cur_lifespan = pItem->m_wCurLifeSpan;
		pkt.weight = pItem->m_wWeight;
		pkt.sprite = pItem->m_sSprite;
		pkt.sprite_frame = pItem->m_sSpriteFrame;
		pkt.item_color = pItem->m_cItemColor;
		pkt.cost = static_cast<uint16_t>(iV1);
		pkt.item_id = pItem->m_sIDnum;
		pkt.max_lifespan = pItem->m_wMaxLifeSpan;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
	{
		hb::net::PacketNotifyEmpty pkt{};
		pkt.header.msg_id = MSGID_NOTIFY;
		pkt.header.msg_type = wMsgType;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
	break;
	}

	return iRet;
}

bool CGame::_bCheckItemReceiveCondition(int iClientH, CItem* pItem)
{
	

	if (m_pClientList[iClientH] == 0) return false;

	if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount) > _iCalcMaxLoad(iClientH))
		return false;

	for(int i = 0; i < hb::limits::MaxItems; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == 0) return true;

	return false;
}

void CGame::_ClearQuestStatus(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	m_pClientList[iClientH]->m_iQuest = 0;
	m_pClientList[iClientH]->m_iQuestID = 0;
	m_pClientList[iClientH]->m_iQuestRewardType = 0;
	m_pClientList[iClientH]->m_iQuestRewardAmount = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = false;
}

int CGame::iGetMaxHP(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return 0;

	int iRet = CalculateMaxHP(
		m_pClientList[iClientH]->m_iVit,
		m_pClientList[iClientH]->m_iLevel,
		m_pClientList[iClientH]->m_iStr,
		m_pClientList[iClientH]->m_iAngelicStr);

	// Apply side effect reduction if active
	if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
		iRet = iRet - (iRet / m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

	return iRet;
}

int CGame::iGetMaxMP(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return 0;

	return CalculateMaxMP(
		m_pClientList[iClientH]->m_iMag,
		m_pClientList[iClientH]->m_iAngelicMag,
		m_pClientList[iClientH]->m_iLevel,
		m_pClientList[iClientH]->m_iInt,
		m_pClientList[iClientH]->m_iAngelicInt);
}

int CGame::iGetMaxSP(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return 0;

	return CalculateMaxSP(
		m_pClientList[iClientH]->m_iStr,
		m_pClientList[iClientH]->m_iAngelicStr,
		m_pClientList[iClientH]->m_iLevel);
}

void CGame::GetMapInitialPoint(int iMapIndex, short* pX, short* pY, char* pPlayerLocation)
{
	int iTotalPoint = 0;

	GamePoint pList[DEF_MAXINITIALPOINT];

	if (m_pMapList[iMapIndex] == 0)
		return;
	for (int i = 0; i < DEF_MAXINITIALPOINT; i++)
		if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
			pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
			pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
			iTotalPoint++;
		}
	if (iTotalPoint == 0) return;
	int iIndex = 0;
	if ((pPlayerLocation != 0) && (memcmp(pPlayerLocation, "NONE", 4) != 0))
		iIndex = iDice(1, iTotalPoint) - 1;

	*pX = static_cast<short>(pList[iIndex].x);
	*pY = static_cast<short>(pList[iIndex].y);
}


// MODERNIZED: New function that polls login client socket instead of handling window messages
void CGame::OnLoginClientSocketEvent(int iLoginClientH)
{
	int iRet;

	if (iLoginClientH < 0 || iLoginClientH >= DEF_MAXCLIENTLOGINSOCK) return;

	auto p = _lclients[iLoginClientH];
	if (p == 0) return;

	iRet = p->_sock->Poll();

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		break;
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		OnClientLoginRead(iLoginClientH);
		break;

	case DEF_XSOCKEVENT_BLOCK:
		break;

	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Confirmcode Login notmatch!", iLoginClientH);
		PutLogList(G_cTxt);
		DeleteLoginClient(iLoginClientH);
		break;
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteLoginClient(iLoginClientH);
		break;
	}
}

void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
	UINT iTmp;
	int iLogSockH, iRet;

	iTmp = WM_USER_BOT_ACCEPT;
	iLogSockH = message - iTmp - 1;

	auto p = _lclients[iLogSockH];
	if (p == 0) return;

	iRet = p->_sock->Poll();

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		break;
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		break;

	case DEF_XSOCKEVENT_READCOMPLETE:
		OnClientLoginRead(iLogSockH);
		break;

	case DEF_XSOCKEVENT_BLOCK:
		break;

	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		std::snprintf(G_cTxt, sizeof(G_cTxt), "<%d> Confirmcode Login notmatch!", iLogSockH);
		PutLogList(G_cTxt);
		DeleteLoginClient(iLogSockH);
		break;
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		break;
	}
}

LoginClient::~LoginClient()
{
	if (_sock)
		delete _sock;
}

void CGame::OnClientLoginRead(int h)
{
	char* pData, cKey;
	size_t  dwMsgSize;

	if (_lclients[h] == 0) return;

	pData = _lclients[h]->_sock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, h, cKey) == false) {
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}

void CGame::DeleteLoginClient(int h)
{
	if (!_lclients[h])
		return;

	_lclients[h]->_timeout_tm = GameClock::GetTimeMS();
	_lclients_disconn.push_back(_lclients[h]);
	//delete _lclients[h];
	_lclients[h] = nullptr;
}


void CGame::BuildItemHandler(int iClientH, char* pData)
{
	char cName[DEF_ITEMNAME], cElementItemID[6];
	int    x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[hb::limits::MaxItems];
	CItem* pItem;
	bool   bFlag, bItemFlag[6];
	double dV1, dV2, dV3;
	uint32_t  dwTemp, dwTemp2;
	uint16_t   wTemp;

	if (m_pClientList[iClientH] == 0) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandCommonBuild>(
		pData, sizeof(hb::net::PacketCommandCommonBuild));
	if (!pkt) return;
	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, pkt->name, sizeof(pkt->name));

	//testcode
	//PutLogList(cName);

	std::memset(cElementItemID, 0, sizeof(cElementItemID));
	for(int i = 0; i < 6; i++) {
		cElementItemID[i] = static_cast<char>(pkt->item_ids[i]);
	}

	bFlag = true;
	while (bFlag) {
		bFlag = false;
		for(int i = 0; i <= 4; i++)
			if ((cElementItemID[i] == -1) && (cElementItemID[i + 1] != -1)) {
				cElementItemID[i] = cElementItemID[i + 1];
				cElementItemID[i + 1] = -1;
				bFlag = true;
			}
	}

	for(int i = 0; i < 6; i++) bItemFlag[i] = false;

	//testcode
	//std::snprintf(G_cTxt, sizeof(G_cTxt), "%d %d %d %d %d %d", cElementItemID[0], cElementItemID[1], cElementItemID[2],
	//	     cElementItemID[3], cElementItemID[4], cElementItemID[5]);
	//PutLogList(G_cTxt);

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[13];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_BUILDITEMFAIL, 0, 0, 0, 0);
		return;
	}

	for(int i = 0; i < 6; i++)
		if (cElementItemID[i] != -1) {
			// Item ID.
			if ((cElementItemID[i] < 0) || (cElementItemID[i] > hb::limits::MaxItems)) return;
			if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == 0) return;
		}

	for(int i = 0; i < hb::limits::MaxBuildItems; i++)
		if (m_pBuildItemList[i] != 0) {
			if (memcmp(m_pBuildItemList[i]->m_cName, cName, DEF_ITEMNAME - 1) == 0) {

				if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;

				for (x = 0; x < hb::limits::MaxItems; x++)
					if (m_pClientList[iClientH]->m_pItemList[x] != 0)
						iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
					else iItemCount[x] = 0;

				iMatch = 0;
				iTotalValue = 0;

				for (x = 0; x < 6; x++) {
					if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
						iMatch++;
					}
					else {
						for (z = 0; z < 6; z++)
							if ((cElementItemID[z] != -1) && (bItemFlag[z] == false)) {

								if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
									(m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >=
										static_cast<uint32_t>(m_pBuildItemList[i]->m_iMaterialItemCount[x])) &&
									(iItemCount[cElementItemID[z]] > 0)) {
									iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
									if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[13]) {
										iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[13]) / 2;
									}

									iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
									iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
									iMatch++;
									bItemFlag[z] = true;

									goto BIH_LOOPBREAK;
								}
							}
					BIH_LOOPBREAK:;
					}
				}

				// iMatch 6     .
				if (iMatch != 6) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_BUILDITEMFAIL, 0, 0, 0, 0);
					return;
				}

				dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
				if (iTotalValue <= 0)
					dV3 = 1.0f;
				else dV3 = (double)iTotalValue;
				dV1 = (double)(dV3 / dV2) * 100.0f;

				iTotalValue = (int)dV1;

				pItem = new CItem;
				if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == false) {
					delete pItem;
					return;
				}

				// Custom-Made
				dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp & 0xFFFFFFFE;
				dwTemp = dwTemp | 0x00000001;
				pItem->m_dwAttribute = dwTemp;

				if (pItem->GetItemType() == ItemType::Material) {
					iTemp = iDice(1, (iPlayerSkillLevel / 2) + 1) - 1;
					pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel / 2) + iTemp;
					pItem->SetTouchEffectType(TouchEffectType::ID);
					pItem->m_sTouchEffectValue1 = static_cast<short>(iDice(1, 100000));
					pItem->m_sTouchEffectValue2 = static_cast<short>(iDice(1, 100000));
					pItem->m_sTouchEffectValue3 = static_cast<short>(GameClock::GetTimeMS());

				}
				else {
					dwTemp = pItem->m_dwAttribute;
					dwTemp = dwTemp & 0x0000FFFF;

					dwTemp2 = (uint16_t)m_pBuildItemList[i]->m_wAttribute;
					dwTemp2 = dwTemp2 << 16;

					dwTemp = dwTemp | dwTemp2;
					pItem->m_dwAttribute = dwTemp;

					iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
					// : SpecEffectValue1 , SpecEffectValue2

					// 1.   ()
					if (iResultValue > 0) {
						dV2 = (double)iResultValue;
						dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
						dV1 = (dV2 / dV3) * 100.0f;
						pItem->m_sItemSpecEffectValue2 = (int)dV1;
					}
					else if (iResultValue < 0) {
						dV2 = (double)(iResultValue);
						dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
						dV1 = (dV2 / dV3) * 100.0f;
						pItem->m_sItemSpecEffectValue2 = (int)dV1;
					}
					else pItem->m_sItemSpecEffectValue2 = 0;

					dV2 = (double)pItem->m_sItemSpecEffectValue2;
					dV3 = (double)pItem->m_wMaxLifeSpan;
					dV1 = (dV2 / 100.0f) * dV3;

					iTemp = (int)pItem->m_wMaxLifeSpan;
					iTemp += (int)dV1;

					pItem->SetTouchEffectType(TouchEffectType::ID);
					pItem->m_sTouchEffectValue1 = static_cast<short>(iDice(1, 100000));
					pItem->m_sTouchEffectValue2 = static_cast<short>(iDice(1, 100000));
					pItem->m_sTouchEffectValue3 = static_cast<short>(GameClock::GetTimeMS());

					if (iTemp <= 0)
						wTemp = 1;
					else wTemp = (uint16_t)iTemp;

					if (wTemp <= pItem->m_wMaxLifeSpan * 2) {
						pItem->m_wMaxLifeSpan = wTemp;
						pItem->m_sItemSpecEffectValue1 = (short)wTemp;
						pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
					}
					else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;

					// Custom-Item  2.
					pItem->m_cItemColor = 2;
				}

				//testcode
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Custom-Item(%s) Value(%d) Life(%d/%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2, pItem->m_wCurLifeSpan, pItem->m_wMaxLifeSpan);
				PutLogList(G_cTxt);

				bAddItem(iClientH, pItem, 0);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, 0, 0); // Integer

#ifdef DEF_TAIWANLOG
				_bItemLog(DEF_ITEMLOG_MAKE, iClientH, (int)-1, pItem);
#endif	

				for (x = 0; x < 6; x++)
					if (cElementItemID[x] != -1) {
						if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == 0) {
							// ### BUG POINT!!!
							std::snprintf(G_cTxt, sizeof(G_cTxt), "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
							PutLogFileList(G_cTxt);
						}
						else {
							iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
							if (iCount < 0) iCount = 0;
							SetItemCount(iClientH, cElementItemID[x], iCount);
						}
					}

				if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[13])
					CalculateSSN_SkillIndex(iClientH, 13, 1);

				GetExp(iClientH, iDice(1, (m_pBuildItemList[i]->m_iSkillLimit / 4))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));

				return;
			}
		}

}

// 3.51 - 05/17/2004 - Hypnotoad/[KLKS] - Monster Special Abilities
char CGame::_cGetSpecialAbility(int iKindSA)
{
	char cSA;

	switch (iKindSA) {
	case 1:
		// Slime, Orc, Orge, WereWolf, YB-, Rabbit, Mountain-Giant, Stalker, Hellclaw, 
		// Wyvern, Fire-Wyvern, Barlog, Tentocle, Centaurus, Giant-Lizard, Minotaurus,
		// Abaddon, Claw-Turtle, Giant-Cray-Fish, Giant-Plant, MasterMage-Orc, Nizie,
		// Tigerworm
		switch (iDice(1, 2)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		}
		break;

	case 2:
		// Giant-Ant, Cat, Giant-Frog, 
		switch (iDice(1, 3)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 5; break; // Poisonous
		}
		break;

	case 3:
		// Zombie, Scorpion, Amphis, Troll, Dark-Elf
		switch (iDice(1, 4)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 5; break; // Poisonous
		case 4: cSA = 6; break; // Critical Poisonous
		}
		break;

	case 4:
		// no linked Npc
		switch (iDice(1, 3)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 7; break; // Explosive
		}
		break;

	case 5:
		// Stone-Golem, Clay-Golem, Beholder, Cannibal-Plant, Rudolph, DireBoar
		switch (iDice(1, 4)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 7; break; // Explosive
		case 4: cSA = 8; break; // Critical-Explosive
		}
		break;

	case 6:
		// no linked Npc
		switch (iDice(1, 3)) {
		case 1: cSA = 3; break; // Anti-Physical Damage
		case 2: cSA = 4; break; // Anti-Magic Damage
		case 3: cSA = 5; break; // Poisonous
		}
		break;

	case 7:
		// Orc-Mage, Unicorn
		switch (iDice(1, 3)) {
		case 1: cSA = 1; break; // Clairvoyant
		case 2: cSA = 2; break; // Distruction of Magic Protection
		case 3: cSA = 4; break; // Anti-Magic Damage
		}
		break;

	case 8:
		// Frost, Ice-Golem, Ettin, Gagoyle, Demon, Liche, Hellbound, Cyclops, 
		// Skeleton
		switch (iDice(1, 5)) {
		case 1: cSA = 1; break; // Clairvoyant
		case 2: cSA = 2; break; // Distruction of Magic Protection
		case 3: cSA = 4; break; // Anti-Magic Damage
		case 4: cSA = 3; break; // Anti-Physical Damage
		case 5: cSA = 8; break; // Critical-Explosive
		}
		break;

	case 9:
		// no linked Npc
		cSA = static_cast<char>(iDice(1, 8)); // All abilities available
		break;
	}

	return cSA;
}

void CGame::CheckSpecialEvent(int iClientH)
{
	CItem* pItem;
	char  cItemName[DEF_ITEMNAME];
	int   iEraseReq;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iSpecialEventID == 200081) {

		if (m_pClientList[iClientH]->m_iLevel < 11) {
			m_pClientList[iClientH]->m_iSpecialEventID = 0;
			return;
		}

		std::memset(cItemName, 0, sizeof(cItemName));
		strcpy(cItemName, "MemorialRing");

		pItem = new CItem;
		if (_bInitItemAttr(pItem, cItemName) == false) {
			delete pItem;
		}
		else {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

				// testcode  .
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get MemorialRing  : Char(%s)", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);

				pItem->SetTouchEffectType(TouchEffectType::UniqueOwner);
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor = 9;

				m_pClientList[iClientH]->m_iSpecialEventID = 0;
			}
		}
	}
}


void CGame::_AdjustRareItemValue(CItem* pItem)
{
	uint32_t dwSWEType, dwSWEValue;
	double dV1, dV2, dV3;

	if ((pItem->m_dwAttribute & 0x00F00000) != 0) {
		dwSWEType = (pItem->m_dwAttribute & 0x00F00000) >> 20;
		dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		// 0-None 1- 2- 3-
		// 5- 6- 7- 8- 9-
		switch (dwSWEType) {
		case 0: break;

		case 5:
			pItem->m_cSpeed--;
			if (pItem->m_cSpeed < 0) pItem->m_cSpeed = 0;
			break;

		case 6:
			dV2 = (double)pItem->m_wWeight;
			dV3 = (double)(dwSWEValue * 4);
			dV1 = (dV3 / 100.0f) * dV2;
			pItem->m_wWeight -= (int)dV1;

			if (pItem->m_wWeight < 1) pItem->m_wWeight = 1;
			break;

		case 8:
		case 9:
			dV2 = (double)pItem->m_wMaxLifeSpan;
			dV3 = (double)(dwSWEValue * 7);
			dV1 = (dV3 / 100.0f) * dV2;
			pItem->m_wMaxLifeSpan += (int)dV1;
			break;
		}
	}
}

int CGame::RollAttributeValue()
{
	// Weighted roll for values 1-13 (original distribution)
	static const int weights[] = { 10000, 7400, 5000, 3000, 2000, 1000, 500, 400, 300, 200, 100, 70, 30 };
	static const int totalWeight = 30000;

	int roll = rand() % totalWeight;
	int cumulative = 0;
	for(int i = 0; i < 13; i++) {
		cumulative += weights[i];
		if (roll < cumulative) return i + 1;
	}
	return 1;
}

bool CGame::GenerateItemAttributes(CItem* pItem)
{
	if (pItem == nullptr) return false;

	AttributePrefixType primaryType = AttributePrefixType::None;
	int primaryValue = 0;
	SecondaryEffectType secondaryType = SecondaryEffectType::None;
	int secondaryValue = 0;
	int itemColor = 0;

	if (pItem->GetItemEffectType() == ItemEffectType::Attack) {
		// Attack weapons - roll primary prefix
		int roll = rand() % 10000;
		int cumul = 0;

		struct { int weight; AttributePrefixType type; int color; int minVal; } attackPrimary[] = {
			{ 299,  AttributePrefixType::Light,      2, 4 },
			{ 700,  AttributePrefixType::Strong,     3, 2 },
			{ 1500, AttributePrefixType::Critical,   5, 5 },
			{ 2000, AttributePrefixType::Agile,      1, 0 },
			{ 2000, AttributePrefixType::Righteous,  7, 0 },
			{ 1600, AttributePrefixType::Poisoning,  4, 4 },
			{ 1600, AttributePrefixType::Sharp,      6, 0 },
			{ 301,  AttributePrefixType::Ancient,    8, 0 },
		};

		for (auto& entry : attackPrimary) {
			cumul += entry.weight;
			if (roll < cumul) {
				primaryType = entry.type;
				itemColor = entry.color;
				primaryValue = RollAttributeValue();
				if (primaryValue < entry.minVal) primaryValue = entry.minVal;
				break;
			}
		}

		// Secondary effect - 40% chance (original rate)
		if (rand() % 100 < 40) {
		int secRoll = rand() % 10000;
		int secCumul = 0;

		struct { int weight; SecondaryEffectType type; int minVal; int maxVal; int fixedVal; } attackSecondary[] = {
			{ 4999, SecondaryEffectType::HittingProb,       3, 0, 0 },
			{ 3500, SecondaryEffectType::ConsecutiveAttack,  0, 7, 0 },
			{ 1000, SecondaryEffectType::GoldBonus,          0, 0, 5 },
			{ 501,  SecondaryEffectType::ExperienceBonus,    0, 0, 2 },
		};

		for (auto& entry : attackSecondary) {
			secCumul += entry.weight;
			if (secRoll < secCumul) {
				secondaryType = entry.type;
				if (entry.fixedVal > 0) {
					secondaryValue = entry.fixedVal;
				} else {
					secondaryValue = RollAttributeValue();
					if (secondaryValue < entry.minVal) secondaryValue = entry.minVal;
					if (entry.maxVal > 0 && secondaryValue > entry.maxVal) secondaryValue = entry.maxVal;
				}
				break;
			}
		}
		} // end 40% secondary chance
	}
	else if (pItem->GetItemEffectType() == ItemEffectType::Defense) {
		// Defense armor - roll primary prefix
		int roll = rand() % 10000;
		int cumul = 0;

		struct { int weight; AttributePrefixType type; int minVal; bool halved; } defensePrimary[] = {
			{ 5999, AttributePrefixType::Strong,         2, false },
			{ 3000, AttributePrefixType::Light,          4, false },
			{ 555,  AttributePrefixType::ManaConverting,  0, true },
			{ 446,  AttributePrefixType::CritChance,      0, true },
		};

		for (auto& entry : defensePrimary) {
			cumul += entry.weight;
			if (roll < cumul) {
				primaryType = entry.type;
				itemColor = 0;
				primaryValue = RollAttributeValue();
				if (entry.halved) primaryValue = primaryValue / 2;
				if (primaryValue < entry.minVal) primaryValue = entry.minVal;
				break;
			}
		}

		// Secondary effect - 40% chance (original rate)
		if (rand() % 100 < 40) {
		int secRoll = rand() % 10001;
		int secCumul = 0;

		struct { int weight; SecondaryEffectType type; int minVal; } defenseSecondary[] = {
			{ 1000, SecondaryEffectType::DefenseRatio,      3 },
			{ 3000, SecondaryEffectType::PoisonResistance,  3 },
			{ 1500, SecondaryEffectType::SPRecovery,        0 },
			{ 1000, SecondaryEffectType::HPRecovery,        0 },
			{ 1000, SecondaryEffectType::MPRecovery,        0 },
			{ 1900, SecondaryEffectType::MagicResistance,   3 },
			{ 400,  SecondaryEffectType::PhysicalAbsorb,    3 },
			{ 201,  SecondaryEffectType::MagicAbsorb,       3 },
		};

		for (auto& entry : defenseSecondary) {
			secCumul += entry.weight;
			if (secRoll < secCumul) {
				secondaryType = entry.type;
				secondaryValue = RollAttributeValue();
				if (secondaryValue < entry.minVal) secondaryValue = entry.minVal;
				break;
			}
		}
		} // end 40% secondary chance
	}
	else if (pItem->GetItemEffectType() == ItemEffectType::AttackManaSave) {
		// AttackManaSave - always type Special
		primaryType = AttributePrefixType::Special;
		itemColor = 5;
		primaryValue = RollAttributeValue();

		// Secondary effect - 40% chance (original rate)
		// Same secondary pool as attack weapons
		if (rand() % 100 < 40) {
		int secRoll = rand() % 10000;
		int secCumul = 0;

		struct { int weight; SecondaryEffectType type; int minVal; int maxVal; int fixedVal; } manaSaveSecondary[] = {
			{ 4999, SecondaryEffectType::HittingProb,       3, 0, 0 },
			{ 3500, SecondaryEffectType::ConsecutiveAttack,  0, 7, 0 },
			{ 1000, SecondaryEffectType::GoldBonus,          0, 0, 5 },
			{ 501,  SecondaryEffectType::ExperienceBonus,    0, 0, 2 },
		};

		for (auto& entry : manaSaveSecondary) {
			secCumul += entry.weight;
			if (secRoll < secCumul) {
				secondaryType = entry.type;
				if (entry.fixedVal > 0) {
					secondaryValue = entry.fixedVal;
				} else {
					secondaryValue = RollAttributeValue();
					if (secondaryValue < entry.minVal) secondaryValue = entry.minVal;
					if (entry.maxVal > 0 && secondaryValue > entry.maxVal) secondaryValue = entry.maxVal;
				}
				break;
			}
		}
		} // end 40% secondary chance
	}
	else {
		// Item has no applicable effect type
		return false;
	}

	// Clamp values to nibble range (0-15)
	if (primaryValue > 15) primaryValue = 15;
	if (secondaryValue > 15) secondaryValue = 15;

	pItem->m_cItemColor = (char)itemColor;
	pItem->m_dwAttribute = BuildAttribute(
		false, // customMade = false for drops
		primaryType,
		(uint8_t)primaryValue,
		secondaryType,
		(uint8_t)secondaryValue,
		0 // no enchant bonus
	);

	_AdjustRareItemValue(pItem);
	return true;
}

void CGame::RequestNoticementHandler(int iClientH, char* pData)
{
	char* cp;
	int iRet, iClientSize;

	if (m_pClientList[iClientH] == 0) return;
	if (m_dwNoticementDataSize < 10) return;

	const auto* pkt = hb::net::PacketCast<hb::net::PacketRequestNoticement>(
		pData, sizeof(hb::net::PacketRequestNoticement));
	if (!pkt) return;
	iClientSize = pkt->value;

	if (iClientSize != m_dwNoticementDataSize) {
		cp = new char[m_dwNoticementDataSize + 2 + sizeof(hb::net::PacketHeader)];
		std::memset(cp, 0, m_dwNoticementDataSize + 2 + sizeof(hb::net::PacketHeader));
		memcpy((cp + sizeof(hb::net::PacketHeader)), m_pNoticementData, m_dwNoticementDataSize);

		{
			auto* header = reinterpret_cast<hb::net::PacketResponseNoticementHeader*>(cp);
			header->header.msg_id = MSGID_RESPONSE_NOTICEMENT;
			header->header.msg_type = DEF_MSGTYPE_REJECT;
		}

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + sizeof(hb::net::PacketHeader));

		delete cp;
	}
	else {
		hb::net::PacketResponseNoticementHeader pkt{};
		pkt.header.msg_id = MSGID_RESPONSE_NOTICEMENT;
		pkt.header.msg_type = DEF_MSGTYPE_CONFIRM;
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
	}
}

void CGame::RequestNoticementHandler(int iClientH)
{
	DWORD lpNumberOfBytesRead;

	if (m_pClientList[iClientH] == 0) return;

	HANDLE hFile = CreateFile("GameConfigs\\Noticement.txt", GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	uint32_t dwFileSize = GetFileSize(hFile, 0);
	if (dwFileSize == -1) {
		return;
	}

	std::memset(G_cData50000, 0, sizeof(G_cData50000));

	SetFilePointer(hFile, 0, 0, FILE_BEGIN);

	ReadFile(hFile, G_cData50000 + sizeof(hb::net::PacketHeader), dwFileSize, &lpNumberOfBytesRead, 0);
	CloseHandle(hFile);

	{
		auto* header = reinterpret_cast<hb::net::PacketResponseNoticementHeader*>(G_cData50000);
		header->header.msg_id = MSGID_RESPONSE_NOTICEMENT;
		header->header.msg_type = DEF_MSGTYPE_CONFIRM;
	}

	int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(G_cData50000, dwFileSize + 2 + sizeof(hb::net::PacketHeader));

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		return;
	}
}


void CGame::RequestCheckAccountPasswordHandler(char* pData, size_t dwMsgSize)
{
	int* ip, iLevel;
	char* cp, cAccountName[11], cAccountPassword[DEF_ACCOUNT_PASS];

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader));

	std::memset(cAccountName, 0, sizeof(cAccountName));
	std::memset(cAccountPassword, 0, sizeof(cAccountPassword));

	memcpy(cAccountName, cp, DEF_ACCOUNT_NAME - 1);
	cp += 10;

	memcpy(cAccountPassword, cp, DEF_ACCOUNT_PASS - 1);
	cp += 10;

	ip = (int*)cp;
	iLevel = *ip;
	cp += 4;

	for(int i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (_stricmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {
			if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
				PutLogList(G_cTxt);
				DeleteClient(i, false, true);
				return;
			}
		}
}

void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{
	int iSkillLevel, iRange, iTamingLevel, iResult;
	short sOwnerH;
	char  cOwnerType;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pMapList[cMapIndex] == 0) return;

	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = iSkillLevel / 12;

	for(int iX = dX - iRange; iX <= dX + iRange; iX++)
		for(int iY = dY - iRange; iY <= dY + iRange; iY++) {
			sOwnerH = 0;
			if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
				m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

			if (sOwnerH != 0) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == 0) break;
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == 0) break;
					iTamingLevel = 10;
					switch (m_pNpcList[sOwnerH]->m_sType) {
					case 10:
					case 16: iTamingLevel = 1; break;
					case 22: iTamingLevel = 2; break;
					case 17:
					case 14: iTamingLevel = 3; break;
					case 18: iTamingLevel = 4; break;
					case 11: iTamingLevel = 5; break;
					case 23:
					case 12: iTamingLevel = 6; break;
					case 28: iTamingLevel = 7; break;
					case 13:
					case 27: iTamingLevel = 8; break;
					case 29: iTamingLevel = 9; break;
					case 33: iTamingLevel = 9; break;
					case 30: iTamingLevel = 9; break;
					case 31:
					case 32: iTamingLevel = 10; break;
					}

					iResult = (iSkillLevel / 10);

					if (iResult < iTamingLevel) break;

					break;
				}
			}
		}
}

void CGame::GetMagicAbilityHandler(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] != 0) return;

	m_pClientList[iClientH]->m_cSkillMastery[4] = 20;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], 0, 0);
	bCheckTotalSkillMasteryPoints(iClientH, 4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char* pData)
{
	char cDir, mapData[3000];
	short dX, dY;
	int   iRet, iSize;

	if (m_pClientList[iClientH] == 0) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == false) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return 0;

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestPanning>(pData, sizeof(hb::net::PacketRequestPanning));
	if (!req) return 0;
	cDir = static_cast<char>(req->dir);
	if ((cDir <= 0) || (cDir > 8)) return 0;

	switch (cDir) {
	case 1:	dY--; break; // responding when mouse is placed north
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break; // responding when mouse placed at west side of screen
	case 8:	dX--; dY--;	break; // responding when mouse is placed north west
		/*
		player is in the center, and is trying to pan,
		directions not responding or causing a break will be kept as X,
		others are the cDir case...
				8	1	X

				7	_	X

				X	X	X
		*/
	}

	m_pClientList[iClientH]->m_sX = dX;
	m_pClientList[iClientH]->m_sY = dY;
	m_pClientList[iClientH]->m_cDir = cDir;

	iSize = iComposeMoveMapData((short)(dX - DEF_VIEWCENTER_X), (short)(dY - DEF_VIEWCENTER_Y), iClientH, cDir, mapData);

	hb::net::PacketWriter writer;
	writer.Reserve(sizeof(hb::net::PacketResponsePanningHeader) + iSize);

	auto* pkt = writer.Append<hb::net::PacketResponsePanningHeader>();
	pkt->header.msg_id = MSGID_RESPONSE_PANNING;
	pkt->header.msg_type = DEF_OBJECTMOVE_CONFIRM;
	pkt->x = static_cast<int16_t>(dX - DEF_VIEWCENTER_X);
	pkt->y = static_cast<int16_t>(dY - DEF_VIEWCENTER_Y);
	pkt->dir = static_cast<uint8_t>(cDir);

	writer.AppendBytes(mapData, iSize);

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		return 0;
	}

	return 1;
}

void CGame::RequestRestartHandler(int iClientH)
{
	char  cTmpMap[32];

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_bIsKilled) {

		strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);
		std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));

		if (strcmp(m_pClientList[iClientH]->m_cLocation, "NONE") == 0) {
			// default .
			strcpy(m_pClientList[iClientH]->m_cMapName, "default");
		}
		else {
			if ((strcmp(m_pClientList[iClientH]->m_cLocation, "aresden") == 0) || (strcmp(m_pClientList[iClientH]->m_cLocation, "arehunter") == 0)) {
				if (m_bIsCrusadeMode) {
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
						m_pClientList[iClientH]->m_iLockedMapTime = 60 * 5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
					}
				}
				// v2.16 2002-5-31
				if (strcmp(cTmpMap, "elvine") == 0) {
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60 * 3;
				}
				else if (m_pClientList[iClientH]->m_iLevel > 80)
					memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
			}
			else {
				if (m_bIsCrusadeMode) {
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						std::memset(m_pClientList[iClientH]->m_cLockedMapName, 0, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
						m_pClientList[iClientH]->m_iLockedMapTime = 60 * 5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60 * 10;
					}
				}
				if (strcmp(cTmpMap, "aresden") == 0) {
					memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60 * 3;

				}
				else if (m_pClientList[iClientH]->m_iLevel > 80)
					memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
			}
		}

		m_pClientList[iClientH]->m_bIsKilled = false;
		m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH);
		m_pClientList[iClientH]->m_iHungerStatus = 100;

		std::memset(cTmpMap, 0, sizeof(cTmpMap));
		strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);
		// !!! RequestTeleportHandler m_cMapName
		RequestTeleportHandler(iClientH, "2   ", cTmpMap, -1, -1);
	}
}

void CGame::RequestSellItemListHandler(int iClientH, char* pData)
{
	int iAmount;
	char cIndex;

	if (m_pClientList[iClientH] == 0) return;

	const auto* req = hb::net::PacketCast<hb::net::PacketRequestSellItemList>(pData, sizeof(hb::net::PacketRequestSellItemList));
	if (!req) return;

	for(int i = 0; i < 12; i++) {
		cIndex = static_cast<char>(req->entries[i].index);
		iAmount = req->entries[i].amount;

		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= hb::limits::MaxItems)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == 0) return;

		// cIndex   .
		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, 0);
		if (m_pClientList[iClientH] == 0) return;
	}
}

void CGame::RequestShopContentsHandler(int iClientH, char* pData)
{
	if (m_pClientList[iClientH] == 0) return;
	if (!m_bIsShopDataAvailable) {
		// No shop data configured
		return;
	}

	const auto* req = hb::net::PacketCast<hb::net::PacketShopRequest>(pData, sizeof(hb::net::PacketShopRequest));
	if (!req) return;

	int16_t npcType = req->npcType;

	// Look up shop ID for this NPC type
	auto mappingIt = m_NpcShopMappings.find(static_cast<int>(npcType));
	if (mappingIt == m_NpcShopMappings.end()) {
		// No shop configured for this NPC type
		char logMsg[128];
		std::snprintf(logMsg, sizeof(logMsg), "(!) Shop request for NPC type %d - no shop mapping found", npcType);
		PutLogList(logMsg);
		return;
	}

	int shopId = mappingIt->second;

	// Get shop data
	auto shopIt = m_ShopData.find(shopId);
	if (shopIt == m_ShopData.end() || shopIt->second.itemIds.empty()) {
		// Shop exists in mapping but has no items
		char logMsg[128];
		std::snprintf(logMsg, sizeof(logMsg), "(!) Shop request for NPC type %d, shop %d - no items found", npcType, shopId);
		PutLogList(logMsg);
		return;
	}

	const ShopData& shop = shopIt->second;
	uint16_t itemCount = static_cast<uint16_t>(shop.itemIds.size());
	if (itemCount > hb::net::MAX_SHOP_ITEMS) {
		itemCount = hb::net::MAX_SHOP_ITEMS;
	}

	// Build response packet
	// Header + array of int16_t item IDs
	size_t packetSize = sizeof(hb::net::PacketShopResponseHeader) + (itemCount * sizeof(int16_t));
	char* cData = new char[packetSize];
	std::memset(cData, 0, packetSize);

	auto* resp = reinterpret_cast<hb::net::PacketShopResponseHeader*>(cData);
	resp->header.msg_id = MSGID_RESPONSE_SHOP_CONTENTS;
	resp->header.msg_type = DEF_MSGTYPE_CONFIRM;
	resp->npcType = npcType;
	resp->shopId = static_cast<int16_t>(shopId);
	resp->itemCount = itemCount;

	// Copy item IDs after header
	int16_t* itemIds = reinterpret_cast<int16_t*>(cData + sizeof(hb::net::PacketShopResponseHeader));
	for (uint16_t i = 0; i < itemCount; i++) {
		itemIds[i] = shop.itemIds[i];
	}

	// Send to client
	m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, static_cast<uint32_t>(packetSize));

	char logMsg[128];
	std::snprintf(logMsg, sizeof(logMsg), "(!) Sent shop contents: NPC type %d, shop %d, %d items", npcType, shopId, itemCount);
	PutLogList(logMsg);

	delete[] cData;
}

void CGame::JoinPartyHandler(int iClientH, int iV1, const char* pMemberName)
{
	char* cp, cData[120];
	uint32_t* dwp;
	uint16_t* wp;
	

	if (m_pClientList[iClientH] == 0) return;

	switch (iV1) {
	case 0:
		RequestDeletePartyHandler(iClientH);
		break;

	case 1:
		//testcode
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Join Party Req: %s(%d) ID(%d) Stat(%d) ReqJoinH(%d) ReqJoinName(%s)", m_pClientList[iClientH]->m_cCharName, iClientH,
			m_pClientList[iClientH]->m_iPartyID, m_pClientList[iClientH]->m_iPartyStatus, m_pClientList[iClientH]->m_iReqJoinPartyClientH,
			m_pClientList[iClientH]->m_cReqJoinPartyName);
		PutLogList(G_cTxt);

		if ((m_pClientList[iClientH]->m_iPartyID != 0) || (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL)) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
			std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			//testcode
			PutLogList("Join Party Reject (1)");
			return;
		}

		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (_stricmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) {
				if (m_pClientList[i]->m_appearance.bIsWalking) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
					//testcode
					PutLogList("Join Party Reject (2)");
				}
				else if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
					//testcode
					PutLogList("Join Party Reject (3)");
				}
				else if (m_pClientList[i]->m_iPartyStatus == DEF_PARTYSTATUS_PROCESSING) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
					//testcode
					PutLogList("Join Party Reject (4)");
					//testcode
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Party join reject(2) ClientH:%d ID:%d JoinName:%s", i, m_pClientList[i]->m_iPartyID, m_pClientList[i]->m_cReqJoinPartyName);
					PutLogList(G_cTxt);

					m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
					std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				}
				else {
					m_pClientList[i]->m_iReqJoinPartyClientH = iClientH;
					std::memset(m_pClientList[i]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[i]->m_cReqJoinPartyName));
					strcpy(m_pClientList[i]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName);
					SendNotifyMsg(0, i, DEF_NOTIFY_QUERY_JOINPARTY, 0, 0, 0, m_pClientList[iClientH]->m_cCharName);

					m_pClientList[iClientH]->m_iReqJoinPartyClientH = i;
					std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					strcpy(m_pClientList[iClientH]->m_cReqJoinPartyName, m_pClientList[i]->m_cCharName);
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
				}
				return;
			}
		break;

	case 2:
		if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) {
			std::memset(cData, 0, sizeof(cData));
			cp = (char*)cData;
			dwp = (uint32_t*)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (uint16_t*)cp;
			*wp = 6;
			cp += 2;
			wp = (uint16_t*)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
			cp += 10;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			PartyOperation(cData);
		}
		break;
	}
}


bool CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{
	int sX, sY, dX, dY, iGoalMapIndex;
	char cResult;

	if (m_pNpcList[iNpcH] == 0) return false;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex == -1) return false;

	if (m_pNpcList[iNpcH]->m_cMapIndex != m_iMiddlelandMapIndex) {
		iGoalMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;

		cResult = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX - 2) && (sX <= dX + 2) && (sY >= dY - 2) && (sY <= dY + 2)) {
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					m_pClientList[sAttackerH]->m_iContribution += 5;
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}

				for(int i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
						SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
					}
			}
			return true;
		}

		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX - 2) && (sX <= dX + 2) && (sY >= dY - 2) && (sY <= dY + 2)) {
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					m_pClientList[sAttackerH]->m_iContribution += 5;
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) EnergySphere Hit By Elvine Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}

				for(int i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
						SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
					}
			}
		}
		return false;
	}
	else {

		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;

		cResult = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX - 4) && (sX <= dX + 4) && (sY >= dY - 4) && (sY <= dY + 4)) {
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					m_pClientList[sAttackerH]->m_iContribution += 5;
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}

				for(int i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
						SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
					}
			}
			return true;
		}

		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX - 4) && (sX <= dX + 4) && (sY >= dY - 4) && (sY <= dY + 4)) {
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					m_pClientList[sAttackerH]->m_iContribution += 5;
					std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}

				for(int i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
						SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
					}
			}
			return true;
		}
		return false;
	}
}

void CGame::EnergySphereProcessor()
{
	int iNamingValue, iCIndex, iTemp, pX, pY;
	char cSA, cName_Internal[31], cWaypoint[31];

	if (m_iMiddlelandMapIndex < 0) return;
	if (m_pMapList[m_iMiddlelandMapIndex] == 0) return;
	if (iDice(1, 2000) != 123) return;
	if (m_iTotalGameServerClients < 500) return;

	if (m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

	iCIndex = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereCreationPoint);

	if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == 0) return;

	cSA = 0;
	pX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
	pY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
	std::memset(cWaypoint, 0, sizeof(cWaypoint));

	iNamingValue = m_pMapList[m_iMiddlelandMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
		std::memset(cName_Internal, 0, sizeof(cName_Internal));
		std::snprintf(cName_Internal, sizeof(cName_Internal), "XX%d", iNamingValue);
		cName_Internal[0] = '_';
		cName_Internal[1] = m_iMiddlelandMapIndex + 65;

		if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_iMiddlelandMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false)) == false) {
			m_pMapList[m_iMiddlelandMapIndex]->SetNamingValueEmpty(iNamingValue);
			return;
		}
	}

	iTemp = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereGoalPoint);
	if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == 0) return;

	m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
			SendNotifyMsg(0, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, 0, 0);
		}

	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Energy Sphere Created! (%d, %d)", pX, pY);
	PutLogList(G_cTxt);
	PutLogFileList(G_cTxt);
}


void CGame::ActivateSpecialAbilityHandler(int iClientH)
{
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled) return;

	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = true;
	m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;

	m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;

	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		m_pClientList[iClientH]->m_appearance.iEffectType = 1;
		break;
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
		m_pClientList[iClientH]->m_appearance.iEffectType = 2;
		break;
	}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, 0);
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}

void CGame::CancelQuestHandler(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	_ClearQuestStatus(iClientH);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_QUESTABORTED, 0, 0, 0, 0);
}

int CGame::iGetItemWeight(CItem* pItem, int iCount)
{
	int iWeight;

	// . Gold   20 1
	iWeight = (pItem->m_wWeight);
	if (iCount < 0) iCount = 1;
	iWeight = iWeight * iCount;
	if (pItem->m_sIDnum == 90) iWeight = iWeight / 20;
	if (iWeight <= 0) iWeight = 1;

	return iWeight;
}

void CGame::UpdateMapSectorInfo()
{
	int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;

	for(int i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) {

			iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;
			m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
			m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
			m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

			// TempSectorInfo   SectorInfo   TempSectorInfo .
			for(int ix = 0; ix < DEF_MAXSECTORS; ix++)
				for(int iy = 0; iy < DEF_MAXSECTORS; iy++) {
					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
						iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
						m_pMapList[i]->m_iMaxNx = ix;
						m_pMapList[i]->m_iMaxNy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
						iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
						m_pMapList[i]->m_iMaxAx = ix;
						m_pMapList[i]->m_iMaxAy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
						iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
						m_pMapList[i]->m_iMaxEx = ix;
						m_pMapList[i]->m_iMaxEy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
						iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
						m_pMapList[i]->m_iMaxMx = ix;
						m_pMapList[i]->m_iMaxMy = iy;
					}

					if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
						iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
						m_pMapList[i]->m_iMaxPx = ix;
						m_pMapList[i]->m_iMaxPy = iy;
					}
				}

			// TempSectorInfo .
			m_pMapList[i]->ClearTempSectorInfo();

			// Sector Info
			if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
			if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
			if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
			if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
			if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
		}
}


void CGame::AgingMapSectorInfo()
{
	for(int i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) {
			for(int ix = 0; ix < DEF_MAXSECTORS; ix++)
				for(int iy = 0; iy < DEF_MAXSECTORS; iy++) {
					m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
					m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;

					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
					if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity = 0;
				}
		}
}


bool CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
	int iNamingValue, tX, tY;
	char cNpcName[DEF_NPCNAME], cName[DEF_NPCNAME], cNpcWaypoint[11], cOwnerType;
	short sOwnerH;

	if ((m_bIsCrusadeMode == false) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return false;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= hb::limits::MaxCrusadeStructures) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOMORECRUSADESTRUCTURE, 0, 0, 0, 0);
		return false;
	}

	// NPC .
	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// NPC  .     .
	}
	else {

		for(int ix = dX - 3; ix <= dX + 5; ix++)
			for(int iy = dY - 3; iy <= dX + 5; iy++) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) return false;
			}

		// NPC .
		std::memset(cNpcName, 0, sizeof(cNpcName));
		if (m_pClientList[iClientH]->m_cSide == 1) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Aresden"); break;
			case 2: strcpy(cNpcName, "CGT-Aresen"); break;
			case 3: strcpy(cNpcName, "MS-Aresden"); break;
			case 4: strcpy(cNpcName, "DT-Aresden"); break;
			}
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Elvine"); break;
			case 2: strcpy(cNpcName, "CGT-Elvine"); break;
			case 3: strcpy(cNpcName, "MS-Elvine"); break;
			case 4: strcpy(cNpcName, "DT-Elvine"); break;
			}
		}
		else return false;

		std::memset(cName, 0, sizeof(cName));
		std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

		std::memset(cNpcWaypoint, 0, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, (rand() % 9),
			DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, 0, 0, -1, false, false) == false) {
			// NameValue .
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
		else {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
			PutLogList(G_cTxt);
			return true;
		}
	}

	return false;
}

void CGame::LocalStartCrusadeMode(uint32_t dwCrusadeGUID)
{
	

	if (m_bIsCrusadeMode) return;
	m_bIsCrusadeMode = true;
	m_iCrusadeWinnerSide = 0;

	if (dwCrusadeGUID != 0) {
		// GUID  .
		_CreateCrusadeGUID(dwCrusadeGUID, 0);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
			m_pClientList[i]->m_iCrusadeDuty = 0;
			m_pClientList[i]->m_iConstructionPoint = 0;
			m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			SendNotifyMsg(0, i, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, m_pClientList[i]->m_iCrusadeDuty, 0, 0);
		}

	for(int i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) m_pMapList[i]->RestoreStrikePoints();

	CreateCrusadeStructures();

	PutLogList("(!)Crusade Mode ON.");
}

void CGame::LocalEndCrusadeMode(int iWinnerSide)
{
	

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "LocalEndCrusadeMode(%d)", iWinnerSide);
	PutLogList(G_cTxt);

	if (m_bIsCrusadeMode == false) return;
	m_bIsCrusadeMode = false;

	PutLogList("(!)Crusade Mode OFF.");

	RemoveCrusadeStructures();

	RemoveCrusadeNpcs();

	_CreateCrusadeGUID(m_dwCrusadeGUID, iWinnerSide);
	m_iCrusadeWinnerSide = iWinnerSide;
	m_iLastCrusadeWinner = iWinnerSide;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
			m_pClientList[i]->m_iCrusadeDuty = 0;
			m_pClientList[i]->m_iConstructionPoint = 0;
			SendNotifyMsg(0, i, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, 0, 0, m_iCrusadeWinnerSide);
		}
	RemoveCrusadeRecallTime();

	if (m_iMiddlelandMapIndex != -1) {
		//bSendMsgToLS(0x3D00123C, 0, true, 0);
	}
}


void CGame::CreateCrusadeStructures()
{
	int z, tX, tY, iNamingValue;
	char cName[6], cNpcName[DEF_NPCNAME], cNpcWayPoint[11];

	std::memset(cName, 0, sizeof(cName));
	std::memset(cNpcName, 0, sizeof(cNpcName));
	std::memset(cNpcWayPoint, 0, sizeof(cNpcWayPoint));

	for(int i = 0; i < hb::limits::MaxCrusadeStructures; i++)
		if (m_stCrusadeStructures[i].cType != 0) {
			for (z = 0; z < DEF_MAXMAPS; z++)
				if ((m_pMapList[z] != 0) && (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) {
					iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						// NPC  .     .
					}
					else {
						// NPC .
						std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
						cName[0] = '_';
						cName[1] = z + 65;

						switch (m_stCrusadeStructures[i].cType) {
						case 36:
							if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
								strcpy(cNpcName, "AGT-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
								strcpy(cNpcName, "AGT-Elvine");
							break;

						case 37:
							if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
								strcpy(cNpcName, "CGT-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
								strcpy(cNpcName, "CGT-Elvine");
							break;

						case 40:
							if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
								strcpy(cNpcName, "ESG-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
								strcpy(cNpcName, "ESG-Elvine");
							break;

						case 41:
							if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
								strcpy(cNpcName, "GMG-Aresden");
							else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
								strcpy(cNpcName, "GMG-Elvine");
							break;

						case 42:
							strcpy(cNpcName, "ManaStone");
							break;

						default:
							strcpy(cNpcName, m_pNpcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName);
							break;
						}

						tX = (int)m_stCrusadeStructures[i].dX;
						tY = (int)m_stCrusadeStructures[i].dY;
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM,
							&tX, &tY, cNpcWayPoint, 0, 0, -1, false) == false) {
							// NameValue .
							m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
						}
						else {
							std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
							PutLogList(G_cTxt);
						}
					}
				}
		}
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, const char* pMapName)
{
	int iIndex;
	uint32_t dwTemp, dwTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;

	dwTime = GameClock::GetTimeMS();

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// GUID       .
	for(int i = 0; i < DEF_MAXGUILDS; i++)
	{
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
			else {
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				std::memset(m_pGuildTeleportLoc[i].m_cDestMapName2, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
		}
	}

	dwTemp = 0;
	iIndex = -1;
	for(int i = 0; i < DEF_MAXGUILDS; i++) {
		{
			if (m_pGuildTeleportLoc[i].m_iV1 == 0) {

				m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
				m_pGuildTeleportLoc[i].m_sDestX2 = dX;
				m_pGuildTeleportLoc[i].m_sDestY2 = dY;
				std::memset(m_pGuildTeleportLoc[i].m_cDestMapName2, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				return;
			}
			else {
				if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
					dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
					iIndex = i;
				}
			}
		}
	}

	// .         (iIndex)   .
	//if (iIndex == -1) return;

	////testcode
	//PutLogList("(X) No more GuildConstructLoc Space! Replaced.");

	//m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	//m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	//m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	//std::memset(m_pGuildTeleportLoc[i].m_cDestMapName2, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	//strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	//m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
}

// New 14/05/2004 Changed
void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
	char cName[6], cNpcName[DEF_NPCNAME], cMapName[11], cNpcWayPoint[11], cOwnerType;
	int x;
	int iNamingValue, tX, tY;
	int bRet;
	short sOwnerH;
	uint32_t dwTime = GameClock::GetTimeMS();

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	//hbest - crusade units summon mapcheck
	if (((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "toh3") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "icebound") == 0))) {
		return;
	}

	std::memset(cNpcWayPoint, 0, sizeof(cNpcWayPoint));
	std::memset(cNpcName, 0, sizeof(cNpcName));
	std::memset(cMapName, 0, sizeof(cMapName));

	if (cType < 0) return;
	if (cType >= DEF_MAXNPCTYPES) return;
	if (cNum > 10) return;

	if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != 0) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)) return;

	cNum = 1;

	// ConstructionPoint     .
	for (x = 1; x <= cNum; x++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
			// NPC  .     .
		}
		else {
			// NPC .
			std::memset(cName, 0, sizeof(cName));
			std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;


			switch (cType) {
			case 43: // Light War Beetle
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "LWB-Aresden"); break;
				case 2: strcpy(cNpcName, "LWB-Elvine"); break;
				}
				break;

			case 36: // Arrow Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGT-Aresden"); break;
				case 2: strcpy(cNpcName, "AGT-Elvine"); break;
				}
				break;

			case 37: // Cannon Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CGT-Aresden"); break;
				case 2: strcpy(cNpcName, "CGT-Elvine"); break;
				}
				break;

			case 38: // Mana Collector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "MS-Aresden"); break;
				case 2: strcpy(cNpcName, "MS-Elvine"); break;
				}
				break;

			case 39: // Detector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DT-Aresden"); break;
				case 2: strcpy(cNpcName, "DT-Elvine"); break;
				}
				break;

			case 51: // Catapult
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CP-Aresden"); break;
				case 2: strcpy(cNpcName, "CP-Elvine"); break;
				}
				break;

			case 44:
				strcpy(cNpcName, "GHK");
				break;

			case 45:
				strcpy(cNpcName, "GHKABS");
				break;

			case 46:
				strcpy(cNpcName, "TK");
				break;

			case 47:
				strcpy(cNpcName, "BG");
				break;

			case 82:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "Sor-Aresden"); break;
				case 2: strcpy(cNpcName, "Sor-Elvine"); break;
				}
				break;

			case 83:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "ATK-Aresden"); break;
				case 2: strcpy(cNpcName, "ATK-Elvine"); break;
				}
				break;

			case 84:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "Elf-Aresden"); break;
				case 2: strcpy(cNpcName, "Elf-Elvine"); break;
				}
				break;

			case 85:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DSK-Aresden"); break;
				case 2: strcpy(cNpcName, "DSK-Elvine"); break;
				}
				break;

			case 86:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "HBT-Aresden"); break;
				case 2: strcpy(cNpcName, "HBT-Elvine"); break;
				}
				break;

			case 87:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CT-Aresden"); break;
				case 2: strcpy(cNpcName, "CT-Elvine"); break;
				}
				break;

			case 88:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "Bar-Aresden"); break;
				case 2: strcpy(cNpcName, "Bar-Elvine"); break;
				}
				break;

			case 89:
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGC-Aresden"); break;
				case 2: strcpy(cNpcName, "AGC-Elvine"); break;
				}
				break;
			}

			//testcode
			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Request Summon War Unit (%d) (%s)", cType, cNpcName);
			PutLogList(G_cTxt);

			tX = (int)dX;
			tY = (int)dY;

			bRet = false;
			switch (cType) {
			case 36:
			case 37:
			case 38:
			case 39:
				if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = true;
				if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = true;
				if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = true;

				if (bRet) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 2, 0, 0, 0);
					return;
				}

				for(int i = 0; i < DEF_MAXGUILDS; i++)
					if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
						m_pGuildTeleportLoc[i].m_dwTime = dwTime;
						if (m_pGuildTeleportLoc[i].m_iV2 >= DEF_MAXCONSTRUCTNUM) {
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
							SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, 0, 0, 0);
							return;
						}
						else {
							m_pGuildTeleportLoc[i].m_iV2++;
							goto RSWU_LOOPBREAK;
						}
					}

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, 0, 0, 0);
				return;
				break;
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 51:
				break;

			case 40:
			case 41:
			case 42:
			case 48:
			case 49:
			case 50:
				break;
			}

		RSWU_LOOPBREAK:

			bRet = false;
			switch (cType) {
			case 36:
			case 37:
				for(int ix = tX - 2; ix <= tX + 2; ix++)
					for(int iy = tY - 2; iy <= tY + 2; iy++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((sOwnerH != 0) && (cOwnerType == DEF_OWNERTYPE_NPC)) {
							switch (m_pNpcList[sOwnerH]->m_sType) {
							case 36:
							case 37:
								bRet = true;
								break;
							}
						}
					}

				if ((dY <= 32) || (dY >= 783)) bRet = true;
				break;
			}

			if (bRet) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 1, 0, 0, 0);
				return;
			}

			if (cMode == 0) {
				bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, 0, 0, -1, false, false, false, false, m_pClientList[iClientH]->m_iGuildGUID);
				if (m_pEntityManager != 0) m_pEntityManager->bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, DEF_OWNERTYPE_PLAYER);
			}
			else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, 0, 0, -1, false, false, false, false, m_pClientList[iClientH]->m_iGuildGUID);

			if (bRet == false) {
				// NameValue .
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
				if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 0, 0);
			}
		}
	}
}

void CGame::CheckConnectionHandler(int iClientH, char* pData, bool bAlreadyResponded)
{
	uint32_t dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;

	if (m_pClientList[iClientH] == 0) return;

	dwTime = GameClock::GetTimeMS();
	const auto* req = hb::net::PacketCast<hb::net::PacketCommandCheckConnection>(pData, sizeof(hb::net::PacketCommandCheckConnection));
	if (!req) return;
	dwTimeRcv = req->time_ms;

	if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == 0) {
		m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
		m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
	}
	else {
		dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
		dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);

		if (dwTimeGapClient < dwTimeGapServer) return;
		if ((dwTimeGapClient - dwTimeGapServer) >= (uint32_t)m_iClientTimeout) {
			DeleteClient(iClientH, true, true);
			return;
		}
	}

	if (!bAlreadyResponded) {
		hb::net::PacketCommandCheckConnection resp{};
		resp.header.msg_id = MSGID_COMMAND_CHECKCONNECTION;
		resp.header.msg_type = DEF_MSGTYPE_CONFIRM;
		resp.time_ms = dwTimeRcv;
		m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&resp), sizeof(resp));
	}
}

void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{

	if (m_pClientList[iClientH] == 0) return;
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;

	if (m_iLastCrusadeWinner == m_pClientList[iClientH]->m_cSide &&
		m_pClientList[iClientH]->m_dwCrusadeGUID == 0 && iDuty == 3) {
		m_pClientList[iClientH]->m_iConstructionPoint = 3000;
	}
	m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, 0, 0);
}

void CGame::MapStatusHandler(int iClientH, int iMode, const char* pMapName)
{
	

	if (m_pClientList[iClientH] == 0) return;

	switch (iMode) {
	case 1:
		if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) return;

		for(int i = 0; i < DEF_MAXGUILDS; i++)
			if ((m_pGuildTeleportLoc[i].m_iV1 != 0) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
					0, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
					0, 0, 0, 0, m_pGuildTeleportLoc[i].m_cDestMapName2);
				std::memset(m_pClientList[iClientH]->m_cConstructMapName, 0, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
				memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
				m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
				m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
				return;
			}

		break;

	case 3:
		//if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) return;
		for(int i = 0; i < hb::limits::MaxCrusadeStructures; i++) {
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = 0;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = 0;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = 0;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = 0;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = 0;
		std::memset(m_pClientList[iClientH]->m_cSendingMapName, 0, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
			for(int i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
				if (m_pClientList[iClientH]->m_iCrusadeDuty == 3)
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
				else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42)
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}
		else {
			if (strcmp(pMapName, "middleland") == 0) {
				for(int i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
					if (m_pClientList[iClientH]->m_iCrusadeDuty == 3)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_stMiddleCrusadeStructureInfo[i].sY;
					}
					else if (m_stMiddleCrusadeStructureInfo[i].cType == 42)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = m_stMiddleCrusadeStructureInfo[i].sY;
					}
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}
			else {
			}
		}

		_SendMapStatus(iClientH);
		break;
	}
}

void CGame::_SendMapStatus(int iClientH)
{
	int iDataSize;
	char* cp, cData[hb::limits::MaxCrusadeStructures * 6];
	short* sp;

	cp = (char*)(cData);

	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;

	sp = (short*)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;

	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == 0)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = true;

	// 100  .
	iDataSize = 0;
	for(int i = 0; i < 100; i++) {
		if (m_pClientList[iClientH]->m_iCSIsendPoint >= hb::limits::MaxCrusadeStructures) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == 0) goto SMS_ENDOFDATA;

		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short*)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short*)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;

		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}

	cp = (char*)(cData + 12);
	*cp = (iDataSize / 6);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAPSTATUSNEXT, iDataSize + 13, 0, 0, cData);
	return;

SMS_ENDOFDATA:

	cp = (char*)(cData + 12);
	*cp = (iDataSize / 6);
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_MAPSTATUSLAST, iDataSize + 13, 0, 0, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = false;

	return;
}


void CGame::RemoveCrusadeStructures()
{
	

	for(int i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != 0) {
			switch (m_pNpcList[i]->m_sType) {
			case 36:
			case 37:
			case 38:
			case 39:
			case 40:
			case 41:
			case 42:
				// Use EntityManager for NPC deletion
				if (m_pEntityManager != NULL)
					m_pEntityManager->DeleteEntity(i);
				break;
			}
		}
}

void CGame::RequestHelpHandler(int iClientH)
{
	

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iGuildRank == -1) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 1) return;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iGuildRank == 0) &&
			(m_pClientList[i]->m_iCrusadeDuty == 3) && (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
			SendNotifyMsg(0, i, DEF_NOTIFY_HELP, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_cCharName);
			return;
		}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELPFAILED, 0, 0, 0, 0);
}

void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
	int iDamage;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_cSide != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
			if (m_pClientList[i]->m_iLevel < 80)
				iDamage = m_pClientList[i]->m_iLevel + iDice(1, 10);
			else iDamage = m_pClientList[i]->m_iLevel * 2 + iDice(1, 10);
			iDamage = iDice(1, m_pClientList[i]->m_iLevel) + m_pClientList[i]->m_iLevel;
			// 255   .
			if (iDamage > 255) iDamage = 255;

			if (m_pClientList[i]->m_cMagicEffectStatus[hb::magic::Protect] == 2) { //magic cut in half
				iDamage = (iDamage / 2) - 2;
			}

			if (m_pClientList[i]->m_cMagicEffectStatus[hb::magic::Protect] == 5) {
				iDamage = 0;
			}

			m_pClientList[i]->m_iHP -= iDamage;
			if (m_pClientList[i]->m_iHP <= 0) {
				ClientKilledHandler(i, 0, 0, iDamage);
				m_stMeteorStrikeResult.iCasualties++;
			}
			else {
				if (iDamage > 0) {
					SendNotifyMsg(0, i, DEF_NOTIFY_HP, 0, 0, 0, 0);
					SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);

					if (m_pClientList[i]->m_bSkillUsingStatus[19] != true) {
						m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
						m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					}

					if (m_pClientList[i]->m_cMagicEffectStatus[hb::magic::HoldObject] != 0) {
						// Hold-Person    .     .
						// 1: Hold-Person 
						// 2: Paralize
						SendNotifyMsg(0, i, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::HoldObject, m_pClientList[i]->m_cMagicEffectStatus[hb::magic::HoldObject], 0, 0);

						m_pClientList[i]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
						bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, hb::magic::HoldObject);
					}
				}
			}
		}
}

void CGame::SyncMiddlelandMapInfo()
{
	

	if (m_iMiddlelandMapIndex != -1) {
		for(int i = 0; i < hb::limits::MaxCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = 0;
			m_stMiddleCrusadeStructureInfo[i].cSide = 0;
			m_stMiddleCrusadeStructureInfo[i].sX = 0;
			m_stMiddleCrusadeStructureInfo[i].sY = 0;
		}
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		for(int i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;

			/**cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;*/
		}

		if (m_iTotalMiddleCrusadeStructures != 0) {
			//testcode
			//std::snprintf(G_cTxt, sizeof(G_cTxt), "m_iTotalMiddleCrusadeStructures: %d", m_iTotalMiddleCrusadeStructures);
			//PutLogList(G_cTxt);
		}
	}
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{
	

	if (m_pClientList[iClientH] == 0) return;
	if (m_bIsCrusadeMode == false) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1:
	case 2:
		for(int i = 0; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
				(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
				m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;
				m_pClientList[i]->m_iWarContribution += (m_pClientList[iClientH]->m_iConstructionPoint / 10);

				if (m_pClientList[i]->m_iConstructionPoint > m_iMaxConstructionPoints)
					m_pClientList[i]->m_iConstructionPoint = m_iMaxConstructionPoints;

				if (m_pClientList[i]->m_iWarContribution > m_iMaxWarContribution)
					m_pClientList[i]->m_iWarContribution = m_iMaxWarContribution;

				SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 0, 0);
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
				return;
			}

		m_pClientList[iClientH]->m_iConstructionPoint = 0;
		break;

	case 3:

		break;
	}
}

bool CGame::bAddClientShortCut(int iClientH)
{
	


	for(int i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_iClientShortCut[i] == iClientH) return false;

	for(int i = 0; i < DEF_MAXCLIENTS; i++)
		if (m_iClientShortCut[i] == 0) {
			m_iClientShortCut[i] = iClientH;
			return true;
		}

	return false;
}

void CGame::RemoveClientShortCut(int iClientH)
{
	

	for(int i = 0; i < DEF_MAXCLIENTS + 1; i++)
		if (m_iClientShortCut[i] == iClientH) {
			m_iClientShortCut[i] = 0;
			goto RCSC_LOOPBREAK;
		}

RCSC_LOOPBREAK:

	//m_iClientShortCut[i] = m_iClientShortCut[m_iTotalClients+1];
	//m_iClientShortCut[m_iTotalClients+1] = 0;
	for(int i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i + 1] != 0)) {
			m_iClientShortCut[i] = m_iClientShortCut[i + 1];
			m_iClientShortCut[i + 1] = 0;
		}
}

void CGame::_CreateCrusadeGUID(uint32_t dwCrusadeGUID, int iWinnerSide)
{
	char* cp, cTxt[256], cFn[256], cTemp[1024];
	FILE* pFile;

#ifdef _WIN32
	_mkdir("GameData");
#endif
	std::memset(cFn, 0, sizeof(cFn));

	strcat(cFn, "GameData");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, "CrusadeGUID.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == 0) {
		std::snprintf(cTxt, sizeof(cTxt), "(!) Cannot create CrusadeGUID(%d) file", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	else {
		std::memset(cTemp, 0, sizeof(cTemp));

		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "CrusadeGUID = %d\n", dwCrusadeGUID);
		strcat(cTemp, cTxt);

		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);

		cp = (char*)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);

		std::snprintf(cTxt, sizeof(cTxt), "(O) CrusadeGUID(%d) file created", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	if (pFile != 0) fclose(pFile);
}


bool CGame::bReadCrusadeGUIDFile(char* cFn)
{
	FILE* pFile;
	HANDLE hFile;
	uint32_t  dwFileSize;
	char* cp, * token, cReadMode;
	char seps[] = "= \t\r\n";

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		return false;
	}
	else {
		cp = new char[dwFileSize + 2];
		std::memset(cp, 0, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok(cp, seps);

		while (token != 0) {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = atoi(token);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "CrusadeGUID = %d", m_dwCrusadeGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;

				case 2:
					// New 13/05/2004 Changed
					m_iLastCrusadeWinner = atoi(token);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "CrusadeWinnerSide = %d", m_iLastCrusadeWinner);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "CrusadeGUID", 11) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}

			token = strtok(NULL, seps);
		}

		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

void CGame::ManualEndCrusadeMode(int iWinnerSide)
{


	if (m_bIsCrusadeMode == false) return;

	LocalEndCrusadeMode(iWinnerSide);
}

int CGame::iGetMapLocationSide(char* pMapName)
{

	if (strcmp(pMapName, "aresden") == 0) return 3;
	if (strcmp(pMapName, "elvine") == 0) return 4;
	if (strcmp(pMapName, "arebrk11") == 0) return 3;
	if (strcmp(pMapName, "elvbrk11") == 0) return 4;

	if (strcmp(pMapName, "cityhall_1") == 0) return 1;
	if (strcmp(pMapName, "cityhall_2") == 0) return 2;
	if (strcmp(pMapName, "cath_1") == 0) return 1;
	if (strcmp(pMapName, "cath_2") == 0) return 2;
	if (strcmp(pMapName, "gshop_1") == 0) return 1;
	if (strcmp(pMapName, "gshop_2") == 0) return 2;
	if (strcmp(pMapName, "bsmith_1") == 0) return 1;
	if (strcmp(pMapName, "bsmith_2") == 0) return 2;
	if (strcmp(pMapName, "wrhus_1") == 0) return 1;
	if (strcmp(pMapName, "wrhus_2") == 0) return 2;
	if (strcmp(pMapName, "gldhall_1") == 0) return 1;
	if (strcmp(pMapName, "gldhall_2") == 0) return 2;
	if (strcmp(pMapName, "wzdtwr_1") == 0) return 1;
	if (strcmp(pMapName, "wzdtwr_2") == 0) return 2;
	if (strcmp(pMapName, "arefarm") == 0) return 1;
	if (strcmp(pMapName, "elvfarm") == 0) return 2;
	if (strcmp(pMapName, "arewrhus") == 0) return 1;
	if (strcmp(pMapName, "elvwrhus") == 0) return 2;
	if (strcmp(pMapName, "cmdhall_1") == 0) return 1;
	if (strcmp(pMapName, "Cmdhall_2") == 0) return 2;

	return 0;
}

bool CGame::bCopyItemContents(CItem* pCopy, CItem* pOriginal)
{
	if (pOriginal == 0) return false;
	if (pCopy == 0) return false;

	pCopy->m_sIDnum = pOriginal->m_sIDnum;
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3;
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6;
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;

	//short m_sSM_HitRatio, m_sL_HitRatio;
	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2;

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice;
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;

	pCopy->m_cCategory = pOriginal->m_cCategory;
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;

	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 = pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;

	return true;
}


//ArchAngel Function

void CGame::RequestChangePlayMode(int iClientH)
{

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPKCount > 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall", 8) != 0) return;

	if (m_pClientList[iClientH]->m_iLevel < 100 ||
		m_pClientList[iClientH]->m_bIsPlayerCivil) {
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) strcpy(m_pClientList[iClientH]->m_cLocation, "arehunter");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) strcpy(m_pClientList[iClientH]->m_cLocation, "elvhunter");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0) strcpy(m_pClientList[iClientH]->m_cLocation, "aresden");
		else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) strcpy(m_pClientList[iClientH]->m_cLocation, "elvine");

		if (m_pClientList[iClientH]->m_bIsPlayerCivil)
			m_pClientList[iClientH]->m_bIsPlayerCivil = false;
		else m_pClientList[iClientH]->m_bIsPlayerCivil = true;

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CHANGEPLAYMODE, 0, 0, 0, m_pClientList[iClientH]->m_cLocation);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, 100, 0, 0, 0);
	}

	g_login->LocalSavePlayerData(iClientH);
}

/*********************************************************************************************************************
**  void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show invisibility aura								**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bInvisibility = true;
		else m_pClientList[sOwnerH]->m_status.bInvisibility = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_status.bInvisibility = true;
		else m_pNpcList[sOwnerH]->m_status.bInvisibility = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, bool bStatus)								**
**  description			:: changes the status of the player to show inhibit casting aura							**
**  last updated		:: November 20, 2004; 9:33 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bInhibitionCasting = true;
		else m_pClientList[sOwnerH]->m_status.bInhibitionCasting = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_status.bInhibitionCasting = true;
		else m_pNpcList[sOwnerH]->m_status.bInhibitionCasting = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show berserk aura									**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bBerserk = true;
		else m_pClientList[sOwnerH]->m_status.bBerserk = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_status.bBerserk = true;
		else m_pNpcList[sOwnerH]->m_status.bBerserk = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

void CGame::SetHasteFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bHaste = true;
		else m_pClientList[sOwnerH]->m_status.bHaste = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetIceFlag(short sOwnerH, char cOwnerType, bool bStatus)										**
**  description			:: changes the status of the player to show frozen aura										**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIceFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bFrozen = true;
		else m_pClientList[sOwnerH]->m_status.bFrozen = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_status.bFrozen = true;
		else m_pNpcList[sOwnerH]->m_status.bFrozen = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show poison aura										**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bPoisoned = true;
		else m_pClientList[sOwnerH]->m_status.bPoisoned = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_status.bPoisoned = true;
		else m_pNpcList[sOwnerH]->m_status.bPoisoned = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, bool bStatus)									**
**  description			:: changes the status of the player to show illusion aura									**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bIllusion = true;
		else m_pClientList[sOwnerH]->m_status.bIllusion = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_status.bIllusion = true;
		else m_pNpcList[sOwnerH]->m_status.bIllusion = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, bool bStatus)										**
**  description			:: changes the status of the player to show hero item aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
int CGame::FindAdminByAccount(const char* accountName)
{
	if (accountName == nullptr) return -1;
	for (int i = 0; i < m_iAdminCount; i++) {
		if (_stricmp(m_stAdminList[i].m_cAccountName, accountName) == 0)
			return i;
	}
	return -1;
}

int CGame::FindAdminByCharName(const char* charName)
{
	if (charName == nullptr) return -1;
	for (int i = 0; i < m_iAdminCount; i++) {
		if (_stricmp(m_stAdminList[i].m_cCharName, charName) == 0)
			return i;
	}
	return -1;
}

bool CGame::IsClientAdmin(int iClientH)
{
	if (iClientH <= 0 || iClientH >= DEF_MAXCLIENTS) return false;
	if (m_pClientList[iClientH] == nullptr) return false;
	return m_pClientList[iClientH]->m_iAdminIndex != -1;
}

int CGame::GetCommandRequiredLevel(const char* cmdName) const
{
	if (cmdName == nullptr) return hb::admin::Administrator;
	auto it = m_commandPermissions.find(cmdName);
	if (it != m_commandPermissions.end())
		return it->second.iAdminLevel;
	return hb::admin::Administrator;
}

int CGame::FindClientByName(const char* pName) const
{
	if (pName == nullptr) return 0;
	for (int i = 1; i < DEF_MAXCLIENTS; i++)
	{
		if (m_pClientList[i] != nullptr && m_pClientList[i]->m_bIsInitComplete)
		{
			if (_strnicmp(m_pClientList[i]->m_cCharName, pName, DEF_CHARNAME - 1) == 0)
				return i;
		}
	}
	return 0;
}

bool CGame::GMTeleportTo(int iClientH, const char* cDestMap, short sDestX, short sDestY)
{
	if (m_pClientList[iClientH] == nullptr) return false;
	if (cDestMap == nullptr) return false;

	// Find destination map index
	int iDestMapIndex = -1;
	for (int i = 0; i < DEF_MAXMAPS; i++)
	{
		if (m_pMapList[i] != nullptr && memcmp(m_pMapList[i]->m_cName, cDestMap, 10) == 0)
		{
			iDestMapIndex = i;
			break;
		}
	}
	if (iDestMapIndex == -1) return false;

	// Remove from current location
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER,
		m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, 0, 0, 0);

	// Update position and map
	m_pClientList[iClientH]->m_sX = sDestX;
	m_pClientList[iClientH]->m_sY = sDestY;
	m_pClientList[iClientH]->m_cMapIndex = static_cast<char>(iDestMapIndex);
	std::memset(m_pClientList[iClientH]->m_cMapName, 0, sizeof(m_pClientList[iClientH]->m_cMapName));
	memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[iDestMapIndex]->m_cName, 10);

	// Always send full INITDATA  same pattern as RequestTeleportHandler RTH_NEXTSTEP.
	// Even same-map teleports need INITDATA so the client reinitializes its view.
	SetPlayingStatus(iClientH);
	// Set faction/identity status fields from player data
	m_pClientList[iClientH]->m_status.bPK = (m_pClientList[iClientH]->m_iPKCount != 0) ? 1 : 0;
	m_pClientList[iClientH]->m_status.bCitizen = (m_pClientList[iClientH]->m_cSide != 0) ? 1 : 0;
	m_pClientList[iClientH]->m_status.bAresden = (m_pClientList[iClientH]->m_cSide == 1) ? 1 : 0;
	m_pClientList[iClientH]->m_status.bHunter = m_pClientList[iClientH]->m_bIsPlayerCivil ? 1 : 0;

	hb::net::PacketWriter writer;
	char initMapData[DEF_MSGBUFFERSIZE + 1];

	writer.Reset();
	auto* init_header = writer.Append<hb::net::PacketResponseInitDataHeader>();
	init_header->header.msg_id = MSGID_RESPONSE_INITDATA;
	init_header->header.msg_type = DEF_MSGTYPE_CONFIRM;

	bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);

	init_header->player_object_id = static_cast<std::int16_t>(iClientH);
	init_header->pivot_x = static_cast<std::int16_t>(m_pClientList[iClientH]->m_sX - DEF_PLAYER_PIVOT_OFFSET_X);
	init_header->pivot_y = static_cast<std::int16_t>(m_pClientList[iClientH]->m_sY - DEF_PLAYER_PIVOT_OFFSET_Y);
	init_header->player_type = m_pClientList[iClientH]->m_sType;
	init_header->appearance = m_pClientList[iClientH]->m_appearance;
	init_header->status = m_pClientList[iClientH]->m_status;
	std::memcpy(init_header->map_name, m_pClientList[iClientH]->m_cMapName, sizeof(init_header->map_name));
	std::memcpy(init_header->cur_location, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, sizeof(init_header->cur_location));

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)
		init_header->sprite_alpha = 1;
	else init_header->sprite_alpha = m_cDayOrNight;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode)
		init_header->weather_status = 0;
	else init_header->weather_status = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;

	init_header->contribution = m_pClientList[iClientH]->m_iContribution;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH,
		DEF_OWNERTYPE_PLAYER,
		m_pClientList[iClientH]->m_sX,
		m_pClientList[iClientH]->m_sY);

	init_header->observer_mode = static_cast<std::uint8_t>(m_pClientList[iClientH]->m_bIsObserverMode);
	init_header->rating = m_pClientList[iClientH]->m_iRating;
	init_header->hp = m_pClientList[iClientH]->m_iHP;
	init_header->discount = 0;

	int iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - DEF_VIEWCENTER_X, m_pClientList[iClientH]->m_sY - DEF_VIEWCENTER_Y, iClientH, initMapData);
	writer.AppendBytes(initMapData, static_cast<std::size_t>(iSize));

	int iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(writer.Data(), static_cast<int>(writer.Size()));
	if (iRet == DEF_XSOCKEVENT_QUENEFULL || iRet == DEF_XSOCKEVENT_SOCKETERROR ||
		iRet == DEF_XSOCKEVENT_CRITICALERROR || iRet == DEF_XSOCKEVENT_SOCKETCLOSED)
	{
		DeleteClient(iClientH, true, true);
		return false;
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);

	return true;
}

void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bHero = true;
		else m_pClientList[sOwnerH]->m_status.bHero = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_status.bHero = true;
		else m_pNpcList[sOwnerH]->m_status.bHero = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, bool bStatus)								**
**  description			:: changes the status of the player to show defense aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bDefenseShield = true;
		else m_pClientList[sOwnerH]->m_status.bDefenseShield = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_status.bDefenseShield = true;
		else m_pNpcList[sOwnerH]->m_status.bDefenseShield = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, bool bStatus)							**
**  description			:: changes the status of the player to show magic protect aura								**
**  last updated		:: November 20, 2004; 9:38 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bMagicProtection = true;
		else m_pClientList[sOwnerH]->m_status.bMagicProtection = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_status.bMagicProtection = true;
		else m_pNpcList[sOwnerH]->m_status.bMagicProtection = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, bool bStatus)						**
**  description			:: changes the status of the player to show arrow protect aura								**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bProtectionFromArrow = true;
		else m_pClientList[sOwnerH]->m_status.bProtectionFromArrow = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == 0) return;
		if (bStatus)
			m_pNpcList[sOwnerH]->m_status.bProtectionFromArrow = true;
		else m_pNpcList[sOwnerH]->m_status.bProtectionFromArrow = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, bool bStatus)							**
**  description			:: changes the status of the player to show illusion movement aura							**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, bool bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == 0) return;
		if (bStatus)
			m_pClientList[sOwnerH]->m_status.bIllusionMovement = true;
		else m_pClientList[sOwnerH]->m_status.bIllusionMovement = false;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
		break;
	}
}

// New 07/05/2004
void CGame::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{
	if (m_pClientList[iClientH] == 0) return;
	if ((iObjectID <= 0) || (iObjectID >= DEF_MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] == 0) {
		// Object .

	}
	else {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, 0, m_pClientList[iObjectID]->m_cGuildName);
	}
}

// Item Logging
bool CGame::_bItemLog(int iAction, int iGiveH, int iRecvH, CItem* pItem, bool bForceItemLog)
{
	if (pItem == 0) return false;
	if (m_pClientList[iGiveH] == 0) return false;

	switch (iAction) {

	case DEF_ITEMLOG_EXCHANGE:
		if (m_pClientList[iRecvH] == 0) return false;
		ItemLog::Get().LogExchange(m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iRecvH]->m_cCharName, m_pClientList[iGiveH]->m_cMapName,
			m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_GIVE:
		if (m_pClientList[iRecvH] == 0) return false;
		ItemLog::Get().LogTrade(m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iRecvH]->m_cCharName, m_pClientList[iGiveH]->m_cMapName,
			m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_DROP:
		ItemLog::Get().LogDrop(m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_GET:
		ItemLog::Get().LogPickup(m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_MAKE:
		ItemLog::Get().LogCraft(m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_DEPLETE:
		ItemLog::Get().LogMisc("Deplete", m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_BUY:
		ItemLog::Get().LogShop("Buy", m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_SELL:
		ItemLog::Get().LogShop("Sell", m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_RETRIEVE:
		ItemLog::Get().LogBank("Retrieve", m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_DEPOSIT:
		ItemLog::Get().LogBank("Deposit", m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_UPGRADEFAIL:
		ItemLog::Get().LogUpgrade(false, m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_UPGRADESUCCESS:
		ItemLog::Get().LogUpgrade(true, m_pClientList[iGiveH]->m_cCharName, m_pClientList[iGiveH]->m_cIPaddress,
			m_pClientList[iGiveH]->m_cMapName, m_pClientList[iGiveH]->m_sX, m_pClientList[iGiveH]->m_sY, pItem);
		break;

	default:
		return false;
	}
	return true;
}

bool CGame::_bItemLog(int iAction, int iClientH, char* cName, CItem* pItem)
{
	if (pItem == 0) return false;
	if (_bCheckGoodItem(pItem) == false) return false;
	if (iAction != DEF_ITEMLOG_NEWGENDROP)
	{
		if (m_pClientList[iClientH] == 0) return false;
	}
	char cTemp1[120];
	std::memset(cTemp1, 0, sizeof(cTemp1));
	if (m_pClientList[iClientH] != 0) m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {

	case DEF_ITEMLOG_NEWGENDROP:
		ItemLog::Get().LogMisc("NpcDrop", cName ? cName : "Unknown", "", "", 0, 0, pItem);
		break;

	case DEF_ITEMLOG_SKILLLEARN:
	case DEF_ITEMLOG_MAGICLEARN:
		if (cName == 0) return false;
		if (m_pClientList[iClientH] == 0) return false;
		ItemLog::Get().LogMisc("Learn", m_pClientList[iClientH]->m_cCharName, cTemp1,
			m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_SUMMONMONSTER:
		if (cName == 0) return false;
		if (m_pClientList[iClientH] == 0) return false;
		ItemLog::Get().LogMisc("Summon", m_pClientList[iClientH]->m_cCharName, cTemp1,
			m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_POISONED:
		if (m_pClientList[iClientH] == 0) return false;
		ItemLog::Get().LogMisc("Poisoned", m_pClientList[iClientH]->m_cCharName, cTemp1,
			m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
		break;

	case DEF_ITEMLOG_REPAIR:
		if (cName == 0) return false;
		if (m_pClientList[iClientH] == 0) return false;
		ItemLog::Get().LogMisc("Repair", m_pClientList[iClientH]->m_cCharName, cTemp1,
			m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
		break;

	default:
		return false;
	}
	return true;
}

bool CGame::_bCheckGoodItem(CItem* pItem)
{
	if (pItem == 0) return false;

	if (pItem->m_sIDnum == 90)
	{
		if (pItem->m_dwCount > 10000) return true;  // Gold  10000   .
		else return false;
	}
	switch (pItem->m_sIDnum) {
		// case 90: // Gold
	case 259:
	case 290:
	case 291:
	case 292:
	case 300:
	case 305:
	case 308:
	case 311:
	case 334:
	case 335:
	case 336:
	case 338:
	case 380:
	case 381:
	case 382:
	case 391:
	case 400:
	case 401:
	case 490:
	case 491:
	case 492:
	case 508:
	case 581:
	case 610:
	case 611:
	case 612:
	case 613:
	case 614:
	case 616:
	case 618:

	case 620:
	case 621:
	case 622:
	case 623:

	case 630:
	case 631:

	case 632:
	case 633:
	case 634:
	case 635:
	case 636:
	case 637:
	case 638:
	case 639:
	case 640:
	case 641:

	case 642:
	case 643:

	case 644:
	case 645:
	case 646:
	case 647:

	case 650:
	case 654:
	case 655:
	case 656:
	case 657:

	case 700:
	case 701:
	case 702:
	case 703:
	case 704:
	case 705:
	case 706:
	case 707:
	case 708:
	case 709:
	case 710:
	case 711:
	case 712:
	case 713:
	case 714:
	case 715:

	case 720:
	case 721:
	case 722:
	case 723:

	case 724:
	case 725:
	case 726:
	case 727:
	case 728:
	case 729:
	case 730:
	case 731:
	case 732:
	case 733:

	case 734:
	case 735:

	case 736:
	case 737:
	case 738:
	case 924:

		return true;
		break;
	default:
		if ((pItem->m_dwAttribute & 0xF0F0F001) == 0) return false;
		else if (pItem->m_sIDnum > 30) return true;
		else return false;
	}
}

void CGame::GetExp(int iClientH, uint32_t iExp, bool bIsAttackerOwn)
{
	double dV1, dV2, dV3;
	int iH;
	uint32_t dwTime = GameClock::GetTimeMS(), iUnitValue;
	int iTotalPartyMembers;

	if (m_pClientList[iClientH] == 0) return;
	if (iExp <= 0) return;

	if (m_pClientList[iClientH]->m_iLevel <= 80) {
		dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f) * dV3;
		iExp = (uint32_t)dV1;
	}
	else { //Lower exp
		if ((m_pClientList[iClientH]->m_iLevel >= 80) && ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresdend1") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvined1") == 0))) {
			iExp = (iExp / 10);
		}
		else if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresdend1") == 0) || (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvined1") == 0)) {
			iExp = (iExp * 1 / 4);
		}
	}

	//Check for party status, else give exp to player
	if ((m_pClientList[iClientH]->m_iPartyID != 0) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
		//Only divide exp if >= 1 person 
		if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 0) {

			//Calc total ppl in party
			iTotalPartyMembers = 0;
			for(int i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++) {
				iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
				if ((m_pClientList[iH] != 0) && (m_pClientList[iH]->m_iHP > 0)) {
					//Newly added, Only players on same map get exp :}
					if ((strlen(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName)) == (strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName))) {
						if (memcmp(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) == 0) {
							iTotalPartyMembers++;
						}
					}
				}
			}

			//Check for party bug
			if (iTotalPartyMembers > hb::limits::MaxPartyMembers) {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(X) Party Bug !! partyMember %d XXXXXXXXXX", iTotalPartyMembers);
				PutLogFileList(G_cTxt);
				iTotalPartyMembers = hb::limits::MaxPartyMembers;
			}

			//Figure out how much exp a player gets
			dV1 = (double)iExp;
			dV2 = dV1;

			if (iTotalPartyMembers > 1)
			{
				dV2 = (dV1 + (dV1 * (double)(iTotalPartyMembers / hb::limits::MaxPartyMembers))) / (double)iTotalPartyMembers;
			}

			dV3 = dV2 + 5.0e-1;
			iUnitValue = (uint32_t)dV3;

			//Divide exp among party members
			for(int i = 0; i < iTotalPartyMembers; i++) {

				iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
				if ((m_pClientList[iH] != 0) && (m_pClientList[iH]->m_bSkillUsingStatus[19] != 1) && (m_pClientList[iH]->m_iHP > 0)) { // Is player alive ??
					if (m_pClientList[iH]->m_status.bSlateExp)  iUnitValue *= 3;
					m_pClientList[iH]->m_iExpStock += iUnitValue;
				}
			}
		}
	}
	else {
		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_bSkillUsingStatus[19] != 1) && (m_pClientList[iClientH]->m_iHP > 0)) { // Is player alive ??
			if (m_pClientList[iClientH]->m_status.bSlateExp)  iExp *= 3;
			m_pClientList[iClientH]->m_iExpStock += iExp;
		}
	}
}

bool CGame::bCheckAndConvertPlusWeaponItem(int iClientH, int iItemIndex)
{
	if (m_pClientList[iClientH] == 0) return false;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return false;

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
	case 4:  // Dagger +1
	case 9:  // Short Sword +1
	case 13: // Main Gauge +1
	case 16: // Gradius +1
	case 18: // Long Sword +1
	case 19: // Long Sword +2
	case 21: // Excaliber +1
	case 24: // Sabre +1
	case 26: // Scimitar +1
	case 27: // Scimitar +2
	case 29: // Falchoin +1
	case 30: // Falchion +2
	case 32: // Esterk +1
	case 33: // Esterk +2
	case 35: // Rapier +1
	case 36: // Rapier +2
	case 39: // Broad Sword +1
	case 40: // Broad Sword +2
	case 43: // Bastad Sword +1
	case 44: // Bastad Sword +2
	case 47: // Claymore +1
	case 48: // Claymore +2
	case 51: // Great Sword +1
	case 52: // Great Sword +2
	case 55: // Flameberge +1
	case 56: // Flameberge +2
	case 60: // Light Axe +1
	case 61: // Light Axe +2
	case 63: // Tomahoc +1
	case 64: // Tomohoc +2
	case 66: // Sexon Axe +1
	case 67: // Sexon Axe +2
	case 69: // Double Axe +1
	case 70: // Double Axe +2
	case 72: // War Axe +1
	case 73: // War Axe +2

	case 580: // Battle Axe +1
	case 581: // Battle Axe +2
	case 582: // Sabre +2
		return true;
		break;
	}
	return false;
}

void CGame::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{
	int iTemp;

	if (m_pClientList[iAttackerH] == 0) return;
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == 0) return;
		break;

	case DEF_OWNERTYPE_NPC:	return;
	default: return;
	}

	if (m_pClientList[iAttackerH]->m_cSide == m_pClientList[iTargetH]->m_cSide) return;

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::Body)];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			ReleaseItemHandler(iTargetH, iTemp, true);
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::Pants)];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			ReleaseItemHandler(iTargetH, iTemp, true);
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::Leggings)];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			ReleaseItemHandler(iTargetH, iTemp, true);
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::Arms)];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			ReleaseItemHandler(iTargetH, iTemp, true);
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::Head)];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != 0)) {

		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
		}
		if ((m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) || (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 64000)) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			SendNotifyMsg(0, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
			ReleaseItemHandler(iTargetH, iTemp, true);
		}
	}
}


// New 12/05/2004
void CGame::RemoveCrusadeNpcs(void)
{
	for(int i = 0; i < DEF_MAXNPCS; i++) {
		if (m_pNpcList[i] != 0) {
			if ((m_pNpcList[i]->m_sType >= 43 && m_pNpcList[i]->m_sType <= 47) || m_pNpcList[i]->m_sType == 51) {
				m_pEntityManager->OnEntityKilled(i, 0, 0, 0);
			}
		}
	}
}

void CGame::RemoveCrusadeRecallTime(void)
{
	for(int i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsWarLocation &&
				m_pClientList[i]->m_bIsPlayerCivil &&
				m_pClientList[i]->m_bIsInitComplete) {
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
			}
		}
	}
}


// New 16/05/2004
void CGame::ReqCreateSlateHandler(int iClientH, char* pData)
{
	int iRet;
	char cItemID[4], ctr[4];
	char cSlateColour;
	bool bIsSlatePresent = false;
	CItem* pItem;
	int iSlateType, iEraseReq;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;

	for(int i = 0; i < 4; i++) {
		cItemID[i] = 0;
		ctr[i] = 0;
	}
	const auto* pkt = hb::net::PacketCast<hb::net::PacketCommandCommonItems>(
		pData, sizeof(hb::net::PacketCommandCommonItems));
	if (!pkt) return;

	// 14% chance of creating slates
	if (iDice(1, 100) < static_cast<uint32_t>(m_sSlateSuccessRate)) bIsSlatePresent = true;

	try {
		// make sure slates really exist
		for(int i = 0; i < 4; i++) {
			cItemID[i] = static_cast<char>(pkt->item_ids[i]);

			if (m_pClientList[iClientH]->m_pItemList[cItemID[i]] == 0 || cItemID[i] > hb::limits::MaxItems) {
				bIsSlatePresent = false;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, 0, 0, 0, 0);
				return;
			}

			//No duping
			if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 868)
				ctr[0] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 869)
				ctr[1] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 870)
				ctr[2] = 1;
			else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 871)
				ctr[3] = 1;
		}
	}
	catch (...) {
		//Crash Hacker Caught
		bIsSlatePresent = false;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, 0, 0, 0, 0);
		std::snprintf(G_cTxt, sizeof(G_cTxt), "TSearch Slate Hack: (%s) Player: (%s) - creating slates without correct item!", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, true, true);
		return;
	}

	// Are all 4 slates present ??
	if (ctr[0] != 1 || ctr[1] != 1 || ctr[2] != 1 || ctr[3] != 1) {
		bIsSlatePresent = false;
		return;
	}

	// if we failed, kill everything
	if (!bIsSlatePresent) {
		for(int i = 0; i < 4; i++) {
			if (m_pClientList[iClientH]->m_pItemList[cItemID[i]] != 0) {
				ItemDepleteHandler(iClientH, cItemID[i], false);
			}
		}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, 0, 0, 0, 0);
		return;
	}

	// make the slates
	for(int i = 0; i < 4; i++) {
		if (m_pClientList[iClientH]->m_pItemList[cItemID[i]] != 0) {
			ItemDepleteHandler(iClientH, cItemID[i], false);
		}
	}

	pItem = new CItem;

	int i = iDice(1, 1000);

	if (i < 50) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}
	else if (i < 250) { // Bezerk slate
		iSlateType = 2;
		cSlateColour = 3;
	}
	else if (i < 750) { // Exp slate
		iSlateType = 4;
		cSlateColour = 7;
	}
	else if (i < 950) { // Mana slate
		iSlateType = 3;
		cSlateColour = 37;
	}
	else if (i < 1001) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}

	// Notify client
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_SLATE_CREATESUCCESS, iSlateType, 0, 0, 0);


	// Create slates
	if (_bInitItemAttr(pItem, 867) == false) {
		delete pItem;
		return;
	}
	else {
		pItem->SetTouchEffectType(TouchEffectType::ID);
		pItem->m_sTouchEffectValue1 = static_cast<short>(iDice(1, 100000));
		pItem->m_sTouchEffectValue2 = static_cast<short>(iDice(1, 100000));
		pItem->m_sTouchEffectValue3 = (short)GameClock::GetTimeMS();

		_bItemLog(DEF_ITEMLOG_GET, iClientH, -1, pItem);

		pItem->m_sItemSpecEffectValue2 = iSlateType;
		pItem->m_cItemColor = cSlateColour;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq)) {
			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return;
			}
		}
		else {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);
			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				break;
			}
		}
	}
	return;
}

void CGame::SetSlateFlag(int iClientH, short sType, bool bFlag)
{
	if (m_pClientList[iClientH] == 0) return;

	if (sType == DEF_NOTIFY_SLATECLEAR) {
		m_pClientList[iClientH]->m_status.bSlateInvincible = false;
		m_pClientList[iClientH]->m_status.bSlateMana = false;
		m_pClientList[iClientH]->m_status.bSlateExp = false;
		return;
	}

	if (bFlag) {
		if (sType == 1) { // Invincible slate
			m_pClientList[iClientH]->m_status.bSlateInvincible = true;
		}
		else if (sType == 3) { // Mana slate
			m_pClientList[iClientH]->m_status.bSlateMana = true;
		}
		else if (sType == 4) { // Exp slate
			m_pClientList[iClientH]->m_status.bSlateExp = true;
		}
	}
	else {
		if (m_pClientList[iClientH]->m_status.bSlateInvincible) {
			m_pClientList[iClientH]->m_status.bSlateInvincible = false;
		}
		else if (m_pClientList[iClientH]->m_status.bSlateMana) {
			m_pClientList[iClientH]->m_status.bSlateMana = false;
		}
		else if (m_pClientList[iClientH]->m_status.bSlateExp) {
			m_pClientList[iClientH]->m_status.bSlateExp = false;
		}
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}

// New 18/05/2004
void CGame::SetPlayingStatus(int iClientH)
{
	char cMapName[11], cLocation[11];

	if (m_pClientList[iClientH] == 0) return;

	std::memset(cMapName, 0, sizeof(cMapName));
	std::memset(cLocation, 0, sizeof(cLocation));

	strcpy(cLocation, m_pClientList[iClientH]->m_cLocation);
	strcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);

	m_pClientList[iClientH]->m_cSide = 0;
	m_pClientList[iClientH]->m_bIsOwnLocation = false;
	m_pClientList[iClientH]->m_bIsPlayerCivil = false;

	if (memcmp(cLocation, cMapName, 3) == 0) {
		m_pClientList[iClientH]->m_bIsOwnLocation = true;
	}

	if (memcmp(cLocation, "are", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 1;
	else if (memcmp(cLocation, "elv", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 2;
	else {
		if (strcmp(cMapName, "elvine") == 0 || strcmp(cMapName, "aresden") == 0) {
			m_pClientList[iClientH]->m_bIsOwnLocation = true;
		}
		m_pClientList[iClientH]->m_bIsNeutral = true;
	}

	if (memcmp(cLocation, "arehunter", 9) == 0 || memcmp(cLocation, "elvhunter", 9) == 0) {
		m_pClientList[iClientH]->m_bIsPlayerCivil = true;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) == 0) {
		m_pClientList[iClientH]->m_bIsPlayerCivil = false;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith", 6) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall", 7) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gshop", 5) == 0)
		m_pClientList[iClientH]->m_pIsProcessingAllowed = true;
	else
		m_pClientList[iClientH]->m_pIsProcessingAllowed = false;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus", 5) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus", 8) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus", 8) == 0)
		m_pClientList[iClientH]->m_bIsInsideWarehouse = true;
	else
		m_pClientList[iClientH]->m_bIsInsideWarehouse = false;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr", 6) == 0)
		m_pClientList[iClientH]->m_bIsInsideWizardTower = true;
	else
		m_pClientList[iClientH]->m_bIsInsideWizardTower = false;
}

void CGame::ForceChangePlayMode(int iClientH, bool bNotify)
{
	if (m_pClientList[iClientH] == 0) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "aresden");
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "elvine");

	if (m_pClientList[iClientH]->m_bIsPlayerCivil)
		m_pClientList[iClientH]->m_bIsPlayerCivil = false;

	if (bNotify) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_CHANGEPLAYMODE, 0, 0, 0, m_pClientList[iClientH]->m_cLocation);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
	}
}

void CGame::ShowVersion(int iClientH)
{
	char cVerMessage[256];

	std::memset(cVerMessage, 0, sizeof(cVerMessage));
	std::snprintf(cVerMessage, sizeof(cVerMessage), "Helbreath Sources %s.%s - www.xtremehb.com", DEF_UPPERVERSION, DEF_LOWERVERSION);
	ShowClientMsg(iClientH, cVerMessage);

}

// v2.14 05/22/2004 - Hypnotoad - adds pk log
bool CGame::_bPKLog(int iAction, int iAttackerH, int iVictumH, char* pNPC)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];

	std::memset(cTxt, 0, sizeof(cTxt));
	std::memset(cTemp1, 0, sizeof(cTemp1));
	std::memset(cTemp2, 0, sizeof(cTemp2));

	if (m_pClientList[iVictumH] == 0) return false;

	switch (iAction) {

	case DEF_PKLOG_REDUCECRIMINAL:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tReduce\tCC(%d)\t%s(%d %d)\t", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_iPKCount,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY);
		break;

	case DEF_PKLOG_BYPLAYER:
		if (m_pClientList[iAttackerH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tKilled by PC\t \t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
		break;
	case DEF_PKLOG_BYPK:
		if (m_pClientList[iAttackerH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tKilled by PK\tCC(%d)\t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, m_pClientList[iAttackerH]->m_iPKCount,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
		break;
	case DEF_PKLOG_BYENERMY:
		if (m_pClientList[iAttackerH] == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tKilled by Enemy\t \t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
		break;
	case DEF_PKLOG_BYNPC:
		if (pNPC == 0) return false;
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tKilled by NPC\t \t%s(%d %d)\tNPC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY, pNPC);
		break;
	case DEF_PKLOG_BYOTHER:
		std::snprintf(cTxt, sizeof(cTxt), "(%s) PC(%s)\tKilled by Other\t \t%s(%d %d)\tUnknown", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName,
			m_pClientList[iVictumH]->m_cMapName, m_pClientList[iVictumH]->m_sX, m_pClientList[iVictumH]->m_sY);
		break;
	default:
		return false;
	}
	PutPvPLogFileList(cTxt);
	return true;
}

void CGame::RequestResurrectPlayer(int iClientH, bool bResurrect)
{
	short sX, sY;
	char buff[100];

	if (m_pClientList[iClientH] == 0) return;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	if (bResurrect == false) {
		m_pClientList[iClientH]->m_bIsBeingResurrected = false;
		return;
	}

	if (m_pClientList[iClientH]->m_bIsBeingResurrected == false) {
		try
		{
			std::snprintf(buff, sizeof(buff), "(!!!) Player(%s) Tried To Use Resurrection Hack", m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true, true, true);
		}
		catch (...)
		{
		}
		return;
	}

	std::snprintf(buff, sizeof(buff), "(*) Resurrect Player! %s", m_pClientList[iClientH]->m_cCharName);
	PutLogList(buff);


	m_pClientList[iClientH]->m_bIsKilled = false;
	// Player's HP becomes half of the Max HP. 
	m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH) / 2;
	// Player's MP
	m_pClientList[iClientH]->m_iMP = iGetMaxMP(iClientH);
	// Player's SP
	m_pClientList[iClientH]->m_iSP = iGetMaxSP(iClientH);
	// Player's Hunger
	m_pClientList[iClientH]->m_iHungerStatus = 100;

	m_pClientList[iClientH]->m_bIsBeingResurrected = false;

	// !!! RequestTeleportHandler m_cMapName
	RequestTeleportHandler(iClientH, "2   ", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
}

bool CGame::bCheckClientAttackFrequency(int iClientH, uint32_t dwClientTime)
{
	if (m_pClientList[iClientH] == 0) return false;

	if (m_pClientList[iClientH]->m_dwAttackFreqTime == 0)
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
	else {
		uint32_t dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwAttackFreqTime;
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;

		// Compute expected minimum swing time from player's weapon speed and status effects.
		// Must match client-side animation timing (PlayerAnim::Attack: sMaxFrame=7, frames 0-7 = 8 durations @ 78ms base).
		constexpr int ATTACK_FRAME_DURATIONS = 8;
		constexpr int BASE_FRAME_TIME = 78;
		constexpr int RUN_FRAME_TIME = 39;
		constexpr int TOLERANCE_MS = 50;

		const auto& status = m_pClientList[iClientH]->m_status;
		int iAttackDelay = status.iAttackDelay;  // 0 = full swing (STR meets weapon req)
		bool bHaste = status.bHaste;
		bool bFrozen = status.bFrozen;

		int effectiveFrameTime = BASE_FRAME_TIME + (iAttackDelay * 12);
		if (bFrozen) effectiveFrameTime += BASE_FRAME_TIME >> 2;
		if (bHaste)  effectiveFrameTime -= static_cast<int>(RUN_FRAME_TIME / 2.3);

		int expectedSwingTime = ATTACK_FRAME_DURATIONS * effectiveFrameTime;
		int threshold = expectedSwingTime - TOLERANCE_MS;
		if (threshold < 200) threshold = 200;

		if (dwTimeGap < static_cast<uint32_t>(threshold)) {
			try
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Swing Hack: (%s) Player: (%s) - attacking at irregular rates. Gap: %ums, Min: %dms",
					m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName,
					dwTimeGap, expectedSwingTime);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
			}
			catch (...)
			{
			}
			return false;
		}
	}

	return false;
}

bool CGame::bCheckClientMagicFrequency(int iClientH, uint32_t dwClientTime)
{
	uint32_t dwTimeGap;

	if (m_pClientList[iClientH] == 0) return false;

	if (m_pClientList[iClientH]->m_dwMagicFreqTime == 0)
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMagicFreqTime;
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;

		if ((dwTimeGap < 1500) && (m_pClientList[iClientH]->m_bMagicConfirm)) {
			try
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Speed Cast: (%s) Player: (%s) - casting magic at irregular rates. ", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
			}
			catch (...)
			{
			}
			return false;
		}

		m_pClientList[iClientH]->m_iSpellCount--;
		if (m_pClientList[iClientH]->m_iSpellCount < 0)
			m_pClientList[iClientH]->m_iSpellCount = 0;
		m_pClientList[iClientH]->m_bMagicConfirm = false;
	}

	return false;
}

bool CGame::bCheckClientMoveFrequency(int iClientH, uint32_t dwClientTime)
{
	uint32_t dwTimeGap;

	if (m_pClientList[iClientH] == 0) return false;


	if (m_pClientList[iClientH]->m_dwMoveFreqTime == 0)
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
	else {
		if (m_pClientList[iClientH]->m_bIsMoveBlocked) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = 0;
			m_pClientList[iClientH]->m_bIsMoveBlocked = false;
			return false;
		}

		if (m_pClientList[iClientH]->m_bIsAttackModeChange) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = 0;
			m_pClientList[iClientH]->m_bIsAttackModeChange = false;
			return false;
		}

		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMoveFreqTime;
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;

		if ((dwTimeGap < 200) && (dwTimeGap >= 0)) {
			try
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Speed Hack: (%s) Player: (%s) - running too fast.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, true, true);
			}
			catch (...)
			{
			}
			return false;
		}

		// testcode
		// std::snprintf(G_cTxt, sizeof(G_cTxt), "Move: %d", dwTimeGap);
		// PutLogList(G_cTxt);
	}

	return false;
}

void CGame::CrusadeWarStarter()
{
	SYSTEMTIME SysTime;
	

	if (m_bIsCrusadeMode) return;
	if (m_bIsCrusadeWarStarter == false) return;

	GetLocalTime(&SysTime);

	for(int i = 0; i < DEF_MAXSCHEDULE; i++)
		if ((m_stCrusadeWarSchedule[i].iDay == SysTime.wDayOfWeek) &&
			(m_stCrusadeWarSchedule[i].iHour == SysTime.wHour) &&
			(m_stCrusadeWarSchedule[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated crusade is being initiated!");
			GlobalStartCrusadeMode();
			return;
		}
}

void CGame::OnTimer(char cType)
{
	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	// MODERNIZED: GameProcess moved to EventLoop to prevent blocking socket polling
	// OnTimer now only handles periodic events (CheckClientResponseTime, weather, etc.)
	// GameProcess() is called directly in EventLoop every 300ms


	if ((dwTime - m_dwGameTime2) > 1000) {
		CheckClientResponseTime();
		CheckDayOrNightMode();
		InvalidateRect(G_hWnd, 0, true);
		m_dwGameTime2 = dwTime;
		// v1.41 

		// v1.41
		if (m_bIsGameStarted == false) {
			PutLogList("Sending start message...");
			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, 0, 0);
			m_bIsGameStarted = true;

			// Initialize EntityManager now that maps are loaded
			if (m_pEntityManager != NULL) {
				// EntityManager owns the entity array now, just set maps and game reference
				m_pEntityManager->SetMapList(m_pMapList, DEF_MAXMAPS);
				m_pEntityManager->SetGame(this);
				PutLogList("EntityManager initialized");
			}
		}
	}
	if ((dwTime - m_dwGameTime6) > 1000) {
		DelayEventProcessor();
		m_dwGameTime6 = dwTime;

		// v2.05
		if (m_iFinalShutdownCount != 0) {
			m_iFinalShutdownCount--;
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(G_cTxt);
			if (m_iFinalShutdownCount <= 1) {
				// 2.14
				SendMessage(m_hWnd, WM_CLOSE, 0, 0);
				return;

			}
		}
	}

	if ((dwTime - m_dwGameTime3) > 1000) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		NoticeHandler();
		SpecialEventHandler();
		EnergySphereProcessor();
		m_dwGameTime3 = dwTime;
	}

	if ((dwTime - m_dwGameTime4) > 600) {
		// Use EntityManager for spawn generation
		if (m_pEntityManager != NULL)
			m_pEntityManager->ProcessSpawns();

		m_dwGameTime4 = dwTime;
	}


	if ((dwTime - m_dwGameTime5) > 1000 * 60 * 3) {

		m_dwGameTime5 = dwTime;

		srand((unsigned)time(0));
	}

	if ((dwTime - m_dwFishTime) > 5000) {
		FishProcessor();
		FishGenerator();
		SendCollectedMana();
		CrusadeWarStarter();
		//ApocalypseStarter();
		ApocalypseEnder();
		m_dwFishTime = dwTime;
	}

	if ((dwTime - m_dwWhetherTime) > 1000 * 20) {
		WhetherProcessor();
		m_dwWhetherTime = dwTime;
	}

	if ((m_bHeldenianRunning) && (m_bIsHeldenianMode)) {
		SetHeldenianMode();
	}
	if ((dwTime - m_dwCanFightzoneReserveTime) > 7200000) {
		FightzoneReserveProcessor();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == false) && (m_bOnExitProcess) && ((dwTime - m_dwExitProcessTime) > 1000 * 2)) {
		if (_iForcePlayerDisconect(15) == 0) {
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = true;

			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
				m_iAutoRebootingCount++;
			}
			else {
				if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 20;
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	if ((dwTime - m_dwMapSectorInfoTime) > 1000 * 10) {
		m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();

		MineralGenerator();

		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}
}

void CGame::GlobalStartCrusadeMode()
{
	uint32_t dwCrusadeGUID;
	SYSTEMTIME SysTime;

	GetLocalTime(&SysTime);
	if (m_iLatestCrusadeDayOfWeek != -1) {
		if (m_iLatestCrusadeDayOfWeek == SysTime.wDayOfWeek) return;
	}
	else m_iLatestCrusadeDayOfWeek = SysTime.wDayOfWeek;

	dwCrusadeGUID = GameClock::GetTimeMS();

	LocalStartCrusadeMode(dwCrusadeGUID);
}

void CGame::OnStartGameSignal()
{
	// Load map configurations from MapInfo.db
	sqlite3* mapInfoDb = nullptr;
	std::string mapInfoDbPath;
	bool mapInfoDbCreated = false;

	if (EnsureMapInfoDatabase(&mapInfoDb, mapInfoDbPath, &mapInfoDbCreated)) {
		if (HasMapInfoRows(mapInfoDb, "maps")) {
			PutLogListLevel(LOG_LEVEL_NOTICE, "Loading map configurations from MapInfo.db...");
			int mapsLoaded = 0;
			for(int i = 0; i < DEF_MAXMAPS; i++)
			{
				if (m_pMapList[i] != 0)
				{
					// Auto-detect fight zone and ice maps from name
					if (memcmp(m_pMapList[i]->m_cName, "fightzone", 9) == 0)
						m_pMapList[i]->m_bIsFightZone = true;
					if (memcmp(m_pMapList[i]->m_cName, "icebound", 8) == 0)
						m_pMapList[i]->m_bIsSnowEnabled = true;

					if (LoadMapConfig(mapInfoDb, m_pMapList[i]->m_cName, m_pMapList[i])) {
						mapsLoaded++;
						// Spawn static NPCs for this map from database
						SpawnMapNpcsFromDatabase(mapInfoDb, i);
					}
					else {
						char cTxt[256];
						std::snprintf(cTxt, sizeof(cTxt), "(!) WARNING: Failed to load map config for: %s", m_pMapList[i]->m_cName);
						PutLogList(cTxt);
						// Fallback to text file
						_bReadMapInfoFiles(i);
					}
				}
			}
			char cTxt[128];
			std::snprintf(cTxt, sizeof(cTxt), "Loaded %d map configurations from database.", mapsLoaded);
			PutLogListLevel(LOG_LEVEL_NOTICE, cTxt);
		}
		else {
			PutLogListLevel(LOG_LEVEL_NOTICE, "MapInfo.db empty, falling back to text files...");
			for(int i = 0; i < DEF_MAXMAPS; i++)
			{
				if (m_pMapList[i] != 0)
				{
					_bReadMapInfoFiles(i);
				}
			}
		}
		CloseMapInfoDatabase(mapInfoDb);
	}
	else {
		PutLogListLevel(LOG_LEVEL_NOTICE, "MapInfo.db not available, loading from text files...");
		for(int i = 0; i < DEF_MAXMAPS; i++)
		{
			if (m_pMapList[i] != 0)
			{
				_bReadMapInfoFiles(i);
			}
		}
	}

	bool loadedSchedules = false;
	sqlite3* configDb = nullptr;
	std::string configDbPath;
	bool configDbCreated = false;
	bool configDbReady = EnsureGameConfigDatabase(&configDb, configDbPath, &configDbCreated);
	if (configDbReady && !configDbCreated) {
		bool hasCrusade = HasGameConfigRows(configDb, "crusade_structures");
		bool hasSchedule = HasGameConfigRows(configDb, "event_schedule");
		if (hasCrusade && hasSchedule) {
			if (LoadCrusadeConfig(configDb, this) && LoadScheduleConfig(configDb, this)) {
				loadedSchedules = true;
			}
		}
	}

	if (!loadedSchedules) {
		PutLogList("(!!!) WARNING! Crusade/Schedule configs missing in GameConfigs.db.");
	}

	_LinkStrikePointMapIndex();

	if (configDb != nullptr) {
		CloseGameConfigDatabase(configDb);
	}

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	bReadApocalypseGUIDFile("GameData\\ApocalypseGUID.txt");
	bReadHeldenianGUIDFile("GameData\\HeldenianGUID.txt");

	PutLogList("(!) Game Server Activated.");

}

void CGame::RequestGuildTeleportHandler(int iClientH)
{
	
	char cMapName[11];

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, 0, 0, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}

	// if a guild teleport is set when its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Accessing crusade teleport: (%s) Player: (%s) - setting teleport location when crusade is disabled.",
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{
		}
		return;
	}

	// if a player is using guild teleport and he is not in a guild, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Accessing crusade teleport: (%s) Player: (%s) - teleporting when not in a guild",
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{
		}
		return;
	}

	if ((m_pClientList[iClientH]->m_cMapIndex == m_iMiddlelandMapIndex) &&
		m_iMiddlelandMapIndex != -1)
		return;

	for(int i = 0; i < DEF_MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
			std::memset(cMapName, 0, sizeof(cMapName));
			strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);

			//testcode
			std::snprintf(G_cTxt, sizeof(G_cTxt), "ReqGuildTeleport: %d %d %d %s", m_pClientList[iClientH]->m_iGuildGUID, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY, cMapName);
			PutLogList(G_cTxt);

			// !!! RequestTeleportHandler m_cMapName
			RequestTeleportHandler(iClientH, "2   ", cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
			return;
		}

	switch (m_pClientList[iClientH]->m_cSide) {
	case 1:
		break;
	case 2:
		break;
	}
}


void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char* pMapName)
{
	
	int iIndex;
	uint32_t dwTemp, dwTime;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange) return;

	// if a player is teleporting and its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Accessing Crusade Set Teleport:(%s) Player: (%s) - setting point when not a crusade.",
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{

		}
		return;
	}

	// if a player is teleporting and its not a crusade, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Accessing Crusade Set Teleport: (%s) Player: (%s) - setting point when not a guildmaster.",
				m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, true, true);
		}
		catch (...)
		{

		}
		return;
	}

	if (dY < 100) dY = 100;
	if (dY > 600) dY = 600;

	dwTime = GameClock::GetTimeMS();

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// GUID       .
	for(int i = 0; i < DEF_MAXGUILDS; i++)
		if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
			if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
			else {
				m_pGuildTeleportLoc[i].m_sDestX = dX;
				m_pGuildTeleportLoc[i].m_sDestY = dY;
				std::memset(m_pGuildTeleportLoc[i].m_cDestMapName, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
				strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				return;
			}
		}

	dwTemp = 0;
	iIndex = -1;
	for(int i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == 0) {

			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			std::memset(m_pGuildTeleportLoc[i].m_cDestMapName, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// .         (iIndex)   .
	if (iIndex == -1) return;

	////testcode
	//PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	//m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	//m_pGuildTeleportLoc[i].m_sDestX = dX;
	//m_pGuildTeleportLoc[i].m_sDestY = dY;
	//std::memset(m_pGuildTeleportLoc[i].m_cDestMapName, 0, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	//strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	//m_pGuildTeleportLoc[i].m_dwTime = dwTime;
}

// New 12/05/2004 Changed
void CGame::MeteorStrikeHandler(int iMapIndex)
{
	int dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
	int iTargetArray[DEF_MAXSTRIKEPOINTS];
	short sOwnerH;
	char  cOwnerType;
	uint32_t dwTime = GameClock::GetTimeMS();

	PutLogList("(!) Beginning Meteor Strike Procedure...");

	if (iMapIndex == -1) {
		PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}

	if (m_pMapList[iMapIndex] == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! 0 Map!");
		return;
	}

	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}

	for(int i = 0; i < DEF_MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for(int i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iTargetArray[iIndex] = i;
			iIndex++;
		}
	}

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(G_cTxt);

	m_stMeteorStrikeResult.iCasualties = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) {
		PutLogList("(!) No strike points!");
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, 0, dwTime + 6000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
	}
	else {

		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
				SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKEHIT, 0, 0, 0, 0);
			}

		for(int i = 0; i < iIndex; i++) {
			iTargetIndex = iTargetArray[i];

			if (iTargetIndex == -1) {
				PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}

			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;

			// dX, dY    2  Energy Shield Generator    .  1   HP .
			// NPC       .
			iTotalESG = 0;
			for(int ix = dX - 10; ix <= dX + 10; ix++)
				for(int iy = dY - 10; iy <= dY + 10; iy++) {
					m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != 0) && (m_pNpcList[sOwnerH]->m_sType == 40)) {
						iTotalESG++;
					}
				}

			// testcode
			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(G_cTxt);

			if (iTotalESG < 2) {

				m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) {
					m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = true;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}
				else {
					m_stMeteorStrikeResult.iStructureDamageAmount += (2 - iTotalESG);
					iEffect = iDice(1, 5) - 1;
					iAddDynamicObjectList(0, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE2, iMapIndex,
						static_cast<short>(m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] + (iDice(1, 3) - 2)),
						static_cast<short>(m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] + (iDice(1, 3) - 2)),
						60 * 1000 * 50);
				}
			}
		MSH_SKIP_STRIKE:;
		}

		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, 0, dwTime + 1000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, 0, dwTime + 4000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, 0, dwTime + 6000, 0, 0, iMapIndex, 0, 0, 0, 0, 0);
	}
}

void CGame::_ClearExchangeStatus(int iToH)
{
	if ((iToH <= 0) || (iToH >= DEF_MAXCLIENTS)) return;
	if (m_pClientList[iToH] == 0) return;

	if (m_pClientList[iToH]->m_cExchangeName)
		SendNotifyMsg(0, iToH, DEF_NOTIFY_CANCELEXCHANGEITEM, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0);

	// m_pClientList[iToH]->m_cExchangeName    = false;
	m_pClientList[iToH]->m_dwInitCCTime = false;
	m_pClientList[iToH]->m_iAlterItemDropIndex = 0;
	//m_pClientList[iToH]->m_cExchangeItemIndex = -1;
	m_pClientList[iToH]->m_iExchangeH = 0;

	m_pClientList[iToH]->m_bIsExchangeMode = false;

	std::memset(m_pClientList[iToH]->m_cExchangeName, 0, sizeof(m_pClientList[iToH]->m_cExchangeName));

}

void CGame::CancelExchangeItem(int iClientH)
{
	int iExH;

	iExH = m_pClientList[iClientH]->m_iExchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}

//HBest force recall start code

//HBest force recall code

void CGame::SetForceRecallTime(int iClientH)
{
	int iTL_ = 0;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
		// iWarPeriod .


		if (m_sForceRecallTime > 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sForceRecallTime;
		}
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeMonday; break;  // 3 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeTuesday; break;
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeWednesday; break;
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeThursday; break;
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeFriday; break;
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeSaturday; break;
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeSunday; break;
			}
		}
	}
	else { // if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) 
		if (m_sForceRecallTime > 0) {
			iTL_ = 20 * m_sForceRecallTime;
		}
		else {

			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20 * m_sRaidTimeMonday; break;  // 3 2002-09-10 #1
			case 2:	iTL_ = 20 * m_sRaidTimeTuesday; break;
			case 3:	iTL_ = 20 * m_sRaidTimeWednesday; break;
			case 4:	iTL_ = 20 * m_sRaidTimeThursday; break;
			case 5:	iTL_ = 20 * m_sRaidTimeFriday; break;
			case 6:	iTL_ = 20 * m_sRaidTimeSaturday; break;
			case 0:	iTL_ = 20 * m_sRaidTimeSunday; break;
			}
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_)
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;

	}

	m_pClientList[iClientH]->m_bIsWarLocation = true;
	return;
}

void CGame::CheckForceRecallTime(int iClientH)
{
	SYSTEMTIME SysTime;
	int iTL_;

	if (m_pClientList[iClientH] == 0) return;


	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
		// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = m_sForceRecallTime * 20;
		}
		// use standard recall time calculations
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeMonday; break;  // 3 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeTuesday; break;
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeWednesday; break;
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeThursday; break;
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeFriday; break;
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeSaturday; break;
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20 * m_sRaidTimeSunday; break;
			}
		}
	}
	else {
		// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			iTL_ = m_sForceRecallTime * 20;
		}
		// use standard recall time calculations
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20 * m_sRaidTimeMonday; break;  // 3 2002-09-10 #1
			case 2:	iTL_ = 20 * m_sRaidTimeTuesday; break;
			case 3:	iTL_ = 20 * m_sRaidTimeWednesday; break;
			case 4:	iTL_ = 20 * m_sRaidTimeThursday; break;
			case 5:	iTL_ = 20 * m_sRaidTimeFriday; break;
			case 6:	iTL_ = 20 * m_sRaidTimeSaturday; break;
			case 0:	iTL_ = 20 * m_sRaidTimeSunday; break;
			}
		}
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_)
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = iTL_;
	}

	m_pClientList[iClientH]->m_bIsWarLocation = true;
	return;

}

int ITEMSPREAD_FIEXD_COORD[25][2] =
{
	{ 0,  0},
	{ 1,  0},
	{ 1,  1},
	{ 0,  1},
	{-1,  1},
	{-1,  0},
	{-1, -1},
	{ 0, -1},
	{ 1, -1},
	{ 2, -1},
	{ 2,  0},
	{ 2,  1},
	{ 2,  2},
	{ 1,  2},
	{ 0,  2},
	{-1,  2},
	{-2,  2},
	{-2,  1},
	{-2,  0},
	{-2, -1},
	{-2, -2},
	{-1, -2},
	{ 0, -2},
	{ 1, -2},
	{ 2, -2},
};


void CGame::SendCollectedMana()
{

	if ((m_iCollectedMana[1] == 0) && (m_iCollectedMana[2] == 0)) return;

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "Sending Collected Mana: %d %d", m_iCollectedMana[1], m_iCollectedMana[2]);
	PutLogList(G_cTxt);

	CollectedManaHandler(m_iCollectedMana[1], m_iCollectedMana[2]);

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
}

void CGame::CollectedManaHandler(uint16_t wAresdenMana, uint16_t wElvineMana)
{
	if (m_iAresdenMapIndex != -1) {
		m_iAresdenMana += wAresdenMana;
		//testcode
		if (wAresdenMana > 0) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Aresden Mana: %d Total:%d", wAresdenMana, m_iAresdenMana);
			PutLogList(G_cTxt);
		}
	}

	if (m_iElvineMapIndex != -1) {
		m_iElvineMana += wElvineMana;
		//testcode
		if (wElvineMana > 0) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Elvine Mana: %d Total:%d", wElvineMana, m_iElvineMana);
			PutLogList(G_cTxt);
		}
	}
}

//New Changed 11/05/2004
void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
	int iActiveStructure, iStructureHP[DEF_MAXSTRIKEPOINTS];
	char* cp2, cWinnerSide, cTempData[120];
	uint16_t* wp;

	if (m_bIsCrusadeMode == false) return;

	for(int i = 0; i < DEF_MAXSTRIKEPOINTS; i++)
		iStructureHP[i] = 0;

	iActiveStructure = 0;
	for(int i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
			iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP;
		}
	}

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "ActiveStructure:%d  MapIndex:%d AresdenMap:%d ElvineMap:%d", iActiveStructure, iMapIndex, m_iAresdenMapIndex, m_iElvineMapIndex);
	PutLogList(G_cTxt);

	if (iActiveStructure == 0) {
		if (iMapIndex == m_iAresdenMapIndex) {
			cWinnerSide = 2;
			LocalEndCrusadeMode(2);
		}
		else if (iMapIndex == m_iElvineMapIndex) {
			cWinnerSide = 1;
			LocalEndCrusadeMode(1);
		}
		else {
			cWinnerSide = 0;
			LocalEndCrusadeMode(0);
		}

	}
	else {
		std::memset(cTempData, 0, sizeof(cTempData));
		cp2 = (char*)(cTempData);

		wp = (uint16_t*)cp2;
		*wp = (uint16_t)m_pMapList[iMapIndex]->m_iTotalStrikePoints;
		cp2 += 2;

		for(int i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
			wp = (uint16_t*)cp2;
			*wp = (uint16_t)iStructureHP[i];
			cp2 += 2;
		}

		//memcpy(cp,cTempData,2*(m_pMapList[iMapIndex]->m_iTotalStrikePoints+1) ) ;

		// v2.15 

		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure, m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);
	}

	m_stMeteorStrikeResult.iCasualties = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}

void CGame::_LinkStrikePointMapIndex()
{
	int z, x;

	for(int i = 0; i < DEF_MAXMAPS; i++)
		if ((m_pMapList[i] != 0) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
			for (z = 0; z < DEF_MAXSTRIKEPOINTS; z++)
				if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
					for (x = 0; x < DEF_MAXMAPS; x++)
						if ((m_pMapList[x] != 0) && (strcmp(m_pMapList[x]->m_cName, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
							m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
							//testcode
							PutLogList(G_cTxt);

							goto LSPMI_LOOPBREAK;
						}
				LSPMI_LOOPBREAK:;
				}
		}
}

bool CGame::_bRegisterMap(char* pName)
{
	
	char cTmpName[11], cTxt[120];

	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	for(int i = 0; i < DEF_MAXMAPS; i++)
		if ((m_pMapList[i] != 0) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
			std::snprintf(cTxt, sizeof(cTxt), "Map already installed: %s", cTmpName);
			PutLogListLevel(LOG_LEVEL_ERROR, cTxt);
			return false;
		}

	for(int i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] == 0) {
			m_pMapList[i] = new class CMap(this);
			if (m_pMapList[i]->bInit(pName) == false) {
				std::snprintf(cTxt, sizeof(cTxt), "Map data load failed: %s", pName);
				PutLogListLevel(LOG_LEVEL_ERROR, cTxt);
				return false;
			};

			if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0))
				m_iMiddlelandMapIndex = i;

			if ((m_iAresdenMapIndex == -1) && (strcmp("aresden", pName) == 0))
				m_iAresdenMapIndex = i;

			if ((m_iElvineMapIndex == -1) && (strcmp("elvine", pName) == 0))
				m_iElvineMapIndex = i;

			if ((m_iBTFieldMapIndex == -1) && (strcmp("BtField", pName) == 0))
				m_iBTFieldMapIndex = i;

			if ((m_iGodHMapIndex == -1) && (strcmp("GodH", pName) == 0))
				m_iGodHMapIndex = i;

			m_iTotalMaps++;
			return true;
		}

	std::snprintf(cTxt, sizeof(cTxt), "Map cannot be added (no space): %s", pName);
	PutLogListLevel(LOG_LEVEL_ERROR, cTxt);
	return false;
}

//New Changed 11/05/2004
void CGame::GrandMagicResultHandler(char* cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iTotalStrikePoints, char* cData)
{
	

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != 0) {
			SendNotifyMsg(0, i, DEF_NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure, 0, 0, 0, 0, iTotalStrikePoints, cData);
		}
}

bool CGame::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, bool bBonus)
{
	int iValue, iProb, iResult;

	if (m_pClientList[iClientH]->m_pItemList[iSomH] == 0) return false;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x0F0000000) >> 28;

	switch (iValue) {
	case 0: iProb = 30; break;  // +1 :90%     +1~+2
	case 1: iProb = 25; break;  // +2 :80%      +3
	case 2: iProb = 20; break;  // +3 :48%      +4 
	case 3: iProb = 15; break;  // +4 :24%      +5
	case 4: iProb = 10; break;  // +5 :9.6%     +6
	case 5: iProb = 10; break;  // +6 :2.8%     +7
	case 6: iProb = 8; break;  // +7 :0.57%    +8
	case 7: iProb = 8; break;  // +8 :0.05%    +9
	case 8: iProb = 5; break;  // +9 :0.004%   +10
	case 9: iProb = 3; break;  // +10:0.00016%
	default: iProb = 1; break;
	}

	if (((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100)) {
		if (iProb > 20)
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
		else if (iProb > 7)
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
		else
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
	}
	if (bBonus) iProb *= 2;

	iProb *= 100;
	iResult = iDice(1, 10000);

	if (iProb >= iResult) {
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
		return true;
	}

	_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

	return false;
}

void CGame::ShowClientMsg(int iClientH, char* pMsg)
{
	char* cp, cTemp[256];
	size_t dwMsgSize;
	short* sp;

	std::memset(cTemp, 0, sizeof(cTemp));

	{
		auto* header = reinterpret_cast<hb::net::PacketHeader*>(cTemp);
		header->msg_id = MSGID_COMMAND_CHATMSG;
		header->msg_type = 0;
	}

	cp = (char*)(cTemp + sizeof(hb::net::PacketHeader));
	sp = (short*)cp;
	*sp = 0;
	cp += 2;

	sp = (short*)cp;
	*sp = 0;
	cp += 2;

	memcpy(cp, "HGServer", 8); // Player name :P
	cp += 10;

	*cp = 10; // chat type
	cp++;

	dwMsgSize = strlen(pMsg);
	if (dwMsgSize > 50) dwMsgSize = 50;
	memcpy(cp, pMsg, dwMsgSize);
	cp += dwMsgSize;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
}

void CGame::Command_YellowBall(int iClientH, char* pData, size_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* token, cBuff[256], cPlayerName[11], cMapName[32];
	int iSoxH, iSoX;

	if (m_pClientList[iClientH] == 0) return;
	if ((dwMsgSize) <= 0) return;

	iSoX = 0;
	for(int i = 0; i < hb::limits::MaxItems; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 653: iSoX++; iSoxH = i; break;
			}
		}
	if (iSoX > 0) {

		std::memset(cPlayerName, 0, sizeof(cPlayerName));
		std::memset(cBuff, 0, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		token = strtok(NULL, seps);

		token = strtok(NULL, seps);
		if (token == 0) {
			return;
		}

		if (strlen(token) > DEF_CHARNAME - 1) {
			memcpy(cPlayerName, token, DEF_CHARNAME - 1);
		}
		else {
			memcpy(cPlayerName, token, strlen(token));
		}

		for(int i = 1; i < DEF_MAXCLIENTS; i++) {
			if (m_pClientList[i] != 0) {
				if (_strnicmp(cPlayerName, m_pClientList[i]->m_cCharName, DEF_CHARNAME - 1) == 0) {
					if ((m_pClientList[iClientH]->m_cLocation) != (m_pClientList[i]->m_cLocation)) return;
					std::memset(cMapName, 0, sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					ItemLog::Get().LogMisc("YellowBall", m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress,
						m_pClientList[i]->m_cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, nullptr);
					ItemDepleteHandler(iClientH, iSoxH, true);
					RequestTeleportHandler(iClientH, "2   ", cMapName, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					return;
				}
			}
		}
	}
}

void CGame::Command_RedBall(int iClientH, char* pData, size_t dwMsgSize)
{
	char seps[] = "= \t\r\n", cName[DEF_NPCNAME], cNpcName[DEF_NPCNAME], cNpcWaypoint[11];
	int iNamingValue, tX, tY, x, iNpcID;
	int iSoxH, iSoX;

	if (m_pClientList[iClientH] == 0) return;
	if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) != 0)) return;

	iSoX = 0;
	for(int i = 0; i < hb::limits::MaxItems; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 652: iSoX++; iSoxH = i; break;
			}
		}
	if (iSoX > 0) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {

		}
		else {

			std::memset(cNpcName, 0, sizeof(cNpcName));
			switch (iDice(1, 5)) {
			case 1: strcpy(cNpcName, "Wyvern"); iNpcID = 66; break;
			case 2: strcpy(cNpcName, "Hellclaw"); iNpcID = 49; break;
			case 3: strcpy(cNpcName, "Fire-Wyvern"); iNpcID = 73; break;
			case 4: strcpy(cNpcName, "Tigerworm"); iNpcID = 50; break;
			case 5: strcpy(cNpcName, "Gagoyle"); iNpcID = 52; break;
			}
			std::memset(cName, 0, sizeof(cName));
			std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

			std::memset(cNpcWaypoint, 0, sizeof(cNpcWaypoint));

			tX = (int)m_pClientList[iClientH]->m_sX;
			tY = (int)m_pClientList[iClientH]->m_sY;
			if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, (rand() % 9),
				DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, 0, 0, -1, false, false) == false) {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				ItemLog::Get().LogMisc("RedBall", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cIPaddress,
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, tX, tY, nullptr);
			}
		}

		for (x = 1; x < DEF_MAXCLIENTS; x++)
			if ((m_pClientList[x] != 0) && (m_pClientList[x]->m_bIsInitComplete)) {
				SendNotifyMsg(0, x, DEF_NOTIFY_SPAWNEVENT, tX, tY, iNpcID, 0, 0, 0);
			}
		ItemDepleteHandler(iClientH, iSoxH, true);
	}
}

void CGame::Command_BlueBall(int iClientH, char* pData, size_t dwMsgSize)

{
	char seps[] = "= \t\r\n";
	char   cName_Master[10], cName_Slave[10], cNpcName[DEF_NPCNAME], cWaypoint[11], cSA;
	int    pX, pY, j, iNum, iNamingValue, iNpcID;
	int x;
	bool   bMaster;
	int iSoxH, iSoX;

	if (m_pClientList[iClientH] == 0) return;
	if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) != 0)) return;


	iSoX = 0;
	for(int i = 0; i < hb::limits::MaxItems; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 654: iSoX++; iSoxH = i; break;
			}
		}
	if (iSoX > 0) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {

		}
		else {

			std::memset(cNpcName, 0, sizeof(cNpcName));

			switch (iDice(1, 38)) {
			case 1: strcpy(cNpcName, "Slime");			iNpcID = 10; break;
			case 2: strcpy(cNpcName, "Giant-Ant");		iNpcID = 15; break;
			case 3: strcpy(cNpcName, "Zombie");			iNpcID = 17; break;
			case 4: strcpy(cNpcName, "Scorpion");		iNpcID = 16; break;
			case 5: strcpy(cNpcName, "Skeleton");		iNpcID = 11; break;
			case 6: strcpy(cNpcName, "Orc-Mage");		iNpcID = 14; break;
			case 7: strcpy(cNpcName, "Clay-Golem");		iNpcID = 23; break;
			case 8: strcpy(cNpcName, "Stone-Golem");	iNpcID = 12; break;
			case 9: strcpy(cNpcName, "Hellbound");		iNpcID = 27; break;
			case 10: strcpy(cNpcName, "Giant-Frog");	iNpcID = 57; break;
			case 11: strcpy(cNpcName, "Troll");			iNpcID = 28; break;
			case 12: strcpy(cNpcName, "Cyclops");		iNpcID = 13; break;
			case 13: strcpy(cNpcName, "Ice-Golem");		iNpcID = 65; break;
			case 14: strcpy(cNpcName, "Beholder");		iNpcID = 53; break;
			case 15: strcpy(cNpcName, "Cannibal-Plant"); iNpcID = 60; break;
			case 16: strcpy(cNpcName, "Orge");			iNpcID = 29; break;
			case 17: strcpy(cNpcName, "Mountain-Giant"); iNpcID = 58; break;
			case 18: strcpy(cNpcName, "DireBoar");		iNpcID = 62; break;
			case 19: strcpy(cNpcName, "Liche");			iNpcID = 30; break;
			case 20: strcpy(cNpcName, "Stalker");		iNpcID = 48; break;
			case 21: strcpy(cNpcName, "WereWolf");		iNpcID = 33; break;
			case 22: strcpy(cNpcName, "Dark-Elf");		iNpcID = 54; break;
			case 23: strcpy(cNpcName, "Frost");			iNpcID = 63; break;
			case 24: strcpy(cNpcName, "Orc");			iNpcID = 14; break;
			case 25: strcpy(cNpcName, "Ettin");			iNpcID = 59; break;
			case 26: strcpy(cNpcName, "Tentocle");		iNpcID = 80; break;
			case 27: strcpy(cNpcName, "Giant-Crayfish"); iNpcID = 74; break;
			case 28: strcpy(cNpcName, "Giant-Plant");	iNpcID = 76; break;
			case 29: strcpy(cNpcName, "Rudolph");		iNpcID = 61; break;
			case 30: strcpy(cNpcName, "Claw-Turtle");	iNpcID = 72; break;
			case 31: strcpy(cNpcName, "Centaurus");		iNpcID = 71; break;
			case 32: strcpy(cNpcName, "Barlog");		iNpcID = 70; break;
			case 33: strcpy(cNpcName, "Giant-Lizard");	iNpcID = 75; break;
			case 34: strcpy(cNpcName, "MasterMage-Orc"); iNpcID = 77; break;
			case 35: strcpy(cNpcName, "Minotaurs");		iNpcID = 78; break;
			case 36: strcpy(cNpcName, "Unicorn");		iNpcID = 32; break;
			case 37: strcpy(cNpcName, "Nizie");			iNpcID = 79; break;
			}

			iNum = 10;
			cSA = 0;
			pX = m_pClientList[iClientH]->m_sX;
			pY = m_pClientList[iClientH]->m_sY;

			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) BlueBallEvent: SummonMob (%s)-(%d)", cNpcName, iNum);
			PutLogList(G_cTxt);

			iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {

				std::memset(cName_Master, 0, sizeof(cName_Master));
				std::snprintf(cName_Master, sizeof(cName_Master), "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;

				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false, true)) == false) {

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				}
			}

			for (j = 0; j < (iNum - 1); j++) {
				iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					// Slave Mob
					std::memset(cName_Slave, 0, sizeof(cName_Slave));
					std::snprintf(cName_Slave, sizeof(cName_Slave), "XX%d", iNamingValue);
					cName_Slave[0] = '_';
					cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;


					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, 0, 0, -1, false, false, false) == false) {

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						// Slave
						if (m_pEntityManager != 0) m_pEntityManager->bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}

		}
	}

	for (x = 1; x < DEF_MAXCLIENTS; x++)
		if ((m_pClientList[x] != 0) && (m_pClientList[x]->m_bIsInitComplete)) {
			SendNotifyMsg(0, x, DEF_NOTIFY_SPAWNEVENT, pX, pY, iNpcID, 0, 0, 0);
		}
	ItemDepleteHandler(iClientH, iSoxH, true);
}


/*
at the end of client connection have a true switch
at the start of client move handler check if the switch is true
if it is not true add 1 warning, if the warning reaches 3
delete client and log him, if the true switch
*/
//and when a client walks into a map with dynamic portal
//[KLKS] - [Pretty Good Coders] says:
//u gotta inform it
//[KLKS] - [Pretty Good Coders] says:
//or else they wont see it

/*void CGame::OpenApocalypseGate(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;

	//m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAliveObject;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_APOCGATEOPEN, 95, 31, 0, m_pClientList[iClientH]->m_cMapName);
}*/

void CGame::GlobalEndApocalypseMode()
{
	if (m_bIsApocalypseMode == false) return;

	LocalEndApocalypse();
}

void CGame::GlobalUpdateConfigs(char cConfigType)
{
	LocalUpdateConfigs(cConfigType);
}

void CGame::LocalUpdateConfigs(char cConfigType)
{
	sqlite3* configDb = nullptr;
	std::string configDbPath;
	bool configDbCreated = false;
	if (!EnsureGameConfigDatabase(&configDb, configDbPath, &configDbCreated) || configDbCreated) {
		PutLogList("(!!!) GameConfigs.db unavailable; cannot reload configs.");
		return;
	}

	bool ok = false;
	if (cConfigType == 1) {
		ok = HasGameConfigRows(configDb, "settings") && LoadSettingsConfig(configDb, this);
		PutLogList(ok ? "(!!!) Settings updated successfully!" : "(!!!) Settings reload failed!");
	}
	if (cConfigType == 3) {
		ok = LoadBannedListConfig(configDb, this);
		PutLogList(ok ? "(!!!) BannedList updated successfully!" : "(!!!) BannedList reload failed!");
	}
	CloseGameConfigDatabase(configDb);
}

void CGame::ReloadItemConfigs()
{
	sqlite3* configDb = nullptr;
	std::string configDbPath;
	bool configDbCreated = false;
	if (!EnsureGameConfigDatabase(&configDb, configDbPath, &configDbCreated) || configDbCreated)
	{
		PutLogList((char*)"(!) Item config reload FAILED - GameConfigs.db unavailable");
		return;
	}

	for(int i = 0; i < DEF_MAXITEMTYPES; i++)
	{
		if (m_pItemConfigList[i] != 0)
		{
			delete m_pItemConfigList[i];
			m_pItemConfigList[i] = 0;
		}
	}

	if (!LoadItemConfigs(configDb, m_pItemConfigList, DEF_MAXITEMTYPES))
	{
		PutLogList((char*)"(!) Item config reload FAILED");
		CloseGameConfigDatabase(configDb);
		return;
	}

	CloseGameConfigDatabase(configDb);
	ComputeConfigHashes();
	PutLogList((char*)"(*) Item configs reloaded successfully");
}

void CGame::ReloadMagicConfigs()
{
	sqlite3* configDb = nullptr;
	std::string configDbPath;
	bool configDbCreated = false;
	if (!EnsureGameConfigDatabase(&configDb, configDbPath, &configDbCreated) || configDbCreated)
	{
		PutLogList((char*)"(!) Magic config reload FAILED - GameConfigs.db unavailable");
		return;
	}

	for(int i = 0; i < DEF_MAXMAGICTYPE; i++)
	{
		if (m_pMagicConfigList[i] != 0)
		{
			delete m_pMagicConfigList[i];
			m_pMagicConfigList[i] = 0;
		}
	}

	if (!LoadMagicConfigs(configDb, this))
	{
		PutLogList((char*)"(!) Magic config reload FAILED");
		CloseGameConfigDatabase(configDb);
		return;
	}

	CloseGameConfigDatabase(configDb);
	ComputeConfigHashes();
	PutLogList((char*)"(*) Magic configs reloaded successfully");
}

void CGame::ReloadSkillConfigs()
{
	sqlite3* configDb = nullptr;
	std::string configDbPath;
	bool configDbCreated = false;
	if (!EnsureGameConfigDatabase(&configDb, configDbPath, &configDbCreated) || configDbCreated)
	{
		PutLogList((char*)"(!) Skill config reload FAILED - GameConfigs.db unavailable");
		return;
	}

	for(int i = 0; i < DEF_MAXSKILLTYPE; i++)
	{
		if (m_pSkillConfigList[i] != 0)
		{
			delete m_pSkillConfigList[i];
			m_pSkillConfigList[i] = 0;
		}
	}

	if (!LoadSkillConfigs(configDb, this))
	{
		PutLogList((char*)"(!) Skill config reload FAILED");
		CloseGameConfigDatabase(configDb);
		return;
	}

	CloseGameConfigDatabase(configDb);
	ComputeConfigHashes();
	PutLogList((char*)"(*) Skill configs reloaded successfully");
}

void CGame::ReloadNpcConfigs()
{
	sqlite3* configDb = nullptr;
	std::string configDbPath;
	bool configDbCreated = false;
	if (!EnsureGameConfigDatabase(&configDb, configDbPath, &configDbCreated) || configDbCreated)
	{
		PutLogList((char*)"(!) NPC config reload FAILED - GameConfigs.db unavailable");
		return;
	}

	for(int i = 0; i < DEF_MAXNPCTYPES; i++)
	{
		if (m_pNpcConfigList[i] != 0)
		{
			delete m_pNpcConfigList[i];
			m_pNpcConfigList[i] = 0;
		}
	}

	if (!LoadNpcConfigs(configDb, this))
	{
		PutLogList((char*)"(!) NPC config reload FAILED");
		CloseGameConfigDatabase(configDb);
		return;
	}

	CloseGameConfigDatabase(configDb);
	PutLogList((char*)"(*) NPC configs reloaded successfully (new spawns will use updated data)");
}

void CGame::SendConfigReloadNotification(bool bItems, bool bMagic, bool bSkills)
{
	hb::net::PacketNotifyConfigReload pkt{};
	pkt.header.msg_id = MSGID_NOTIFY_CONFIG_RELOAD;
	pkt.header.msg_type = DEF_MSGTYPE_CONFIRM;
	pkt.reloadItems = bItems ? 1 : 0;
	pkt.reloadMagic = bMagic ? 1 : 0;
	pkt.reloadSkills = bSkills ? 1 : 0;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
	{
		if (m_pClientList[i] != 0 && m_pClientList[i]->m_bIsInitComplete)
			m_pClientList[i]->m_pXSock->iSendMsg((char*)&pkt, sizeof(pkt));
	}
}

void CGame::PushConfigReloadToClients(bool bItems, bool bMagic, bool bSkills)
{
	int iCount = 0;
	for(int i = 1; i < DEF_MAXCLIENTS; i++)
	{
		if (m_pClientList[i] != 0 && m_pClientList[i]->m_bIsInitComplete)
		{
			if (bItems)  bSendClientItemConfigs(i);
			if (bMagic)  bSendClientMagicConfigs(i);
			if (bSkills) bSendClientSkillConfigs(i);
			iCount++;
		}
	}

	char buf[128];
	std::snprintf(buf, sizeof(buf), "(*) Config reload pushed to %d client(s)", iCount);
	PutLogList(buf);
}

void CGame::LocalEndApocalypse()
{
	

	m_bIsApocalypseMode = false;

	for(int i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATEENDMSG, 0, 0, 0, 0);
		}
	}
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!)Apocalypse Mode OFF.");
	PutLogList(G_cTxt);
}

void CGame::LocalStartApocalypse(uint32_t dwApocalypseGUID)
{
	
	//uint32_t dwApocalypse;

	m_bIsApocalypseMode = true;

	if (dwApocalypseGUID != 0) {
		_CreateApocalypseGUID(dwApocalypseGUID);
		//m_dwApocalypseGUID = dwApocalypse;
	}

	for(int i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			SendNotifyMsg(0, i, DEF_NOTIFY_APOCGATESTARTMSG, 0, 0, 0, 0);
			//RequestTeleportHandler(i, "0   ");
			//SendNotifyMsg(0, i, DEF_NOTIFY_APOCFORCERECALLPLAYERS, 0, 0, 0, 0);
		}
	}
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!)Apocalypse Mode ON.");
	PutLogList(G_cTxt);
}

bool CGame::bReadApocalypseGUIDFile(char* cFn)
{
	FILE* pFile;
	HANDLE hFile;
	uint32_t  dwFileSize;
	char* cp, * token, cReadMode;
	char seps[] = "= \t\r\n";

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		return false;
	}
	else {
		cp = new char[dwFileSize + 2];
		std::memset(cp, 0, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok(cp, seps);

		while (token != 0) {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwApocalypseGUID = atoi(token);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "ApocalypseGUID = %d", m_dwApocalypseGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "ApocalypseGUID", 14) == 0) cReadMode = 1;
			}

			token = strtok(NULL, seps);
		}

		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

bool CGame::bReadHeldenianGUIDFile(char* cFn)
{
	FILE* pFile;
	HANDLE hFile;
	uint32_t  dwFileSize;
	char* cp, * token, cReadMode;
	char seps[] = "= \t\r\n";

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, 0, 0, OPEN_EXISTING, 0, 0);
	dwFileSize = GetFileSize(hFile, 0);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == 0) {
		return false;
	}
	else {
		cp = new char[dwFileSize + 2];
		std::memset(cp, 0, dwFileSize + 2);
		fread(cp, dwFileSize, 1, pFile);

		token = strtok(cp, seps);

		while (token != 0) {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwHeldenianGUID = atoi(token);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "HeldenianGUID = %d", m_dwHeldenianGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				case 2:
					m_sLastHeldenianWinner = atoi(token);
					std::snprintf(G_cTxt, sizeof(G_cTxt), "HeldenianWinnerSide = %d", m_sLastHeldenianWinner);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "HeldenianGUID", 13) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}

			token = strtok(NULL, seps);
		}

		delete cp;
	}
	if (pFile != 0) fclose(pFile);

	return true;
}

void CGame::_CreateApocalypseGUID(uint32_t dwApocalypseGUID)
{
	char* cp, cTxt[256], cFn[256], cTemp[1024];
	FILE* pFile;

#ifdef _WIN32
	_mkdir("GameData");
#endif
	std::memset(cFn, 0, sizeof(cFn));

	strcat(cFn, "GameData");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, "ApocalypseGUID.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == 0) {
		std::snprintf(cTxt, sizeof(cTxt), "(!) Cannot create ApocalypseGUID(%d) file", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	else {
		std::memset(cTemp, 0, sizeof(cTemp));

		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "ApocalypseGUID = %d\n", dwApocalypseGUID);
		strcat(cTemp, cTxt);

		cp = (char*)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);

		std::snprintf(cTxt, sizeof(cTxt), "(O) ApocalypseGUID(%d) file created", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	if (pFile != 0) fclose(pFile);
}

/*void CGame::ApocalypseStarter()
{
 SYSTEMTIME SysTime;
 

	if (m_bIsApocalypseMode ) return;
	if (m_bIsApocalypseStarter == false) return;

	GetLocalTime(&SysTime);

	for(int i = 0; i < DEF_MAXAPOCALYPSE; i++)
	if	((m_stApocalypseScheduleStart[i].iDay == SysTime.wDayOfWeek) &&
		(m_stApocalypseScheduleStart[i].iHour == SysTime.wHour) &&
		(m_stApocalypseScheduleStart[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated apocalypse is initiated!");
			GlobalStartApocalypseMode();
			return;
	}
}*/

void CGame::ApocalypseEnder()
{
	SYSTEMTIME SysTime;
	

	if (m_bIsApocalypseMode == false) return;
	if (m_bIsApocalypseStarter == false) return;

	GetLocalTime(&SysTime);

	for(int i = 0; i < DEF_MAXAPOCALYPSE; i++)
		if ((m_stApocalypseScheduleEnd[i].iDay == SysTime.wDayOfWeek) &&
			(m_stApocalypseScheduleEnd[i].iHour == SysTime.wHour) &&
			(m_stApocalypseScheduleEnd[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated apocalypse is concluded!");
			GlobalEndApocalypseMode();
			return;
		}
}

// New 06/05/2004
// Party Code
void CGame::RequestCreatePartyHandler(int iClientH)
{
	char* cp, cData[120];
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) {
		return;
	}

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
	cp = (char*)cData;

	/*dwp = (uint32_t *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;*/
	wp = (uint16_t*)cp;
	*wp = 1; // 1, request
	cp += 2;

	wp = (uint16_t*)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
	cp += 10;

	PartyOperation(cData);;

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "Request Create Party: %d", iClientH);
	PutLogList(G_cTxt);
}

// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResultHandler(char* pData)
{
	char* cp, cResult, cName[12];
	uint16_t* wp;
	int iClientH, iPartyID, iTotal;

	cp = (char*)(pData);
	wp = (uint16_t*)cp;
	cp += 2;

	switch (*wp) {
	case 1:
		cResult = *cp;
		cp++;

		wp = (uint16_t*)cp;
		iClientH = (int)*wp;
		cp += 2;

		std::memset(cName, 0, sizeof(cName));
		memcpy(cName, cp, DEF_CHARNAME - 1);
		cp += 10;

		wp = (uint16_t*)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Create(iClientH, cName, cResult, iPartyID);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "party Operation Result: Create(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 2:
		wp = (uint16_t*)cp;
		iPartyID = *wp;
		cp += 2;

		PartyOperationResult_Delete(iPartyID);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "party Operation Result: Delete(PartyID:%d)", iPartyID);
		PutLogList(G_cTxt);
		break;

	case 3:
		wp = (uint16_t*)cp;
		iClientH = *wp;
		cp += 2;

		std::memset(cName, 0, sizeof(cName));
		memcpy(cName, cp, DEF_CHARNAME - 1);
		cp += 10;

		if ((iClientH < 0) && (iClientH > DEF_MAXCLIENTS)) return;
		if (m_pClientList[iClientH] == 0) return;
		if (_stricmp(m_pClientList[iClientH]->m_cCharName, cName) != 0) return;

		for(int i = 0; i < hb::limits::MaxPartyMembers; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;

				std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d Out(Clear) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORH_LOOPBREAK1;
			}
	PORH_LOOPBREAK1:

		for(int i = 0; i < hb::limits::MaxPartyMembers - 1; i++)
			if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1] != 0)) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1];
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i + 1] = 0;
			}

		m_pClientList[iClientH]->m_iPartyID = 0;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;

		std::snprintf(G_cTxt, sizeof(G_cTxt), "Party Status 0: %s", m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);

		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 8, 0, 0, 0);
		break;

	case 4:
		cResult = *cp;
		cp++;

		wp = (uint16_t*)cp;
		iClientH = (int)*wp;
		cp += 2;

		std::memset(cName, 0, sizeof(cName));
		memcpy(cName, cp, DEF_CHARNAME - 1);
		cp += 10;

		wp = (uint16_t*)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Join(iClientH, cName, cResult, iPartyID);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "party Operation Result: Join(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 5:
		wp = (uint16_t*)cp;
		iClientH = (int)*wp;
		cp += 2;

		std::memset(cName, 0, sizeof(cName));
		memcpy(cName, cp, DEF_CHARNAME - 1);
		cp += 10;

		wp = (uint16_t*)cp;
		iTotal = (int)*wp;
		cp += 2;

		PartyOperationResult_Info(iClientH, cName, iTotal, cp);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "party Operation Result: Info(ClientH:%d Total:%d)", iClientH, iTotal);
		PutLogList(G_cTxt);
		break;

	case 6:
		cResult = *cp;
		cp++;

		wp = (uint16_t*)cp;
		iClientH = (int)*wp;
		cp += 2;

		std::memset(cName, 0, sizeof(cName));
		memcpy(cName, cp, DEF_CHARNAME - 1);
		cp += 10;

		wp = (uint16_t*)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Dismiss(iClientH, cName, cResult, iPartyID);

		std::snprintf(G_cTxt, sizeof(G_cTxt), "party Operation Result: Dismiss(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;
	}
}


void CGame::PartyOperationResult_Create(int iClientH, char* pName, int iResult, int iPartyID)
{
	char* cp, cData[120];
	uint16_t* wp;
	

	if (m_pClientList[iClientH] == 0) return;
	if (_stricmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

	switch (iResult) {
	case 0:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (_stricmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = 0;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 1, 0, 0, 0);
		break;

	case 1:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (_stricmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 1, 1, 0, 0);

		for(int i = 0; i < hb::limits::MaxPartyMembers; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
				//testcode
				std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d New Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
	PORC_LOOPBREAK1:

		if ((m_pClientList[iClientH]->m_iReqJoinPartyClientH != 0) && (strlen(m_pClientList[iClientH]->m_cReqJoinPartyName) != 0)) {
			std::memset(cData, 0, sizeof(cData));
			cp = (char*)cData;
			/*dwp = (uint32_t *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;*/
			wp = (uint16_t*)cp;
			*wp = 3;
			cp += 2;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			PartyOperation(cData);;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
			std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResult_Join(int iClientH, char* pName, int iResult, int iPartyID)
{
	

	if (m_pClientList[iClientH] == 0) return;

	switch (iResult) {
	case 0:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (_stricmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = 0;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 4, 0, 0, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (_stricmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 4, 1, 0, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));

		for(int i = 0; i < hb::limits::MaxPartyMembers; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;

				std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d In(Join) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
	PORC_LOOPBREAK1:

		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if ((i != iClientH) && (m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
				SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 4, 1, 0, pName);
			}
		break;
	}
}

void CGame::PartyOperationResult_Dismiss(int iClientH, char* pName, int iResult, int iPartyID)
{
	
	// iClientH     .

	switch (iResult) {
	case 0:
		break;

	case 1:
		if (iClientH == 0) {
			// iClientH  NULL        .
			for(int i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (_stricmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
					iClientH = i;
					goto PORD_LOOPBREAK;
				}
		PORD_LOOPBREAK:

			for(int i = 0; i < hb::limits::MaxPartyMembers; i++)
				if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
					m_stPartyInfo[iPartyID].iIndex[i] = 0;
					m_stPartyInfo[iPartyID].iTotalMembers--;
					//testcode
					std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
					PutLogList(G_cTxt);
					goto PORC_LOOPBREAK1;
				}
		PORC_LOOPBREAK1:
			for(int i = 0; i < hb::limits::MaxPartyMembers - 1; i++)
				if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i + 1] != 0)) {
					m_stPartyInfo[iPartyID].iIndex[i] = m_stPartyInfo[iPartyID].iIndex[i + 1];
					m_stPartyInfo[iPartyID].iIndex[i + 1] = 0;
				}

			if (m_pClientList[iClientH] != 0) {
				m_pClientList[iClientH]->m_iPartyID = 0;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
			}

			for(int i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
					SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 6, 1, 0, pName);
				}
			return;
		}

		if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING)) return;
		if ((m_pClientList[iClientH] != 0) && (_stricmp(m_pClientList[iClientH]->m_cCharName, pName) != 0)) return;

		for(int i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
				SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 6, 1, 0, pName);
			}

		for(int i = 0; i < hb::limits::MaxPartyMembers; i++)
			if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[iPartyID].iIndex[i] = 0;
				m_stPartyInfo[iPartyID].iTotalMembers--;
				//testcode
				std::snprintf(G_cTxt, sizeof(G_cTxt), "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK2;
			}
	PORC_LOOPBREAK2:
		for(int i = 0; i < hb::limits::MaxPartyMembers - 1; i++)
			if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i + 1] != 0)) {
				m_stPartyInfo[iPartyID].iIndex[i] = m_stPartyInfo[iPartyID].iIndex[i + 1];
				m_stPartyInfo[iPartyID].iIndex[i + 1] = 0;
			}

		if (m_pClientList[iClientH] != 0) {
			m_pClientList[iClientH]->m_iPartyID = 0;
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		}
		break;
	}
}

void CGame::PartyOperationResult_Delete(int iPartyID)
{
	

	for(int i = 0; i < hb::limits::MaxPartyMembers; i++)
	{
		m_stPartyInfo[iPartyID].iIndex[i] = 0;
		m_stPartyInfo[iPartyID].iTotalMembers = 0;
	}

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
			SendNotifyMsg(0, i, DEF_NOTIFY_PARTY, 2, 0, 0, 0);
			m_pClientList[i]->m_iPartyID = 0;
			m_pClientList[i]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[i]->m_iReqJoinPartyClientH = 0;
			//testcode
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Notify delete party: %d", i);
			PutLogList(G_cTxt);
		}
}


void CGame::RequestJoinPartyHandler(int iClientH, char* pData, size_t dwMsgSize)
{
	char   seps[] = "= \t\r\n";
	char* cp, * token, cBuff[256], cData[120], cName[12];
	uint16_t* wp;
	

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) return;
	if ((dwMsgSize) <= 0) return;

	std::memset(cBuff, 0, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	token = strtok(cBuff, seps);

	token = strtok(NULL, seps);
	if (token != 0) {
		std::memset(cName, 0, sizeof(cName));
		strcpy(cName, token);
	}
	else return;

	for(int i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != 0) && (_stricmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
			if ((m_pClientList[i]->m_iPartyID == 0) || (m_pClientList[i]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM)) {
				return;
			}

			std::memset(cData, 0, sizeof(cData));

			cp = (char*)cData;
			/*dwp = (uint32_t *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;*/
			wp = (uint16_t*)cp;
			*wp = 3;
			cp += 2;
			wp = (uint16_t*)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
			cp += 10;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[i]->m_iPartyID;
			cp += 2;
			PartyOperation(cData);;
			return;
		}

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, 0, 0, 0, cName);
}


void CGame::RequestDismissPartyHandler(int iClientH)
{
	char* cp, cData[120];
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	cp = (char*)cData;
	/*dwp = (uint32_t *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;*/
	wp = (uint16_t*)cp;
	*wp = 4;
	cp += 2;
	wp = (uint16_t*)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
	cp += 10;
	wp = (uint16_t*)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	PartyOperation(cData);;

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
}


void CGame::GetPartyInfoHandler(int iClientH)
{
	char* cp, cData[120];
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	cp = (char*)cData;
	/*dwp = (uint32_t *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;*/
	wp = (uint16_t*)cp;
	*wp = 5;
	cp += 2;
	wp = (uint16_t*)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
	cp += 10;
	wp = (uint16_t*)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	PartyOperation(cData);;
}


void CGame::PartyOperationResult_Info(int iClientH, char* pName, int iTotal, char* pNameList)
{
	if (m_pClientList[iClientH] == 0) return;
	if (_stricmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	SendNotifyMsg(0, iClientH, DEF_NOTIFY_PARTY, 5, 1, iTotal, pNameList);
}

void CGame::RequestDeletePartyHandler(int iClientH)
{
	char* cp, cData[120];
	uint16_t* wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iPartyID != 0) {
		std::memset(cData, 0, sizeof(cData));
		cp = (char*)cData;
		/*dwp = (uint32_t *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;*/
		wp = (uint16_t*)cp;
		*wp = 4;
		cp += 2;
		wp = (uint16_t*)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, DEF_CHARNAME - 1);
		cp += 10;
		wp = (uint16_t*)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		PartyOperation(cData);;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
	}
}

void CGame::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
	char* cp, cData[120];
	uint16_t* wp;
	int iH;

	if (m_pClientList[iClientH] == 0) return;

	switch (iResult) {
	case 0:
		iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
		if (m_pClientList[iH] == 0) {
			return;
		}
		if (_stricmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
			return;
		}
		if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
			return;
		}
		if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (_stricmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
			return;
		}

		SendNotifyMsg(0, iH, DEF_NOTIFY_PARTY, 7, 0, 0, 0);
		//testcode
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Party join reject(3) ClientH:%d ID:%d", iH, m_pClientList[iH]->m_iPartyID);
		PutLogList(G_cTxt);

		m_pClientList[iH]->m_iPartyID = 0;
		m_pClientList[iH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iH]->m_iReqJoinPartyClientH = 0;
		std::memset(m_pClientList[iH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
		std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1:
		if ((m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && (m_pClientList[iClientH]->m_iPartyID != 0)) {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == 0) {
				return;
			}
			if (_stricmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (_stricmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				return;
			}

			std::memset(cData, 0, sizeof(cData));
			cp = (char*)cData;
			/*dwp = (uint32_t *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;*/
			wp = (uint16_t*)cp;
			*wp = 3;
			cp += 2;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (uint16_t*)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			PartyOperation(cData);;
		}
		else {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == 0) {
				return;
			}
			if (_stricmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (_stricmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				return;
			}

			if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL) {
				RequestCreatePartyHandler(iClientH);
			}
			else {
			}
		}
		break;

	case 2:
		if ((m_pClientList[iClientH]->m_iPartyID != 0) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			RequestDismissPartyHandler(iClientH);
		}
		else {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;

			// NULL  .
			if ((m_pClientList[iH] != 0) && (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) &&
				(_stricmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) == 0)) {
				m_pClientList[iH]->m_iReqJoinPartyClientH = 0;
				std::memset(m_pClientList[iH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
			}

			m_pClientList[iClientH]->m_iPartyID = 0;
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = 0;
			std::memset(m_pClientList[iClientH]->m_cReqJoinPartyName, 0, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

void CGame::PartyOperation(char* pData)
{
	char* cp, cName[12], cData[120];
	uint16_t* wp, wRequestType;
	int iGSCH, iPartyID;
	int bRet;

	cp = (char*)pData;

	wp = (uint16_t*)cp;
	wRequestType = *wp;
	cp += 2;

	wp = (uint16_t*)cp;
	iGSCH = (uint16_t)*wp;
	cp += 2;

	std::memset(cName, 0, sizeof(cName));
	memcpy(cName, cp, DEF_CHARNAME - 1);
	cp += 10;

	wp = (uint16_t*)cp;
	iPartyID = (uint16_t)*wp;
	cp += 2;

	//testcode
	std::snprintf(G_cTxt, sizeof(G_cTxt), "Party Operation Type: %d Name: %s PartyID:%d", wRequestType, cName, iPartyID);
	PutLogList(G_cTxt);

	cp = (char*)cData;
	wp = (uint16_t*)cp;

	switch (wRequestType) {
	case 1:
		iPartyID = m_pPartyManager->iCreateNewParty(cName);

		*wp = 1;
		cp += 2;
		*cp = (int)!(iPartyID == 0);
		cp++;
		wp = (uint16_t*)cp;
		*wp = iGSCH;
		cp += 2;
		memcpy(cp, cName, 10);
		cp += 10;
		wp = (uint16_t*)cp;
		*wp = (uint16_t)iPartyID;
		cp += 2;

		PartyOperationResultHandler(cData);
		break;

	case 2:
		break;

	case 3:
		bRet = m_pPartyManager->bAddMember(iPartyID, cName);

		*wp = 4;
		cp += 2;
		*cp = (int)bRet;
		cp++;
		wp = (uint16_t*)cp;
		*wp = iGSCH;
		cp += 2;
		memcpy(cp, cName, 10);
		cp += 10;
		wp = (uint16_t*)cp;
		*wp = (uint16_t)iPartyID;
		cp += 2;

		PartyOperationResultHandler(cData);
		break;

	case 4:
		bRet = m_pPartyManager->bRemoveMember(iPartyID, cName);

		*wp = 6;
		cp += 2;
		*cp = (int)bRet;
		cp++;
		wp = (uint16_t*)cp;
		*wp = iGSCH;
		cp += 2;
		memcpy(cp, cName, 10);
		cp += 10;
		wp = (uint16_t*)cp;
		*wp = (uint16_t)iPartyID;
		cp += 2;

		PartyOperationResultHandler(cData);
		break;

	case 5:
		m_pPartyManager->bCheckPartyMember(iGSCH, iPartyID, cName);
		break;

	case 6:
		m_pPartyManager->bGetPartyInfo(iGSCH, cName, iPartyID);
		break;

	case 7:
		m_pPartyManager->SetServerChangeStatus(cName, iPartyID);
		break;
	}
}

void CGame::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{
	int iItemX, iItemY, iSoM, iSoX, iSomH, iSoxH, iValue; // v2.172
	uint32_t dwTemp, dwSWEType;
	double dV1, dV2, dV3;
	short sItemUpgrade = 2;

	//hbest
	int bugint = 0;

	if (m_pClientList[iClientH] == 0) return;
	if ((iItemIndex < 0) || (iItemIndex >= hb::limits::MaxItems)) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == 0) return;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
	if (iValue >= 15 || iValue < 0) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, 0, 0, 0);
		return;
	}

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
	case 46: // Pendants are category 46
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->GetItemType() != ItemType::Equip)
		{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are type Equip
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cEquipPos < 11)
		{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are left finger or more
		}
		if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->GetItemEffectType() != ItemEffectType::AddEffect)
		{
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are EffectType AddEffect
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectValue1) {
		default: // Other items are not upgradable
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return; // Pendants are EffectType 14

		case 16: // AngelicPandent(STR)
		case 17: // AngelicPandent(DEX)
		case 18: // AngelicPandent(INT)
		case 19: // AngelicPandent(MAG)
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}
			if (iValue >= 10)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}
			switch (iValue) {
			case 0:	sItemUpgrade = 10; break;
			case 1: sItemUpgrade = 11; break;
			case 2: sItemUpgrade = 13; break;
			case 3: sItemUpgrade = 16; break;
			case 4: sItemUpgrade = 20; break;
			case 5: sItemUpgrade = 25; break;
			case 6: sItemUpgrade = 31; break;
			case 7: sItemUpgrade = 38; break;
			case 8: sItemUpgrade = 46; break;
			case 9: sItemUpgrade = 55; break;
			default:
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
				break;
			}
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1)
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2)
				|| (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
				return;
			}
			if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}
			int iDicePTA = iDice(1, 100);
			if (iDicePTA <= 70)
			{
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);
				iValue++;
				if (iValue > 10) iValue = 10;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
			else
			{
				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
			}
			return;
			break;
		}
		break;

	case 1: // weapons upgrade
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 703:
		case 709: // DarkKnightFlameberge 
		case 718: // DarkKnightGreatSword
		case 727: // DarkKnightFlamebergW
		case 736:
		case 737: // DarkKnightAxe
		case 745: // DarkKnightHammer
			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}

			sItemUpgrade = (iValue * (iValue + 6) / 8) + 2;

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				if (iValue != 0) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
					return;
				}
			}

			if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

			if ((iValue == 0) && m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 703)
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 709) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->SetTouchEffectType(TouchEffectType::UniqueOwner);
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;

			}
			else if ((iValue == 0) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709)))
			{

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 709) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->SetTouchEffectType(TouchEffectType::UniqueOwner);
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONEITEMCHANGE, iItemIndex,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum);

				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}
			else if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 745))
			{

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 745) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->SetTouchEffectType(TouchEffectType::UniqueOwner);
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONEITEMCHANGE, iItemIndex,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum);

				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}
			else if ((iValue == 0) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 737))
			{

				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 737) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->SetTouchEffectType(TouchEffectType::UniqueOwner);
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONEITEMCHANGE, iItemIndex,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum);

				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}
			else
			{
				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
			}
			break;

		default:

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
				dwSWEType = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
				if (dwSWEType == 9) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
					return;
				}
			}
			iSoX = iSoM = 0;
			for(int i = 0; i < hb::limits::MaxItems; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break;
					}
				}
			if (iSoX > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false);
					ItemDepleteHandler(iClientH, iSoxH, false);
					return;
				}

				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) {
					iValue++;
					if (iValue > 10)
						iValue = 10;
					else {
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
						ItemDepleteHandler(iClientH, iSoxH, false);
					}
				}
				else {
					iValue++;
					if (iValue > 7)
						iValue = 7;
					else {
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
						ItemDepleteHandler(iClientH, iSoxH, false);
					}
				}
			}

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
			break;
		}
		break;

	case 3:
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
		break;

	case 5:
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
			dwSWEType = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
			if (dwSWEType == 8) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
				return;
			}
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 620:
		case 623:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return;
		default: break;
		}


		iSoX = iSoM = 0;
		for(int i = 0; i < hb::limits::MaxItems; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
				case 656: iSoX++; iSoxH = i; break;
				case 657: iSoM++; iSomH = i; break;
				}
			}

		if (iSoM > 0) {
			if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, true) == false) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
				iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
				if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false);
				ItemDepleteHandler(iClientH, iSomH, false);
				return;
			}

			iValue++;
			if (iValue > 10)
				iValue = 10;
			else {
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) {
					// +20%
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.2f * dV1;
					dV3 = dV1 + dV2;
				}
				else {
					// +15%
					dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
					dV2 = 0.15f * dV1;
					dV3 = dV1 + dV2;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0)
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
				ItemDepleteHandler(iClientH, iSomH, false);
			}
		}
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, 0, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
		break;

	case 6: // armors upgrade
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 621:
		case 622:

		case 700:
		case 701:
		case 702:
		case 704:
		case 706:
		case 707:
		case 708:
		case 710:
		case 711:
		case 712:
		case 713:
		case 724:
		case 725:
		case 726:
		case 728:
		case 729:
		case 730:
		case 731:
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
			return;

		default:
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != 0) {
				dwSWEType = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;
				if (dwSWEType == 8) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
					return;
				}
			}
			iSoX = iSoM = 0;
			for(int i = 0; i < hb::limits::MaxItems; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break;
					}
				}
			if (iSoM > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, true) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false);
					ItemDepleteHandler(iClientH, iSomH, false);
					return;
				}
				iValue++;
				if (iValue > 10)
					iValue = 10;
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != 0) {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.2f * dV1;
						dV3 = dV1 + dV2;
					}
					else {
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.15f * dV1;
						dV3 = dV1 + dV2;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0)
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					ItemDepleteHandler(iClientH, iSomH, false);
				}
			}
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, 0, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;
		}
		break;

	case 8: // wands upgrade 
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 291: // MagicWand(LLF)

		case 714:
		case 732:
		case 738:
		case 746:

			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				if (iValue != 0) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
					return;
				}
			}

			if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}
			sItemUpgrade = (iValue * (iValue + 6) / 8) + 2;

			if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade) < 0)
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}

			m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);

			if (iValue == 0) {
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->SetTouchEffectType(TouchEffectType::UniqueOwner);
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
			}

			if ((iValue == 11) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 714) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 738)))
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 738) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->SetTouchEffectType(TouchEffectType::UniqueOwner);
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;


			}
			else if ((iValue == 15) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 738))
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 746) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->SetTouchEffectType(TouchEffectType::UniqueOwner);
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;


			}
			else if ((iValue == 15) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 746))
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 892) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					return;
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->SetTouchEffectType(TouchEffectType::UniqueOwner);
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;


			}
			else
			{
				iValue += 1;
				if (iValue > 15) iValue = 15;
				dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
				dwTemp = dwTemp & 0x0FFFFFFF;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;
			}

		default:
			iSoX = iSoM = 0;
			for(int i = 0; i < hb::limits::MaxItems; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break;
					}
				}
			if (iSoX > 0) {
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == false) {
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, false);
					ItemDepleteHandler(iClientH, iSoxH, false);
					return;
				}

				iValue++;
				if (iValue > 7)
					iValue = 7;
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28);
					ItemDepleteHandler(iClientH, iSoxH, false);
				}
			}

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);

			break;
		}
		break;

		//hbest hero cape upgrade
	case 13:
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 400:
		case 401:
			iSoX = iSoM = 0;
			for(int i = 0; i < hb::limits::MaxItems; i++)
				if (m_pClientList[iClientH]->m_pItemList[i] != 0) {
					switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break;
					case 657: iSoM++; iSomH = i; break;
					}
				}

			if (iSoM < 1) {
				return;
			}

			bugint = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum;
			if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
				(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, 0, 0, 0);
				return;
			}

			if ((m_pClientList[iClientH]->m_iContribution < 50) || (m_pClientList[iClientH]->m_iEnemyKillCount < 50))
			{
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, 0, 0, 0);
				return;
			}

			m_pClientList[iClientH]->m_iContribution -= 50;
			m_pClientList[iClientH]->m_iEnemyKillCount -= 50;
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, 0, 0, 0);

			if (iValue == 0)
			{
				iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x;
				iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y;

				delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = 0;

				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new CItem;

				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX;
				m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY;

				if (bugint == 400) {
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 427) == false) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
						return;
					}
				}
				else {
					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], 428) == false) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
						return;
					}
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->SetTouchEffectType(TouchEffectType::UniqueOwner);
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

				ItemDepleteHandler(iClientH, iSomH, false);

				SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONEITEMCHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute,
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum);
				_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int)-1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
				break;


			}

		default: break;
		}
		break;

	default:
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, 0, 0);
		break;
	}
}

void CGame::TimeHitPointsUp(int iClientH)
{
	int iMaxHP, iTemp, iTotal;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;

	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;

	if (m_pClientList[iClientH]->m_bIsKilled) return;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19]) return;

	iMaxHP = iGetMaxHP(iClientH);

	if (m_pClientList[iClientH]->m_iHP < iMaxHP) {

		iTemp = iDice(1, (m_pClientList[iClientH]->m_iVit));

		if (iTemp < (m_pClientList[iClientH]->m_iVit / 2)) iTemp = (m_pClientList[iClientH]->m_iVit / 2);

		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)

			iTemp -= (iTemp / m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;

		if (m_pClientList[iClientH]->m_iAddHP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f) * dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iHP += iTotal;

		if (m_pClientList[iClientH]->m_iHP > iMaxHP) m_pClientList[iClientH]->m_iHP = iMaxHP;

		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_HP, 0, 0, 0, 0);
	}
	m_pClientList[iClientH]->m_iHPstock = 0;
}

char CGame::_cCheckHeroItemEquipped(int iClientH)
{
	short sHeroLeggings, sHeroHauberk, sHeroArmor, sHeroHelm;

	if (m_pClientList[iClientH] == 0) return 0;

	sHeroHelm = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Head)];
	sHeroArmor = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Body)];
	sHeroHauberk = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Arms)];
	sHeroLeggings = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::Pants)];

	if ((sHeroHelm < 0) || (sHeroLeggings < 0) || (sHeroArmor < 0) || (sHeroHauberk < 0)) return 0;

	if (m_pClientList[iClientH]->m_pItemList[sHeroHelm] == 0) return 0;
	if (m_pClientList[iClientH]->m_pItemList[sHeroLeggings] == 0) return 0;
	if (m_pClientList[iClientH]->m_pItemList[sHeroArmor] == 0) return 0;
	if (m_pClientList[iClientH]->m_pItemList[sHeroHauberk] == 0) return 0;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 403) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 411) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 407) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 415) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 404) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 412) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 408) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 416) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 405) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 413) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 409) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 417) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 406) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 414) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 410) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 418) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 2;

	return 0;
}

bool CGame::bPlantSeedBag(int iMapIndex, int dX, int dY, int iItemEffectValue1, int iItemEffectValue2, int iClientH)
{
	int iNamingValue, tX, tY;
	short sOwnerH;
	char cOwnerType, cNpcName[DEF_NPCNAME], cName[DEF_NPCNAME], cNpcWaypointIndex[11];
	int bRet;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= 200) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_NOMOREAGRICULTURE, 0, 0, 0, 0);
		return false;
	}

	if (iItemEffectValue2 > m_pClientList[iClientH]->m_cSkillMastery[2]) {
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_AGRICULTURESKILLLIMIT, 0, 0, 0, 0);
		return false;
	}

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();

	if (iNamingValue == -1) {
	}
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if (sOwnerH != 0 && sOwnerH == DEF_OWNERTYPE_NPC && m_pNpcList[sOwnerH]->m_cActionLimit == 5) {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, 0, 0, 0, 0);
			return false;
		}
		else {
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX, dY) == false) {
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, 0, 0, 0, 0);
				return false;
			}

			std::memset(cNpcName, 0, sizeof(cNpcName));
			strcpy(cNpcName, "Crops");
			std::memset(cName, 0, sizeof(cName));
			std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = iMapIndex + 65;

			std::memset(cNpcWaypointIndex, 0, sizeof(cNpcWaypointIndex));
			tX = dX;
			tY = dY;

			bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypointIndex, 0, 0, 0, false, true);
			if (bRet == false) {
				m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (m_pNpcList[sOwnerH] == 0) return 0;
				m_pNpcList[sOwnerH]->m_cCropType = iItemEffectValue1;
				switch (iItemEffectValue1) {
				case 1: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 2: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 3: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 4: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 5: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 6: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 7: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 8: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 9: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 10: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 11: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 12: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				case 13: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
				default: m_pNpcList[sOwnerH]->m_cCropSkill = 100; break;
				}
				m_pNpcList[sOwnerH]->m_appearance.iSpecialFrame = 1;
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, 0, 0, 0);
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(skill:%d type:%d)plant(%s) Agriculture begin(%d,%d) sum(%d)!", m_pNpcList[sOwnerH]->m_cCropSkill, m_pNpcList[sOwnerH]->m_cCropType, cNpcName, tX, tY, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
				PutLogList(G_cTxt);
				return true;
			}
		}
	}
	return false;
}

void CGame::_CheckFarmingAction(short sAttackerH, short sTargetH, bool bType)
{
	char cCropType;
	int iItemID;
	CItem* pItem;

	iItemID = 0;
	cCropType = 0;

	cCropType = m_pNpcList[sTargetH]->m_cCropType;
	switch (cCropType) {
	case 1: GetExp(sAttackerH, iDice(3, 10)); iItemID = 820; break; // WaterMelon
	case 2: GetExp(sAttackerH, iDice(3, 10)); iItemID = 821; break; // Pumpkin
	case 3: GetExp(sAttackerH, iDice(4, 10)); iItemID = 822; break; // Garlic
	case 4: GetExp(sAttackerH, iDice(4, 10)); iItemID = 823; break; // Barley
	case 5: GetExp(sAttackerH, iDice(5, 10)); iItemID = 824; break; // Carrot
	case 6: GetExp(sAttackerH, iDice(5, 10)); iItemID = 825; break; // Radish
	case 7: GetExp(sAttackerH, iDice(6, 10)); iItemID = 826; break; // Corn
	case 8: GetExp(sAttackerH, iDice(6, 10)); iItemID = 827; break; // ChineseBellflower
	case 9: GetExp(sAttackerH, iDice(7, 10)); iItemID = 828; break; // Melone
	case 10: GetExp(sAttackerH, iDice(7, 10)); iItemID = 829; break; // Tommato
	case 11: GetExp(sAttackerH, iDice(8, 10)); iItemID = 830; break; // Grapes
	case 12: GetExp(sAttackerH, iDice(8, 10)); iItemID = 831; break; // BlueGrapes
	case 13: GetExp(sAttackerH, iDice(9, 10)); iItemID = 832; break; // Mushroom
	default: GetExp(sAttackerH, iDice(10, 10)); iItemID = 721; break; // Ginseng

	}

	pItem = new CItem;
	if (_bInitItemAttr(pItem, iItemID) == false) {
		delete pItem;
	}
	if (bType == 0) {
		m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->bSetItem(m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[sAttackerH]->m_cMapIndex,
			m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, pItem->m_sIDnum, 0,
			pItem->m_cItemColor, pItem->m_dwAttribute);
	}
	else if (bType == 1) {
		m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bSetItem(m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[sTargetH]->m_cMapIndex,
			m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, pItem->m_sIDnum, 0,
			pItem->m_cItemColor, pItem->m_dwAttribute);
	}

}

/*void CGame::CalculateEnduranceDecrement(short sTargetH, short sAttackerH, char cTargetType, int iArmorType)
{
 short sItemIndex;
 int iDownValue = 1, iHammerChance = 100;

	if (m_pClientList[sTargetH] == 0) return;

	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0 )) {
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)) {
			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
				case 14:
					if ((31 == m_pClientList[sAttackerH]->m_appearance.iWeaponType) || (32 == m_pClientList[sAttackerH]->m_appearance.iWeaponType)) {
						sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
						if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 761) { // BattleHammer
								iDownValue = 30;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
								iDownValue = 35;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 843) { // BarbarianHammer
								iDownValue = 30;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 745) { // BarbarianHammer
								iDownValue = 30;
								break;
							}
						}
					}
					else {
						iDownValue = 20; break;
					}
				case 10: iDownValue = 3; break;
				default: iDownValue = 1; break;
				}

				if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled ) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType)
						case 52: iDownValue = 0; iHammerChance = 0;
				}
			}
		}

		if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 0)) {
				m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan -= iDownValue;
		}

		if ((m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan <= 0) || (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 64000)) {
			m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan = 0;
			SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
			ReleaseItemHandler(sTargetH, iArmorType, true);
			return;
		}

	/*try
	{
		if (m_pClientList[sAttackerH] != 0) {
			if (cTargetType == DEF_OWNERTYPE_PLAYER) {
				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
					if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 617) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 618) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 619) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 873) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 874) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 75) || (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 76)) {
						m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 6;
						return;
					}
				}
			}
		}*/

		/*if (m_pClientList[sAttackerH] != 0) {
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		if ((m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14) && (iHammerChance == 100)) {
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan < 2000) {
				iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
			}
			else {
				iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
			}

			if ((31 == m_pClientList[sAttackerH]->m_appearance.iWeaponType) || (32 == m_pClientList[sAttackerH]->m_appearance.iWeaponType)) {
				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 761) { // BattleHammer
						iHammerChance = iHammerChance/2;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*10)/9);
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 843) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*10)/9);
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 745) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*10)/9);
					}
				}
			}
			if ((m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum == 622) || (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum == 621)) {
				iHammerChance = 0;
			}
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan < iHammerChance) {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "(iHammerChance (%d), target armor endurance (%d)!", iHammerChance, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan);
				PutLogList(G_cTxt);
				ReleaseItemHandler(sTargetH, iArmorType, true);
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
				return;
			}
		}
		}
		}
	//catch(...)
	{

	}
}*/

bool CGame::bCalculateEnduranceDecrement(short sTargetH, short sAttackerH, char cTargetType, int iArmorType)
{
	int iDownValue = 1, iHammerChance = 100, iItemIndex;
	uint16_t wWeaponType;

	if (m_pClientList[sTargetH] == 0) return false;
	if (sAttackerH > DEF_MAXCLIENTS) return false;
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] == 0)) return false;
	wWeaponType = m_pClientList[sAttackerH]->m_appearance.iWeaponType;		// sAttackerH was 2536 == null
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)) {
		switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
		case 14:
			if ((wWeaponType == 31) || (wWeaponType == 32)) {
				iItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
				if ((iItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[iItemIndex] != 0)) {
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 761) { // BattleHammer 
						iDownValue = 30;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
						iDownValue = 35;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 843) { // BarbarianHammer
						iDownValue = 30;
					}
					if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 745) { // MasterBattleHammer
						iDownValue = 30;
					}
					break;
				}
			}
			else {
				iDownValue = 20;
			}
			break;
		case 10:
			iDownValue = 3;
			break;
		default:
			iDownValue = 1;
			break;
		}
	}
	if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled) {
		switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
		case 52:
			iDownValue = 0;
			iHammerChance = 0;
			break;
		}
	}
	if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 0)) {
		m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan -= iDownValue;
		SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iArmorType, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan, 0, 0);
	}
	if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan <= 0) {
		m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan = 0;
		SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
		ReleaseItemHandler(sTargetH, iArmorType, true);
		return true;
	}
	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14) && (iHammerChance == 100)) {
		if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan < 2000) {
			iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
		}
		else {
			iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
		}
		if ((wWeaponType == 31) || (wWeaponType == 32)) {
			iItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
			if ((iItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[iItemIndex] != 0)) {
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 761) { // BattleHammer 
					iHammerChance -= iHammerChance >> 1;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
					iHammerChance = (((iHammerChance * 5) + 7) >> 3);
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 843) { // BarbarianHammer
					iHammerChance = (((iHammerChance * 5) + 7) >> 3);
				}
				if (m_pClientList[sAttackerH]->m_pItemList[iItemIndex]->m_sIDnum == 745) { // MasterBattleHammer
					iHammerChance = (((iHammerChance * 5) + 7) >> 3);
				}
			}
			else {
				iHammerChance = ((iHammerChance + 3) >> 2);
			}
			switch (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum) {
			case 621:
			case 622:
				iHammerChance = 0;
				break;
			}
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan < iHammerChance) {
				ReleaseItemHandler(sTargetH, iArmorType, true);
				SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, 0, 0);
			}
		}
	}
	return true;
}

uint32_t CGame::iCalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType, int tdX, int tdY, int iAttackMode, bool bNearAttack, bool bIsDash, bool bArrowUse)
{
	int    iAP_SM, iAP_L, iAttackerHitRatio, iTargetDefenseRatio, iDestHitRatio, iResult, iAP_Abs_Armor, iAP_Abs_Shield;
	char   cAttackerName[DEF_NPCNAME], cAttackerDir, cAttackerSide, cTargetDir, cProtect, cCropSkill, cFarmingSkill;
	short  sWeaponIndex, sAttackerWeapon, dX, dY, sX, sY, sAtkX, sAtkY, sTgtX, sTgtY;
	uint32_t  dwTime;
	uint16_t   wWeaponType;
	double dTmp1, dTmp2, dTmp3;
	bool   bKilled;
	bool   bNormalMissileAttack;
	bool   bIsAttackerBerserk;
	int    iKilledDice, iDamage, iExp, iWepLifeOff, iSideCondition, iMaxSuperAttack, iWeaponSkill, iComboBonus, iTemp;
	int    iAttackerHP, iMoveDamage, iRepDamage;
	char   cAttackerSA;
	int    iAttackerSAvalue, iHitPoint;
	char   cDamageMoveDir;
	int    iPartyID, iConstructionPoint, iWarContribution, tX, tY, iDst1, iDst2;
	short sItemIndex;
	short sSkillUsed;

	dwTime = GameClock::GetTimeMS();
	bKilled = false;
	iExp = 0;
	iPartyID = 0;
	bNormalMissileAttack = false;
	std::memset(cAttackerName, 0, sizeof(cAttackerName));
	cAttackerSA = 0;
	iAttackerSAvalue = 0;
	wWeaponType = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sAttackerH] == 0) return 0;
		if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == false)) return 0;
		if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] == 0) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap) && (m_bIsHeldenianMode)) return 0;
		if ((m_bIsCrusadeMode == false) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return 0;

		if (m_pClientList[sAttackerH]->m_status.bInvisibility) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_PLAYER, false);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_PLAYER, hb::magic::Invisibility);
			m_pClientList[sAttackerH]->m_cMagicEffectStatus[hb::magic::Invisibility] = 0;
		}

		if (!m_pClientList[sAttackerH]->m_appearance.bIsWalking) return 0;

		iAP_SM = 0;
		iAP_L = 0;

		wWeaponType = m_pClientList[sAttackerH]->m_appearance.iWeaponType;

		sSkillUsed = m_pClientList[sAttackerH]->m_sUsingWeaponSkill;
		if ((bIsDash) && (m_pClientList[sAttackerH]->m_cSkillMastery[sSkillUsed] != 100) && (wWeaponType != 25) && (wWeaponType != 27)) {
			try
			{
				std::snprintf(G_cTxt, sizeof(G_cTxt), "TSearch Fullswing Hack: (%s) Player: (%s) - dashing with only (%d) weapon skill.", m_pClientList[sAttackerH]->m_cIPaddress, m_pClientList[sAttackerH]->m_cCharName, m_pClientList[sAttackerH]->m_cSkillMastery[sSkillUsed]);
				PutHackLogFileList(G_cTxt);
				DeleteClient(sAttackerH, true, true);
			}
			catch (...)
			{

			}
			return 0;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;

		if (wWeaponType == 0) {
			iAP_SM = iAP_L = iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 12));
			if (iAP_SM <= 0) iAP_SM = 1;
			if (iAP_L <= 0) iAP_L = 1;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[5];
			m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 5;

		}
		else if ((wWeaponType >= 1) && (wWeaponType < 40)) {
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;

			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 + 0.5f);

			dTmp1 = (double)iAP_L;
			dTmp2 = (double)(m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr);

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 + 0.5f);
		}
		else if (wWeaponType >= 40) {
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
			bNormalMissileAttack = true;

			iAP_SM += iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 20));
			iAP_L += iDice(1, ((m_pClientList[sAttackerH]->m_iStr + m_pClientList[sAttackerH]->m_iAngelicStr) / 20));
		}

		iAttackerHitRatio += 50;
		if (iAP_SM <= 0) iAP_SM = 1;
		if (iAP_L <= 0) iAP_L = 1;

		if (m_pClientList[sAttackerH]->m_iCustomItemValue_Attack != 0) {
			if ((m_pClientList[sAttackerH]->m_iMinAP_SM != 0) && (iAP_SM < m_pClientList[sAttackerH]->m_iMinAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMinAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMinAP_L != 0) && (iAP_L < m_pClientList[sAttackerH]->m_iMinAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMinAP_L;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_SM != 0) && (iAP_SM > m_pClientList[sAttackerH]->m_iMaxAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMaxAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_L != 0) && (iAP_L > m_pClientList[sAttackerH]->m_iMaxAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMaxAP_L;
			}
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 1) {
			iAttackerHitRatio += 100;
			iAP_SM += 5;
			iAP_L += 5;
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 851) || // KlonessEsterk 
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863) || // KlonessWand(MS.20)
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864)) { // KlonessWand(MS.10) 
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating / 100;
					if (iRepDamage < 5) iRepDamage = 5;
					if (iRepDamage > 15) iRepDamage = 15;
					iAP_SM += iRepDamage;
					iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == 0) return 0;
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 10);
						if (iRepDamage > 10) iRepDamage = 10;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 732) || // BerserkWand(MS.20)
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 738)) { // BerserkWand(MS.10)
				iAP_SM += 1;
				iAP_L += 1;
			}
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 847) &&
				(m_cDayOrNight == 2)) {
				iAP_SM += 4;
				iAP_L += 4;
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 848) &&
				(m_cDayOrNight == 1)) {
				iAP_SM += 4;
				iAP_L += 4;
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 849) || // KlonessBlade 
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 850)) { // KlonessAxe
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating / 100;
					if (iRepDamage < 5) iRepDamage = 5;
					if (iRepDamage > 15) iRepDamage = 15;
					iAP_SM += iRepDamage;
					iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == 0) return 0;
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 10);
						if (iRepDamage > 10) iRepDamage = 10;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::Neck)];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != 0)) {
			if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == 0) return 0;
					iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating) / 20);
					if (iRepDamage > 5) iRepDamage = 5;
					iAP_SM += iRepDamage;
					iAP_L += iRepDamage;
				}
			}
		}

		cAttackerDir = m_pClientList[sAttackerH]->m_cDir;
		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);

		if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[hb::magic::Berserk] != 0)
			bIsAttackerBerserk = true;
		else bIsAttackerBerserk = false;

		if ((bArrowUse != true) && (m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {

			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 + 0.5f);
			iAP_SM += iTemp;

			dTmp1 = (double)iAP_L;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 + 0.5f);
			iAP_L += iTemp;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
			case 5:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); iAttackerHitRatio += 20; break; // Boxing
			case 6:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); iAttackerHitRatio += 30; break; // Bow
			case 7:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); iAttackerHitRatio += 40; break; // Dagger/SS
			case 8:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); iAttackerHitRatio += 30; break; // Long Sword
			case 9:  iAP_SM += (iAP_SM / 7);  iAP_L += (iAP_L / 7);  iAttackerHitRatio += 30; break; // Fencing
			case 10: iAP_SM += (iAP_SM / 5);  iAP_L += (iAP_L / 5);                           break; // Axe
			case 14: iAP_SM += (iAP_SM / 5);  iAP_L += (iAP_L / 5);  iAttackerHitRatio += 20; break; // Hammer
			case 21: iAP_SM += (iAP_SM / 5);  iAP_L += (iAP_L / 5);  iAttackerHitRatio += 50; break; // Wand
			default: break;
			}
			iAttackerHitRatio += 100;
			iAttackerHitRatio += m_pClientList[sAttackerH]->m_iCustomItemValue_Attack;
		}

		if (bIsDash) {

			iAttackerHitRatio += 20;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
			case 8:  iAP_SM += (iAP_SM / 10); iAP_L += (iAP_L / 10); break;
			case 10: iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5); break;
			case 14: iAP_SM += (iAP_SM / 5); iAP_L += (iAP_L / 5); break;
			default: break;
			}
		}

		iAttackerHP = m_pClientList[sAttackerH]->m_iHP;
		iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR;

		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:

		if (m_pNpcList[sAttackerH] == 0) return 0;
		if (m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == false) return 0;

		if (m_pNpcList[sAttackerH]->m_status.bInvisibility) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_NPC, false);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_NPC, hb::magic::Invisibility);
			m_pNpcList[sAttackerH]->m_cMagicEffectStatus[hb::magic::Invisibility] = 0;
		}

		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		iAP_SM = 0;
		iAP_L = 0;

		if (m_pNpcList[sAttackerH]->m_cAttackDiceThrow >= 0)
		{
			iAP_L = iAP_SM = iDice(
				static_cast<uint32_t>(m_pNpcList[sAttackerH]->m_cAttackDiceThrow),
				static_cast<uint32_t>(m_pNpcList[sAttackerH]->m_cAttackDiceRange)
			);
		}

		iAttackerHitRatio = m_pNpcList[sAttackerH]->m_iHitRatio;

		cAttackerDir = m_pNpcList[sAttackerH]->m_cDir;
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, DEF_NPCNAME - 1);

		if (m_pNpcList[sAttackerH]->m_cMagicEffectStatus[hb::magic::Berserk] != 0)
			bIsAttackerBerserk = true;
		else bIsAttackerBerserk = false;

		iAttackerHP = m_pNpcList[sAttackerH]->m_iHP;
		cAttackerSA = m_pNpcList[sAttackerH]->m_cSpecialAbility;

		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == 0) return 0;
		if (m_pClientList[sTargetH]->m_bIsKilled) return 0;

		// GM mode damage immunity
		if (m_pClientList[sTargetH]->m_bIsGMMode)
		{
			uint32_t dwNow = GameClock::GetTimeMS();
			if (dwNow - m_pClientList[sTargetH]->m_dwLastGMImmuneNotifyTime > 2000)
			{
				m_pClientList[sTargetH]->m_dwLastGMImmuneNotifyTime = dwNow;
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, DEF_DAMAGE_IMMUNE, 0, 0);
			}
			return 0;
		}

		if (m_pClientList[sTargetH]->m_status.bSlateInvincible) return 0;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == false) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil)) return 0;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral) &&
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation)) return 0;

		if ((m_pClientList[sTargetH]->m_sX != tdX) || (m_pClientList[sTargetH]->m_sY != tdY)) return 0;


		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral)
			&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;

		if ((m_pClientList[sTargetH]->m_iPartyID != 0) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return 0;

		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode)) {
			iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
			if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				iAP_SM = iAP_SM / 2;
				iAP_L = iAP_L / 2;
			}
			else {
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone) {
					if (m_pClientList[sAttackerH]->m_iGuildGUID == m_pClientList[sTargetH]->m_iGuildGUID) return 0;
					else {
						iAP_SM = iAP_SM / 2;
						iAP_L = iAP_L / 2;
					}
				}
				else return 0;
			}
		}

		iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;


		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:

		if (m_pNpcList[sTargetH] == 0) return 0;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return 0;

		if ((m_pNpcList[sTargetH]->m_sX != tdX) || (m_pNpcList[sTargetH]->m_sY != tdY)) return 0;

		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pNpcList[sTargetH]->m_iDefenseRatio;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
				break;
			}

			if ((wWeaponType == 25) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				if (m_pClientList[sAttackerH]->m_iCrusadeDuty != 2) break;

				switch (m_pNpcList[sTargetH]->m_sType) {
				case 36:
				case 37:
				case 38:
				case 39:
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:
						m_pNpcList[sTargetH]->m_appearance.iSpecialFrame = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						switch (m_pNpcList[sTargetH]->m_sType) {
						case 36: iConstructionPoint = 700; iWarContribution = 700; break;
						case 37: iConstructionPoint = 700; iWarContribution = 700; break;
						case 38: iConstructionPoint = 500; iWarContribution = 500; break;
						case 39: iConstructionPoint = 500; iWarContribution = 500; break;
						}

						m_pClientList[sAttackerH]->m_iWarContribution += iWarContribution;
						if (m_pClientList[sAttackerH]->m_iWarContribution > m_iMaxWarContribution)
							m_pClientList[sAttackerH]->m_iWarContribution = m_iMaxWarContribution;
						std::snprintf(G_cTxt, sizeof(G_cTxt), "Construction Complete! WarContribution: +%d", iWarContribution);
						PutLogList(G_cTxt);
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, 0, 0);
						break;
					case 5:
						m_pNpcList[sTargetH]->m_appearance.iSpecialFrame = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						break;
					case 10:
						m_pNpcList[sTargetH]->m_appearance.iSpecialFrame = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						break;
					}
					break;
				}

				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
			if ((wWeaponType == 27) && (m_pNpcList[sTargetH]->m_cCropType != 0) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				cFarmingSkill = m_pClientList[sAttackerH]->m_cSkillMastery[2];
				cCropSkill = m_pNpcList[sTargetH]->m_cCropSkill;
				if (cFarmingSkill < 20) return 0;
				if (m_pClientList[sAttackerH]->m_iLevel < 20) return 0;
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 64:
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:
						m_pNpcList[sTargetH]->m_appearance.iSpecialFrame = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						//sub_4B67E0
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 1);
						// Use EntityManager for NPC deletion
						if (m_pEntityManager != NULL)
							m_pEntityManager->DeleteEntity(sTargetH);
						return 0;
					case 8:
						m_pNpcList[sTargetH]->m_appearance.iSpecialFrame = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);
						break;
					case 18:
						m_pNpcList[sTargetH]->m_appearance.iSpecialFrame = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);
						break;

					}
					break;
				}
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
		}

		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		break;
	}

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (cTargetType == DEF_OWNERTYPE_PLAYER)) {

		sX = m_pClientList[sAttackerH]->m_sX;
		sY = m_pClientList[sAttackerH]->m_sY;

		dX = m_pClientList[sTargetH]->m_sX;
		dY = m_pClientList[sTargetH]->m_sY;

		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return 0;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) return 0;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if ((m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_iAngelicDex) > 50) {
			iAttackerHitRatio += ((m_pClientList[sAttackerH]->m_iDex + m_pClientList[sAttackerH]->m_iAngelicDex) - 50);
		}
	}

	if (wWeaponType >= 40) {
		switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
		case 0:	break;
		case 1:	iAttackerHitRatio -= (iAttackerHitRatio / 20); break;
		case 2:	iAttackerHitRatio -= (iAttackerHitRatio / 10); break;
		case 3:	iAttackerHitRatio -= (iAttackerHitRatio / 4);  break;
		}
	}

	if (iAttackerHitRatio < 0)   iAttackerHitRatio = 0;
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect];
		break;

	case DEF_OWNERTYPE_NPC:
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect];
		break;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] != -1) {
			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)]] == 0) {
				m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)]] = false;
				DeleteClient(sAttackerH, true, true);
				return 0;
			}

			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)]]->GetItemEffectType() == ItemEffectType::AttackArrow) {
				if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) {
					return 0;
				}
				else {
					if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex] == 0)
						return 0;

					if (bArrowUse != true)
						m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount--;
					if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount <= 0) {

						ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, false);
						m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH);
					}
					else {
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount, false, 0);
						iCalcTotalWeight(sAttackerH);
					}
				}
				if (cProtect == 1) return 0;
			}
			else {
				switch (cProtect) {
				case 3: iTargetDefenseRatio += 40;  break;
				case 4: iTargetDefenseRatio += 100; break;
				}
				if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
			}
		}
	}
	else {
		switch (cProtect) {
		case 1:
			switch (m_pNpcList[sAttackerH]->m_sType) {
			case 54:
				if ((abs(sTgtX - m_pNpcList[sAttackerH]->m_sX) >= 1) || (abs(sTgtY - m_pNpcList[sAttackerH]->m_sY) >= 1)) return 0;
			}
			break;
		case 3: iTargetDefenseRatio += 40;  break;
		case 4: iTargetDefenseRatio += 100; break;
		}
		if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
	}

	if (cAttackerDir == cTargetDir) iTargetDefenseRatio = iTargetDefenseRatio / 2;
	if (iTargetDefenseRatio < 1)   iTargetDefenseRatio = 1;

	dTmp1 = (double)(iAttackerHitRatio);
	dTmp2 = (double)(iTargetDefenseRatio);
	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3);

	if (iDestHitRatio < m_iMinimumHitRatio) iDestHitRatio = m_iMinimumHitRatio;
	if (iDestHitRatio > m_iMaximumHitRatio) iDestHitRatio = m_iMaximumHitRatio;

	if ((bIsAttackerBerserk) && (iAttackMode < 20)) {
		iAP_SM = iAP_SM * 2;
		iAP_L = iAP_L * 2;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
		iAP_L += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
	}

	if (bNearAttack) {
		iAP_SM = iAP_SM / 2;
		iAP_L = iAP_L / 2;
	}

	if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
		iAP_L -= (iDice(1, m_pClientList[sTargetH]->m_iVit / 10) - 1);
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (iAP_SM <= 1) iAP_SM = 1;
		if (iAP_L <= 1) iAP_L = 1;
	}
	else {
		if (iAP_SM <= 0) iAP_SM = 0;
		if (iAP_L <= 0) iAP_L = 0;
	}

	iResult = iDice(1, 100);

	if (iResult <= iDestHitRatio) {
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {

			if (((m_pClientList[sAttackerH]->m_iHungerStatus <= 10) || (m_pClientList[sAttackerH]->m_iSP <= 0)) && (iDice(1, 10) == 5)) return false;
			m_pClientList[sAttackerH]->m_iComboAttackCount++;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount < 0) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount > 4) m_pClientList[sAttackerH]->m_iComboAttackCount = 1;
			iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
			iComboBonus = iGetComboAttackBonus(iWeaponSkill, m_pClientList[sAttackerH]->m_iComboAttackCount);

			if ((m_pClientList[sAttackerH]->m_iComboAttackCount > 1) && (m_pClientList[sAttackerH]->m_iAddCD != 0))
				iComboBonus += m_pClientList[sAttackerH]->m_iAddCD;

			iAP_SM += iComboBonus;
			iAP_L += iComboBonus;

			switch (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectType) {
			case 0: break;
			case 1:
				if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
					iAP_SM += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
					iAP_L += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
				}
				break;

			case 2:
				cAttackerSA = 61;
				iAttackerSAvalue = m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue * 5;
				break;

			case 3:
				cAttackerSA = 62;
				break;
			}

			if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone) {
				iAP_SM += iAP_SM / 3;
				iAP_L += iAP_L / 3;
			}

			if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
				iAP_SM += iAP_SM / 3;
				iAP_L += iAP_L / 3;
			}

			if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
				if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
					iAP_SM += iAP_SM;
					iAP_L += iAP_L;
				}
				else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
					iAP_SM += (iAP_SM * 7) / 10;
					iAP_L += (iAP_L * 7) / 10;
				}
				else {
					iAP_SM += iAP_SM / 3;
					iAP_L += iAP_L / 3;
				}
			}
		}

		switch (cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			ClearSkillUsingStatus(sTargetH);
			if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > (uint32_t)m_iLagProtectionInterval) {
				return 0;
			}
			else {
				switch (cAttackerSA) {
				case 62:
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iTemp = abs(m_pClientList[sTargetH]->m_iRating) / 10;
						if (iTemp > 10) iTemp = 10;
						iAP_SM += iTemp;
					}
					break;
				}

				iAP_Abs_Armor = 0;
				iAP_Abs_Shield = 0;
				iTemp = iDice(1, 10000);
				if ((iTemp >= 1) && (iTemp < 5000))           iHitPoint = 1;
				else if ((iTemp >= 5000) && (iTemp < 7500))   iHitPoint = 2;
				else if ((iTemp >= 7500) && (iTemp < 9000))   iHitPoint = 3;
				else if ((iTemp >= 9000) && (iTemp <= 10000)) iHitPoint = 4;

				switch (iHitPoint) {
				case 1:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Body)] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Body)] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Body)];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;
						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				case 2:
					if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Pants)] +
						m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Leggings)]) > 0) {
						if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Pants)] +
							m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Leggings)]) >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)(m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Pants)] + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Leggings)]);
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 3:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Arms)] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Arms)] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Arms)];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 4:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Head)] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Head)] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[ToInt(EquipPos::Head)];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				}

				if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield > 0) {
					if (iDice(1, 100) <= (m_pClientList[sTargetH]->m_cSkillMastery[11])) {
						CalculateSSN_SkillIndex(sTargetH, 11, 1);
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Shield;
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Shield = (int)dTmp3;

						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::LeftHand)];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
							if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0)) {
								m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_CURLIFESPAN, iTemp, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan, 0, 0);
							}
							if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, 0, 0);
								ReleaseItemHandler(sTargetH, iTemp, true);
							}
						}
					}
				}

				iAP_SM = iAP_SM - (iAP_Abs_Armor + iAP_Abs_Shield);
				if (iAP_SM <= 0) iAP_SM = 1;

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0) && (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled)) {
					switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
					case 0: break;
					case 1:
						iTemp = (m_pClientList[sTargetH]->m_iHP / 2);
						if (iTemp > iAP_SM) iAP_SM = iTemp;
						if (iAP_SM <= 0) iAP_SM = 1;
						break;
					case 2:
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::Ice] == 0) {
							m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::Ice] = 1;
							SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, true);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Ice, dwTime + 30000,
								sTargetH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 1, 0, 0);
							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Ice, 1, 0, 0);
						}
						break;
					case 3:
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] == 0) {
							m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 2;
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::HoldObject, dwTime + 10000,
								sTargetH, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 10, 0, 0);
							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::HoldObject, 10, 0, 0);
						}
						break;
					case 4:
						iAP_SM = (m_pClientList[sTargetH]->m_iHP);
						break;
					case 5:
						m_pClientList[sAttackerH]->m_iHP += iAP_SM;
						if (iGetMaxHP(sAttackerH) < m_pClientList[sAttackerH]->m_iHP) m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH);
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_HP, 0, 0, 0, 0);
						break;
					}
				}

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled)) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
					case 50:
						if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] != -1)
							sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
						else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
						if (sWeaponIndex != -1)	m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						break;
					case 51:
						if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
							iAP_SM = 0;
						break;
					case 52:
						iAP_SM = 0;
						break;
					}
				}

				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect) &&
					(iDice(1, 10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iAP_SM)) {
					iAP_SM = m_pClientList[sTargetH]->m_iHP - 1;
				}

				switch (iHitPoint) {
				case 1:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::Body)];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;

				case 2:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::Pants)];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					else {
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::Leggings)];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
							bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
						}
					}
					break;

				case 3:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::Arms)];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;

				case 4:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[ToInt(EquipPos::Head)];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != 0)) {
						bCalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;
				}

				if ((cAttackerSA == 2) && (m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect] != 0)) {
					SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::Protect, m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect], 0, 0);
					switch (m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect]) {
					case 1:
						SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_PLAYER, false);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_PLAYER, false);
						break;
					case 3:
					case 4:
						SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_PLAYER, false);
						break;
					}
					m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, hb::magic::Protect);
				}

				if ((m_pClientList[sTargetH]->m_bIsPoisoned == false) &&
					((cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61))) {
					if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_PLAYER) == false) {
						m_pClientList[sTargetH]->m_bIsPoisoned = true;
						if (cAttackerSA == 5)		m_pClientList[sTargetH]->m_iPoisonLevel = 15;
						else if (cAttackerSA == 6)  m_pClientList[sTargetH]->m_iPoisonLevel = 40;
						else if (cAttackerSA == 61) m_pClientList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue;

						m_pClientList[sTargetH]->m_dwPoisonTime = dwTime;
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTON, hb::magic::Poison, m_pClientList[sTargetH]->m_iPoisonLevel, 0, 0);
						SetPoisonFlag(sTargetH, DEF_OWNERTYPE_PLAYER, true);
					}
				}

				m_pClientList[sTargetH]->m_iHP -= iAP_SM;
				// Interrupt spell casting on damage
				if (iAP_SM > 0) {
					m_pClientList[sTargetH]->m_dwLastDamageTakenTime = GameClock::GetTimeMS();
					if (m_pClientList[sTargetH]->m_bMagicPauseTime) {
						m_pClientList[sTargetH]->m_bMagicPauseTime = false;
						m_pClientList[sTargetH]->m_iSpellCount = -1;
						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SPELLINTERRUPTED, 0, 0, 0, 0);
					}
				}
				if (m_pClientList[sTargetH]->m_iHP <= 0) {
					if (cAttackerType == DEF_OWNERTYPE_PLAYER)
						bAnalyzeCriminalAction(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iAP_SM);
					bKilled = true;
					iKilledDice = m_pClientList[sTargetH]->m_iLevel;
				}
				else {
					if (iAP_SM > 0) {
						if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
							dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
							dTmp2 = (double)iAP_SM;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;
							iTemp = iGetMaxMP(sTargetH);
							m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
							if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
						}
						if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
							if (iDice(1, 100) <= static_cast<uint32_t>(m_pClientList[sTargetH]->m_iAddChargeCritical)) {
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
								SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
							}
						}

						SendNotifyMsg(0, sTargetH, DEF_NOTIFY_HP, 0, 0, 0, 0);

						if (cAttackerType == DEF_OWNERTYPE_PLAYER)
							sAttackerWeapon = m_pClientList[sAttackerH]->m_appearance.iWeaponType;
						else sAttackerWeapon = 1;

						if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone))
							iMoveDamage = 60;
						else iMoveDamage = 40;

						if (iAP_SM >= iMoveDamage) {
							if (sTgtX == sAtkX) {
								if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE;
								else if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}
							else if (sTgtX > sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 3;
								else if (sTgtY > sAtkY) cDamageMoveDir = 4;
								else if (sTgtY < sAtkY) cDamageMoveDir = 2;
							}
							else if (sTgtX < sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 7;
								else if (sTgtY > sAtkY) cDamageMoveDir = 6;
								else if (sTgtY < sAtkY) cDamageMoveDir = 8;
							}
							m_pClientList[sTargetH]->m_iLastDamage = iAP_SM;

							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iAP_SM, sAttackerWeapon, 0);
						}
						else {
						CAE_SKIPDAMAGEMOVE:
							int iProb;
							if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
								switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
								case 6: iProb = 3500; break;
								case 8: iProb = 1000; break;
								case 9: iProb = 2900; break;
								case 10: iProb = 2500; break;
								case 14: iProb = 2000; break;
								case 21: iProb = 2000; break;
								default: iProb = 1; break;
								}
							}
							else iProb = 1;

							if (iDice(1, 10000) >= static_cast<uint32_t>(iProb))
								SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, sAttackerWeapon, 0);
						}

						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] == 1) {
							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, hb::magic::HoldObject, m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject], 0, 0);
							m_pClientList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, hb::magic::HoldObject);
						}

						m_pClientList[sTargetH]->m_iSuperAttackCount++;
						if (m_pClientList[sTargetH]->m_iSuperAttackCount > 14) {
							m_pClientList[sTargetH]->m_iSuperAttackCount = 0;
							iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
							if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
							SendNotifyMsg(0, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, 0, 0, 0, 0);
						}
					}
				}
			}
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return 0;
			if (m_pNpcList[sTargetH]->m_bIsKilled) return 0;
			if (m_bIsCrusadeMode) {
				if (cAttackerSide == m_pNpcList[sTargetH]->m_cSide) {
					switch (m_pNpcList[sTargetH]->m_sType) {
					case 40:
					case 41:
					case 43:
					case 44:
					case 45:
					case 46:
					case 47:
					case 51:
						return 0;

					default: break;
					}
				}
				else {
					switch (m_pNpcList[sTargetH]->m_sType) {
					case 41:
						if (cAttackerSide != 0) {
							m_pNpcList[sTargetH]->m_iV1 += iAP_L;
							if (m_pNpcList[sTargetH]->m_iV1 > 500) {
								m_pNpcList[sTargetH]->m_iV1 = 0;
								m_pNpcList[sTargetH]->m_iManaStock--;
								if (m_pNpcList[sTargetH]->m_iManaStock <= 0) m_pNpcList[sTargetH]->m_iManaStock = 0;
								std::snprintf(G_cTxt, sizeof(G_cTxt), "ManaStock down: %d", m_pNpcList[sTargetH]->m_iManaStock);
								PutLogList(G_cTxt);
							}
						}
						break;
					}
				}
			}
			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 1:
			case 2:
				return 0;
			}

			if (m_pNpcList[sTargetH]->m_cSize == 0)
				iDamage = iAP_SM;
			else iDamage = iAP_L;

			if (m_pNpcList[sTargetH]->m_iAbsDamage < 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)(abs(m_pNpcList[sTargetH]->m_iAbsDamage)) / 100.0f;
				dTmp3 = dTmp1 * dTmp2;
				dTmp2 = dTmp1 - dTmp3;
				iDamage = (int)dTmp2;
				if (iDamage < 0) iDamage = 1;
				else if ((m_pNpcList[sTargetH]->m_sType == 31) && (cAttackerType == 1) && (m_pClientList[sAttackerH] != 0) && (m_pClientList[sAttackerH]->m_iSpecialAbilityType == 7))
					iDamage += iDice(3, 2);
			}


			if ((cAttackerSA == 2) && (m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect] != 0)) {
				switch (m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect]) {
				case 1:
					SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_NPC, false);
					break;
				case 2:
				case 5:
					SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_NPC, false);
					break;
				case 3:
				case 4:
					SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_NPC, false);
					break;
				}
				m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::Protect] = 0;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, hb::magic::Protect);
			}

			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 0:
			case 3:
			case 5:
				m_pNpcList[sTargetH]->m_iHP -= iDamage;
				break;
			}

			if (m_pNpcList[sTargetH]->m_iHP <= 0) {
				m_pEntityManager->OnEntityKilled(sTargetH, sAttackerH, cAttackerType, iDamage);
				bKilled = true;
				iKilledDice = m_pNpcList[sTargetH]->m_iHitDice;
			}
			else {
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) goto CAE_SKIPCOUNTERATTACK;

				if (m_pNpcList[sTargetH]->m_cActionLimit != 0) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_bIsPermAttackMode) goto CAE_SKIPCOUNTERATTACK;
				if ((m_pNpcList[sTargetH]->m_bIsSummoned) && (m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_sType == 51) goto CAE_SKIPCOUNTERATTACK;

				if (iDice(1, 3) == 2) {
					if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
						tX = tY = 0;
						switch (m_pNpcList[sTargetH]->m_cTargetType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex] != 0) {
								tX = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex] != 0) {
								tX = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;
						}

						iDst1 = (m_pNpcList[sTargetH]->m_sX - tX) * (m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY) * (m_pNpcList[sTargetH]->m_sY - tY);

						tX = tY = 0;
						switch (cAttackerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sAttackerH] != 0) {
								tX = m_pClientList[sAttackerH]->m_sX;
								tY = m_pClientList[sAttackerH]->m_sY;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sAttackerH] != 0) {
								tX = m_pNpcList[sAttackerH]->m_sX;
								tY = m_pNpcList[sAttackerH]->m_sY;
							}
							break;
						}

						iDst2 = (m_pNpcList[sTargetH]->m_sX - tX) * (m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY) * (m_pNpcList[sTargetH]->m_sY - tY);

						if (iDst2 <= iDst1) {
							m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
							m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
							m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;
						}
					}
					else {
						m_pNpcList[sTargetH]->m_cBehavior = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;
						m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
						m_pNpcList[sTargetH]->m_cTargetType = cAttackerType;
					}
				}

			CAE_SKIPCOUNTERATTACK:

				if ((iDice(1, 3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0))
					m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (cAttackerType == DEF_OWNERTYPE_PLAYER)
					sAttackerWeapon = m_pClientList[sAttackerH]->m_appearance.iWeaponType;
				else sAttackerWeapon = 1;

				if ((wWeaponType < 40) && (m_pNpcList[sTargetH]->m_cActionLimit == 4)) {
					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;
					}

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
						cDamageMoveDir = static_cast<char>(iDice(1, 8));
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) goto CAE_SKIPDAMAGEMOVE2;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX = dX;
					m_pNpcList[sTargetH]->m_sY = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) {
						cDamageMoveDir = static_cast<char>(iDice(1, 8));
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, 0) == false) goto CAE_SKIPDAMAGEMOVE2;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX = dX;
					m_pNpcList[sTargetH]->m_sY = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, 0, 0, 0);

					if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType)) {
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
							iExp = (m_pNpcList[sTargetH]->m_iExp / 3);
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0)
								iExp += m_pNpcList[sTargetH]->m_iNoDieRemainExp;

							if (m_pClientList[sAttackerH]->m_iAddExp != 0) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1 / 100.0f) * dTmp2;
								iExp += (int)dTmp3;
							}

							if ((m_bIsCrusadeMode) && (iExp > 10)) iExp = 10;

							GetExp(sAttackerH, iExp);

							// Use EntityManager for NPC deletion
							if (m_pEntityManager != NULL)
								m_pEntityManager->DeleteEntity(sTargetH);
							return false;
						}
					}

				CAE_SKIPDAMAGEMOVE2:;
				}
				else {
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, 0);
				}

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] == 1) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, hb::magic::HoldObject);
				}
				else if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] == 2) {
					if ((m_pNpcList[sTargetH]->m_iHitDice > 50) && (iDice(1, 10) == 5)) {
						m_pNpcList[sTargetH]->m_cMagicEffectStatus[hb::magic::HoldObject] = 0;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, hb::magic::HoldObject);
					}
				}

				if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != true) &&
					(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != 0)) {
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > static_cast<uint32_t>(iDamage)) {
						iExp = iDamage;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}

					if (m_pClientList[sAttackerH]->m_iAddExp != 0) {
						dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
						dTmp2 = (double)iExp;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;
						iExp += (int)dTmp3;
					}

					if (m_bIsCrusadeMode) iExp = iExp / 3;

					if (m_pClientList[sAttackerH]->m_iLevel > 100) {
						switch (m_pNpcList[sTargetH]->m_sType) {
						case 55:
						case 56:
							iExp = 0;
							break;
						default: break;
						}
					}
				}
			}
			break;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)] != -1)
				sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)];
			else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];

			if ((sWeaponIndex != -1) && (bArrowUse != true)) {
				if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != 0) &&
					(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum != 231)) {
					if (bKilled == false)
						CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, 1);
					else {
						if (m_pClientList[sAttackerH]->m_iHP <= 3)
							CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice) * 2);
						else CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice));
					}
				}

				if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != 0) &&
					(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0)) {
					iWepLifeOff = 1;
					if ((wWeaponType >= 1) && (wWeaponType < 40)) {
						switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
						case 0:	break;
						case 1:	if (iDice(1, 3) == 1) iWepLifeOff++; break;
						case 2:	if (iDice(1, 2) == 1) iWepLifeOff += iDice(1, 2); break;
						case 3:	if (iDice(1, 2) == 1) iWepLifeOff += iDice(1, 3); break;
						}
					}

					if (m_pClientList[sAttackerH]->m_cSide != 0) {
						if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < iWepLifeOff)
							m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						else m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -= iWepLifeOff;

						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_CURLIFESPAN, sWeaponIndex, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan, 0, 0);
					}

					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0) {
						SendNotifyMsg(0, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, 0, 0);
						ReleaseItemHandler(sAttackerH, sWeaponIndex, true);
					}
				}
			}
			else {
				if (wWeaponType == 0) {
					CalculateSSN_SkillIndex(sAttackerH, 5, 1);
				}
			}
		}
	}
	else {
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
		}
	}

	return iExp;
}

// October 19, 2004 - 3.51 translated
void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{}

// October 19, 2004 - 3.51 translated


// October 19, 2004 - 3.51 translated
void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
	
	uint32_t dwTime = GameClock::GetTimeMS();

	switch (cAttackerSide) {
	case 1:
		if (m_iElvineMapIndex != -1) {
			for(int i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
					if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) {
						SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 1, 0, 0, 0);
					}
					else {
						SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, 0, 0, 0);
					}
				}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, 0, dwTime + 5000, 0, 0, m_iElvineMapIndex, 0, 0, 0, 0, 0);
		}
		else {
			for(int i = 1; i < DEF_MAXCLIENTS; i++)
				if (m_pClientList[i] != 0) {
					SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, 0, 0, 0);
				}
		}
		break;

	case 2:
		if (m_iAresdenMapIndex != -1) {
			for(int i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != 0) && (m_pClientList[i]->m_bIsInitComplete)) {
					if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) {
						SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 3, 0, 0, 0);
					}
					else {
						SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, 0, 0, 0);
					}
				}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, 0, dwTime + 1000 * 5, 0, 0, m_iAresdenMapIndex, 0, 0, 0, 0, 0);
		}
		else {
			for(int i = 1; i < DEF_MAXCLIENTS; i++)
				if (m_pClientList[i] != 0) {
					SendNotifyMsg(0, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, 0, 0, 0);
				}
		}
		break;
	}
}

// October 19, 2004 - 3.51 translated


// October 19, 2004 - 3.51 translated


// October 19,2004 - 3.51 translated


/*
void CGame::StormBringer(int iClientH, short dX, short dY)
{
	char cOwnerType;
	short sOwner, sAppr2, sAttackerWeapon;
	int  iDamage, iTemp, iV1, iV2, iV3;

	//ArchAngel Fix

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)] != -1) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

		iTemp = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)];
		sAppr2 = (short)((m_pClientList[iClientH]->m_appearance.bIsWalking) >> 12);

		if (m_pClientList[iClientH]->m_pItemList[iTemp]->m_sIDnum == hb::item::ItemId::StormBringer){

			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (sAppr2 != 0) {
					iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_L;
					iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_L;
					iV3 = m_pClientList[iClientH]->m_cAttackBonus_L;

					if (m_pClientList[iClientH]->m_cMagicEffectStatus[ hb::magic::Berserk ] != 0){
						iDamage = iDice(iV1*2,iV2*2)+iV3;
					}
					else{
						iDamage = iDice(iV1,iV2)+iV3;
					}

					m_pClientList[sOwner]->m_iHP -= iDamage;
					if (m_pClientList[sOwner]->m_iHP <= 0){
						sAttackerWeapon = 1;
						m_pClientList[sOwner]->m_iHP = 0;

						m_pClientList[sOwner]->m_bIsKilled = true;
						m_pClientList[sOwner]->m_iLastDamage = iDamage;
						SendNotifyMsg(0, sOwner, DEF_NOTIFY_HP, 0, 0, 0, 0);
						SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, iDamage, sAttackerWeapon, 0);
						m_pMapList[m_pClientList[sOwner]->m_cMapIndex]->ClearOwner(14, sOwner, DEF_OWNERTYPE_PLAYER, m_pClientList[sOwner]->m_sX, m_pClientList[sOwner]->m_sY);
						m_pMapList[m_pClientList[sOwner]->m_cMapIndex]->SetDeadOwner(sOwner, DEF_OWNERTYPE_PLAYER, m_pClientList[sOwner]->m_sX, m_pClientList[sOwner]->m_sY);
					}
					else{
						SendNotifyMsg(0, sOwner, DEF_NOTIFY_HP, 0, 0, 0, 0);
						SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (sAppr2 != 0) {
					if (m_pNpcList[sOwner]->m_cSize == 0){
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_SM;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_SM;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_SM;
					}
					else if (m_pNpcList[sOwner]->m_cSize == 1){
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_L;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_L;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_L;
					}

					if (m_pClientList[iClientH]->m_cMagicEffectStatus[ hb::magic::Berserk ] != 0){
						iDamage = iDice(iV1*2,iV2*2)+iV3;
					}
					else{
						iDamage = iDice(iV1,iV2)+iV3;
					}

					m_pNpcList[sOwner]->m_iHP -= iDamage;
					if (m_pNpcList[sOwner]->m_iHP <= 0){
						sAttackerWeapon = 1;
						m_pNpcList[sOwner]->m_iHP = 0;

						m_pNpcList[sOwner]->m_sBehaviorTurnCount = 0;
						m_pNpcList[sOwner]->m_cBehavior = DEF_BEHAVIOR_DEAD;
						m_pNpcList[sOwner]->m_dwDeadTime = GameClock::GetTimeMS();
						SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, iDamage, sAttackerWeapon, 0);
						m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->ClearOwner(10, sOwner, DEF_OWNERTYPE_NPC, m_pNpcList[sOwner]->m_sX, m_pNpcList[sOwner]->m_sY);
						m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->SetDeadOwner(sOwner, DEF_OWNERTYPE_NPC, m_pNpcList[sOwner]->m_sX, m_pNpcList[sOwner]->m_sY);
					}
					else{
						SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, 0);
					}
				}
				break;
			}
		}
	}
}*/

bool CGame::_bCheckCharacterData(int iClientH)
{
	

	if ((m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) ||
		(m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT)) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) stat points are greater then server accepts.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch (...)
		{

		}
	}

	if ((m_pClientList[iClientH]->m_iLevel > m_iMaxLevel) ) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) level above max server level.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch (...)
		{

		}
	}

	if (m_pClientList[iClientH]->m_iExp < 0) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) experience is below 0 - (Exp:%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iExp);
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch (...)
		{

		}
	}

	if ((m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) ) {
		try
		{
			if (m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)])] != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)])]->m_sIDnum == 492) || (m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::RightHand)])]->m_sIDnum == 491)) {
					if (m_pClientList[iClientH]->m_iHP > (4 * (iGetMaxHP(iClientH) / 5))) {

					}
				}
			}
			else if (m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)])] != 0) {
				if ((m_pClientList[iClientH]->m_pItemList[(m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::TwoHand)])]->m_sIDnum == 490)) {
					if (m_pClientList[iClientH]->m_iHP > (4 * (iGetMaxHP(iClientH) / 5))) {

					}
				}
			}
			else {
				std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) HP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iHP, iGetMaxHP(iClientH));
				PutHackLogFileList(G_cTxt);
				return false;
			}
		}
		catch (...)
		{

		}
	}

	if ((m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) ) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) MP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iMP, iGetMaxMP(iClientH));
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch (...)
		{

		}
	}

	if ((m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) ) {
		try
		{
			std::snprintf(G_cTxt, sizeof(G_cTxt), "Packet Editing: (%s) Player: (%s) SP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iSP, iGetMaxSP(iClientH));
			PutHackLogFileList(G_cTxt);
			return false;
		}
		catch (...)
		{

		}
	}

	try
	{
		for(int i = 0; i < DEF_MAXBANNED; i++) {
			if (strlen(m_stBannedList[i].m_cBannedIPaddress) == 0) break; //No more GM's on list
			if ((strlen(m_stBannedList[i].m_cBannedIPaddress)) == (strlen(m_pClientList[iClientH]->m_cIPaddress))) {
				if (memcmp(m_stBannedList[i].m_cBannedIPaddress, m_pClientList[iClientH]->m_cIPaddress, strlen(m_pClientList[iClientH]->m_cIPaddress)) == 0) {
					std::snprintf(G_cTxt, sizeof(G_cTxt), "Client Rejected: Banned: (%s)", m_pClientList[iClientH]->m_cIPaddress);
					PutLogList(G_cTxt);
					return false;
				}
				else {

				}
			}
		}
	}
	catch (...)
	{

	}

	return true;
}

void CGame::GlobalEndHeldenianMode()
{
	//char * cp, cData[32];

	if (m_bIsHeldenianMode == false) return;

	LocalEndHeldenianMode();

}

void CGame::LocalEndHeldenianMode()
{
	if (m_bIsHeldenianMode == false) return;
	m_bIsHeldenianMode = false;
	m_bHeldenianInitiated = true;

	m_dwHeldenianFinishTime = static_cast<uint32_t>(time(0));
	if (var_88C == 1) {
		if (m_cHeldenianModeType == 1) {
			if (m_iHeldenianAresdenLeftTower > m_iHeldenianElvineLeftTower) {
				m_cHeldenianVictoryType = 1;
			}
			else if (m_iHeldenianAresdenLeftTower < m_iHeldenianElvineLeftTower) {
				m_cHeldenianVictoryType = 2;
			}
			else if (m_iHeldenianAresdenDead < m_iHeldenianElvineDead) {
				m_cHeldenianVictoryType = 1;
			}
			else if (m_iHeldenianAresdenDead > m_iHeldenianElvineDead) {
				m_cHeldenianVictoryType = 2;
			}
			else {
				m_sLastHeldenianWinner = m_cHeldenianVictoryType;
			}
		}
		else if (m_cHeldenianModeType == 2) {
			m_sLastHeldenianWinner = m_cHeldenianVictoryType;
		}
		m_sLastHeldenianWinner = m_cHeldenianVictoryType;
		if (bNotifyHeldenianWinner() == false) {
			std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) HELDENIAN End. Result Report Failed");
			PutLogList(G_cTxt);
		}
	}
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) HELDENIAN End. %d", m_sLastHeldenianWinner);
	PutLogList(G_cTxt);

	for(int i = 0; i < DEF_MAXMAPS; i++)
	{
		if (m_pMapList[i] != 0)
		{
			for (int x = 0; x < DEF_MAXCLIENTS; x++)
				if ((m_pClientList[x] != 0) && (m_pClientList[x]->m_bIsInitComplete)) {
					SendNotifyMsg(0, x, DEF_NOTIFY_HELDENIANEND, 0, 0, 0, 0);
					if (m_pMapList[m_pClientList[x]->m_cMapIndex]->m_bIsHeldenianMap) {
						for (int n = 0; n < DEF_MAXNPCS; n++)
							if ((m_pNpcList[n] != 0) && (m_pMapList[m_pNpcList[n]->m_cMapIndex] != 0) && (m_pNpcList[n]->m_bIsSummoned)) {
								RemoveHeldenianNpc(n);
							}
						RemoveOccupyFlags(x);
					}
				}
		}
	}
	_CreateHeldenianGUID(m_dwHeldenianGUID, m_cHeldenianVictoryType);
}

bool CGame::bNotifyHeldenianWinner()
{
	if (var_88C == 0) {
		return true;
	}
	else {
		return false;
	}

}

void CGame::RemoveHeldenianNpc(int iNpcH)
{
	if (m_pNpcList[iNpcH] == 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled) return;

	m_pNpcList[iNpcH]->m_bIsKilled = true;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = 0;
	m_pNpcList[iNpcH]->m_dwRegenTime = 0;
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC);
	m_pNpcList[iNpcH]->m_iTargetIndex = 0;
	m_pNpcList[iNpcH]->m_cTargetType = 0;

	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, 1, 0);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pNpcList[iNpcH]->m_cBehavior = 4;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	m_pNpcList[iNpcH]->m_dwDeadTime = GameClock::GetTimeMS();

}

void CGame::RemoveOccupyFlags(int iMapIndex)
{
	uint32_t dwTime = GameClock::GetTimeMS();
	
	short dX, dY;
	int iDynamicObjectIndex;
	class COccupyFlag* iOccupyFlagIndex;
	class CTile* pTile;

	if (m_pMapList[iMapIndex] == 0) return;
	for(int i = 1; i < DEF_MAXOCCUPYFLAG; i++)
		//if (m_pMapList[iMapIndex]->m_pOccupyFlag[i]) return; // centu : wtf ?
		if (m_pMapList[iMapIndex]->m_pOccupyFlag[i]) {
			dX = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			dY = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			pTile = (class CTile*)(m_pMapList[iMapIndex]->m_pTile + dX + dY * m_pMapList[iMapIndex]->m_sSizeY);
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			if (m_pDynamicObjectList[iDynamicObjectIndex] == 0) return;

			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex,
				m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY,
				m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, 0, (short)0);

			m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(0, 0, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);

			iOccupyFlagIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i];

			if (m_pDynamicObjectList[iDynamicObjectIndex] == 0) {
				for(int ix = dX - 2; ix <= dX + 2; ix++)
					for(int iy = dY - 2; iy <= dY + 2; iy++) {
						pTile = (class CTile*)(m_pMapList[iMapIndex]->m_pTile + ix + iy * m_pMapList[iMapIndex]->m_sSizeY);
						pTile->m_sOwner = 0;
					}
			}
		}
}

void CGame::_CreateHeldenianGUID(uint32_t dwHeldenianGUID, int iWinnerSide)
{
	char* cp, cTxt[256], cFn[256], cTemp[1024];
	FILE* pFile;

#ifdef _WIN32
	_mkdir("GameData");
#endif
	std::memset(cFn, 0, sizeof(cFn));

	strcat(cFn, "GameData");
	strcat(cFn, "\\");
	strcat(cFn, "\\");
	strcat(cFn, "HeldenianGUID.Txt");

	pFile = fopen(cFn, "wt");
	if (pFile == 0) {
		std::snprintf(cTxt, sizeof(cTxt), "(!) Cannot create HeldenianGUID(%d) file", dwHeldenianGUID);
		PutLogList(cTxt);
	}
	else {
		std::memset(cTemp, 0, sizeof(cTemp));

		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "HeldenianGUID = %d", dwHeldenianGUID);
		strcat(cTemp, cTxt);

		std::memset(cTxt, 0, sizeof(cTxt));
		std::snprintf(cTxt, sizeof(cTxt), "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);

		cp = (char*)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);

		std::snprintf(cTxt, sizeof(cTxt), "(O) HeldenianGUID(%d) file created", dwHeldenianGUID);
		PutLogList(cTxt);
	}
	if (pFile != 0) fclose(pFile);
}

bool CGame::bCheckHeldenianMap(int sAttackerH, int iMapIndex, char cType)
{
	short tX, tY;
	int iRet;
	class CTile* pTile;

	iRet = 0;
	if (m_pClientList[sAttackerH] == 0) return 0;
	if ((m_bIsHeldenianMode == 1) || (m_cHeldenianType == 1)) {
		if (cType == DEF_OWNERTYPE_PLAYER) {
			if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) && (m_pClientList[sAttackerH]->m_cSide > 0)) {
				tX = m_pClientList[sAttackerH]->m_sX;
				tY = m_pClientList[sAttackerH]->m_sY;
				if ((tX < 0) || (tX >= m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeX) ||
					(tY < 0) || (tY >= m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeY)) return 0;
				pTile = (class CTile*)(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_pTile + tX + tY * m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeY);
				if (pTile == 0) return 0;
				if (pTile->m_iOccupyStatus != 0) {
					if (pTile->m_iOccupyStatus < 0) {
						if (m_pClientList[sAttackerH]->m_cSide == 1) {
							iRet = 1;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						if (m_pClientList[sAttackerH]->m_cSide == 2) {
							iRet = 1;
						}
					}
				}
			}
		}
		else if (cType == DEF_OWNERTYPE_NPC) {
			if ((m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex] != 0) && (iMapIndex != -1) && (m_pNpcList[sAttackerH]->m_cSide > 0)) {
				tX = m_pNpcList[sAttackerH]->m_sX;
				tY = m_pNpcList[sAttackerH]->m_sY;
				pTile = (class CTile*)(m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_pTile + tX + tY * m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_sSizeY);
				if (pTile == 0) return 0;
				if (pTile->m_iOccupyStatus != 0) {
					if (pTile->m_iOccupyStatus < 0) {
						if (m_pNpcList[sAttackerH]->m_cSide == 1) {
							iRet = 1;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						if (m_pNpcList[sAttackerH]->m_cSide == 2) {
							iRet = 1;
						}
					}
				}
			}
		}
	}
	return iRet;
}

void CGame::RequestHeldenianTeleport(int iClientH, char* pData, size_t dwMsgSize)
{
	char cTmpName[DEF_NPCNAME], * cp, cTxt[512], cMapName[11];
	short tX, tY, cLoc, * sp;
	uint16_t wResult;
	int iRet, iWhyReturn, iProcessed;

	iProcessed = 1;
	if (m_pClientList[iClientH] == 0) return;

	const auto* header = hb::net::PacketCast<hb::net::PacketHeader>(pData, sizeof(hb::net::PacketHeader));
	if (!header) return;
	cp = (char*)(pData + sizeof(hb::net::PacketHeader));
	std::memset(cTmpName, 0, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	if (strcmp(cTmpName, "Gail") == 0) {
		std::memset(cTxt, 0, sizeof(cTxt));
		if ((m_bIsHeldenianMode == 1) && (m_pClientList[iClientH]->m_bIsPlayerCivil != true) && (m_pClientList[iClientH]->m_cSide == 2 || m_pClientList[iClientH]->m_cSide == 1)) {
			if (m_cHeldenianType == 1) {
				std::memset(cMapName, 0, sizeof(cMapName));
				memcpy(cMapName, "BtField", 10);
				if (m_pClientList[iClientH]->m_cSide == 1) {
					tX = 68;
					tY = 225;
					cLoc = 1;
				}
				else if (m_pClientList[iClientH]->m_cSide == 2) {
					tX = 202;
					tY = 70;
					cLoc = 2;
				}
			}
			else if (m_cHeldenianType == 2) {
				std::memset(cMapName, 0, sizeof(cMapName));
				memcpy(cMapName, "HRampart", 10);
				if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) {
					tX = 81;
					tY = 42;
					cLoc = 3;
				}
				else {
					tX = 156;
					tY = 153;
					cLoc = 4;
				}
			}
			wResult = DEF_MSGTYPE_CONFIRM;
			iProcessed = 1;
			iWhyReturn = 0;
		}
	}

	wResult = DEF_MSGTYPE_REJECT;
	iProcessed = 0;
	iWhyReturn = 0;

	sp = (short*)cp;
	*sp = 4;
	cp += 4;

	sp = (short*)cp;
	*sp = cLoc;
	cp += 4;

	memcpy(cp, cMapName, 10);
	cp += 10;

	sp = (short*)cp;
	*sp = tX;
	cp += 4;

	sp = (short*)cp;
	*sp = tY;
	cp += 4;

	sp = (short*)cp;
	*sp = iWhyReturn;
	cp += 4;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTxt, 36);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, true, true);
		break;
	}
}


void CGame::GlobalStartHeldenianMode()
{
	uint32_t dwTime = GameClock::GetTimeMS();
	LocalStartHeldenianMode(m_cHeldenianModeType, m_sLastHeldenianWinner, dwTime);

}

void CGame::LocalStartHeldenianMode(short sV1, short sV2, uint32_t dwHeldenianGUID)
{
	int x, z, iNamingValue;
	char cName[DEF_CHARNAME], cTmp[21], cNpcWaypointIndex[10], cSide, cOwnerType;
	short sOwnerH;
	int bRet;
	int dX, dY;

	if (m_bIsHeldenianMode) return;

	if ((m_cHeldenianModeType == -1) || (m_cHeldenianModeType != sV1)) {
		m_cHeldenianModeType = static_cast<char>(sV1);
	}
	if ((m_sLastHeldenianWinner != -1) && (m_sLastHeldenianWinner == sV2)) {
		std::snprintf(G_cTxt, sizeof(G_cTxt), "Heldenian Mode : %d , Heldenian Last Winner : %d", m_cHeldenianModeType, m_sLastHeldenianWinner);
		PutLogFileList(G_cTxt);
	}

	if (dwHeldenianGUID != 0) {
		_CreateHeldenianGUID(dwHeldenianGUID, 0);
		m_dwHeldenianGUID = dwHeldenianGUID;
	}
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;

	for(int i = 0; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsInitComplete != true) break;
			m_pClientList[i]->m_cVar = 2;
			SendNotifyMsg(0, i, DEF_NOTIFY_HELDENIANTELEPORT, 0, 0, 0, 0);
			m_pClientList[i]->m_iWarContribution = 0;
			m_pClientList[i]->m_iConstructionPoint = (m_pClientList[i]->m_iCharisma * 300);
			if (m_pClientList[i]->m_iConstructionPoint > 12000) m_pClientList[i]->m_iConstructionPoint = 12000;
			SendNotifyMsg(0, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 1, 0);
		}
	}

	for (x = 0; x < DEF_MAXMAPS; x++) {
		if (m_pMapList[x] == 0) break;
		if (m_pMapList[x]->m_bIsHeldenianMap) {
			for(int i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] == 0) break;
				if (m_pClientList[i]->m_bIsInitComplete != true) break;
				if (m_pClientList[i]->m_cMapIndex != x) break;
				SendNotifyMsg(0, i, DEF_NOTIFY_0BE8, 0, 0, 0, 0);
				RequestTeleportHandler(i, "1   ", 0, -1, -1);
			}
			for(int i = 0; i < DEF_MAXNPCS; i++) {
				if (m_pNpcList[i] == 0) break;
				if (m_pNpcList[i]->m_bIsKilled) break;
				if (m_pNpcList[i]->m_cMapIndex != x) break;
				m_pNpcList[i]->m_bIsSummoned = true;
				RemoveHeldenianNpc(i);
			}

			if (m_cHeldenianModeType == 1) {
				if (strcmp(m_pMapList[x]->m_cName, "BtField") == 0) {
					for(int i = 0; i < MAX_HELDENIANTOWER; i++) {
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID > DEF_MAXNPCTYPES) break;
						if (iNamingValue != -1) {
							dX = m_pMapList[x]->m_stHeldenianTower[i].dX;
							dY = m_pMapList[x]->m_stHeldenianTower[i].dY;
							cSide = m_pMapList[x]->m_stHeldenianTower[i].cSide;
							for (z = 0; z < DEF_MAXNPCTYPES; z++) {
								if (m_pNpcConfigList[z] == 0) break;
								if (m_pNpcConfigList[z]->m_sType == m_pMapList[x]->m_stHeldenianTower[i].sTypeID) {
									std::memset(cTmp, 0, sizeof(cTmp));
									strcpy(cTmp, m_pNpcConfigList[z]->m_cNpcName);
								}
							}
							std::memset(cName, 0, sizeof(cName));
							std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = static_cast<char>(i + 65);
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, 0, 0, cSide, false, false, false, true, false);
							if (bRet == 0) {
								m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != 0) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) {
									m_pNpcList[sOwnerH]->m_iBuildCount = 0;
								}
								if (cSide == 1)	m_iHeldenianAresdenLeftTower += 1;
								if (cSide == 2) m_iHeldenianElvineLeftTower += 1;
							}
						}
					}
					std::snprintf(G_cTxt, sizeof(G_cTxt), "HeldenianAresdenLeftTower : %d , HeldenianElvineLeftTower : %d", m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower);
					PutLogFileList(G_cTxt);
					UpdateHeldenianStatus();
				}
			}
			else if (m_cHeldenianModeType == 2) {
				if (strcmp(m_pMapList[x]->m_cName, "HRampart") == 0) {
					for(int i = 0; i < DEF_MAXHELDENIANDOOR; i++) {
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							dX = m_pMapList[x]->m_stHeldenianGateDoor[i].dX;
							dY = m_pMapList[x]->m_stHeldenianGateDoor[i].dY;
							cSide = m_sLastHeldenianWinner;
							for (z = 0; z < DEF_MAXNPCTYPES; z++) {
								if (m_pNpcConfigList[z] == 0) break;
								if (m_pNpcConfigList[z]->m_sType == 91) {
									std::memset(cTmp, 0, sizeof(cTmp));
									strcpy(cTmp, m_pNpcConfigList[z]->m_cNpcName);
								}
							}
							std::memset(cName, 0, sizeof(cName));
							std::snprintf(cName, sizeof(cName), "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = static_cast<char>(i + 65);
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, 0, 0, cSide, false, false, false, true, false);
							if (bRet == 0) {
								m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								//m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[bRet] != 0) && (bRet > 0) && (bRet < DEF_MAXNPCS)) {
									m_pNpcList[bRet]->m_iBuildCount = 0;
									m_pNpcList[bRet]->m_cDir = m_pMapList[x]->m_stHeldenianGateDoor[i].cDir;
								}
							}
						}
					}
				}
			}
		}
	}
	m_bHeldenianInitiated = true;
	m_bIsHeldenianMode = true;
	std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) HELDENIAN Start.");
	PutLogFileList(G_cTxt);
	m_dwHeldenianStartTime = static_cast<uint32_t>(time(0));
}

void CGame::ManualStartHeldenianMode(int iClientH, char* pData, size_t dwMsgSize)
{
	char cHeldenianType, cBuff[256], * token, seps[] = "= \t\r\n";
	SYSTEMTIME SysTime;
	int iV1;

	if (m_bIsHeldenianMode) return;
	if (m_bIsApocalypseMode) return;
	if (m_bIsCrusadeMode) return;
	if ((dwMsgSize != 0) && (pData != 0)) {
		m_bHeldenianRunning = true;
		GetLocalTime(&SysTime);

		std::memset(cBuff, 0, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);
		token = strtok(NULL, seps);
		token = strtok(NULL, seps);
		if (token != 0) {
			iV1 = atoi(token);
			iV1 += (SysTime.wHour * 24 + SysTime.wMinute * 60);
			m_dwHeldenianStartHour = (iV1 / 24);
			m_dwHeldenianStartMinute = (iV1 / 60);
		}
		token = strtok(NULL, seps);
		if (token != 0) {
			cHeldenianType = atoi(token);
			if ((cHeldenianType == 1) || (cHeldenianType == 2)) {
				m_cHeldenianModeType = cHeldenianType;
			}
		}
	}
	GlobalStartHeldenianMode();
	std::snprintf(G_cTxt, sizeof(G_cTxt), "GM Order(%s): begin Heldenian", m_pClientList[iClientH]->m_cCharName);
	PutLogFileList(G_cTxt);
}

void CGame::ManualEndHeldenianMode(int iClientH, char* pData, size_t dwMsgSize)
{
	if (m_bIsHeldenianMode) {
		GlobalEndHeldenianMode();
		m_bHeldenianRunning = false;
		std::snprintf(G_cTxt, sizeof(G_cTxt), "GM Order(%s): end Heldenian", m_pClientList[iClientH]->m_cCharName);
		PutLogFileList(G_cTxt);
	}
}

void CGame::SetHeldenianMode()
{
	SYSTEMTIME SysTime;

	GetLocalTime(&SysTime);
	m_dwHeldenianStartHour = SysTime.wHour;
	m_dwHeldenianStartMinute = SysTime.wMinute;

	if (m_cHeldenianModeType != 2) {
		m_cHeldenianVictoryType = m_sLastHeldenianWinner;
	}
}

void CGame::CheckCrusadeResultCalculation(int iClientH)
{
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_cVar == 1) return;

	if ((m_bIsCrusadeMode == false) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
		if (m_pClientList[iClientH]->m_iWarContribution > m_iMaxWarContribution) m_pClientList[iClientH]->m_iWarContribution = m_iMaxWarContribution;
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_iCrusadeWinnerSide == 0) {
				m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution / 6);
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, m_pClientList[iClientH]->m_iWarContribution, 0);
			}
			else {
				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 100;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 40;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, m_pClientList[iClientH]->m_iWarContribution, 0);
				}
				else if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_cSide) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 100;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel * 40;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution / 10;
					SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, -1 * m_pClientList[iClientH]->m_iWarContribution, 0);
				}
			}
		}
		else {
			SendNotifyMsg(0, iClientH, DEF_NOTIFY_CRUSADE, (uint32_t)m_bIsCrusadeMode, 0, 0, 0, -1);
		}
		m_pClientList[iClientH]->m_iCrusadeDuty = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}

void CGame::CheckHeldenianResultCalculation(int iClientH)
{
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_cVar != 2) return;
	if ((m_cHeldenianType == 0) || (m_pClientList[iClientH]->m_dwHeldenianGUID == 0)) return;
	if (m_pClientList[iClientH]->m_dwHeldenianGUID == m_dwHeldenianGUID) {
		if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) {
			if (m_pClientList[iClientH]->m_iLevel <= 80) {
				m_pClientList[iClientH]->m_iWarContribution += (m_pClientList[iClientH]->m_iLevel) * 200;
			}
			else if (m_pClientList[iClientH]->m_iLevel > 80 && m_pClientList[iClientH]->m_iLevel <= 100) {
				m_pClientList[iClientH]->m_iWarContribution += (m_pClientList[iClientH]->m_iLevel) * 100;
			}
			else if (m_pClientList[iClientH]->m_iLevel > 100) {
				m_pClientList[iClientH]->m_iWarContribution += (m_pClientList[iClientH]->m_iLevel) * 30;
			}
			dV2 = (double)m_pClientList[iClientH]->m_iExp;
			dV3 = (double)m_pClientList[iClientH]->m_iWarContribution * 1.2f;
			dV1 = dV2 + dV3;
			GetExp(iClientH, (uint32_t)dV1);
		}
		else {
			GetExp(iClientH, (m_pClientList[iClientH]->m_iWarContribution / 5));
		}
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwHeldenianGUID = 0;
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = GameClock::GetTimeMS();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}


bool CGame::UpdateHeldenianStatus()
{
	
	bool bFlag;
	int iShortCutIndex, iClientH;

	if (m_bIsHeldenianMode != true) return false;
	for(int i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != 0) {
			if (m_pMapList[i]->m_bIsHeldenianMap) {
				bFlag = true;
				iShortCutIndex = 0;
			}
			if (bFlag) {
				iClientH = m_iClientShortCut[iShortCutIndex];
				iShortCutIndex++;
				if (iClientH == 0) {
					bFlag = 0;
				}
				else {
					if ((m_pClientList[iClientH] != 0) && (m_pClientList[iClientH]->m_bIsInitComplete) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "BtField") == 0)) {
						SendNotifyMsg(0, iClientH, DEF_NOTIFY_HELDENIANCOUNT, m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower, m_iHeldenianAresdenDead, 0, m_iHeldenianElvineDead, 0);
					}
				}
			}
		}
	return true;
}


void CGame::ForceRecallProcess() {
	
	int iMapSide = 0;

	uint32_t dwTime;

	dwTime = GameClock::GetTimeMS();

	for(int i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != 0) {
			if (m_pClientList[i]->m_bIsInitComplete) {
				//force recall in enemy buidlings at crusade
				iMapSide = iGetMapLocationSide(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName);
				if ((memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) && (iMapSide == 2) && (m_bIsCrusadeMode)) {
					RequestTeleportHandler(i, "2   ", "aresden", -1, -1);
				}
				if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) && (iMapSide == 1) && (m_bIsCrusadeMode)) {
					RequestTeleportHandler(i, "2   ", "elvine", -1, -1);
				}

				//remove mim in building
				if ((memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "wrhus", 5) == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gshop_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "bsmith_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cath_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "CmdHall_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cityhall_1") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gshop_2") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "bsmith_2") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cath_2") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "CmdHall_2") == 0)
					|| (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "cityhall_2") == 0)
					|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "wzdtwr", 6) == 0)
					|| (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "gldhall", 7) == 0))
				{
					//SetIllusionFlag(i, DEF_OWNERTYPE_PLAYER, false);
					if (m_pClientList[i]->m_status.bIllusionMovement) {
						SetIllusionMovementFlag(i, DEF_OWNERTYPE_PLAYER, false);
						bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, hb::magic::Confuse);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, hb::magic::Confuse, dwTime + 2, i, DEF_OWNERTYPE_PLAYER, 0, 0, 0, 4, 0, 0);
					}
				}
			}
			//check gizon errors
			if (m_pClientList[i]->m_iLevel < 180) {
				if (m_pClientList[i]->m_iGizonItemUpgradeLeft > 0) {
					m_pClientList[i]->m_iGizonItemUpgradeLeft = 0;
				}
			}
		}
	}
}

//in stat change, check skillpoints
void CGame::SkillCheck(int sTargetH) {
	//magic
	while ((m_pClientList[sTargetH]->m_iMag * 2) < m_pClientList[sTargetH]->m_cSkillMastery[4]) {
		m_pClientList[sTargetH]->m_cSkillMastery[4]--;
	}
	//hand attack
	while ((m_pClientList[sTargetH]->m_iStr * 2) < m_pClientList[sTargetH]->m_cSkillMastery[5]) {
		m_pClientList[sTargetH]->m_cSkillMastery[5]--;
	}
	//hammer
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[14]) {
		m_pClientList[sTargetH]->m_cSkillMastery[14]--;
	}
	//shield
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[11]) {
		m_pClientList[sTargetH]->m_cSkillMastery[11]--;
	}
	//axe
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[10]) {
		m_pClientList[sTargetH]->m_cSkillMastery[10]--;
	}
	//fencing
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[9]) {
		m_pClientList[sTargetH]->m_cSkillMastery[9]--;
	}
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[8]) {
		m_pClientList[sTargetH]->m_cSkillMastery[8]--;
	}
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[7]) {
		m_pClientList[sTargetH]->m_cSkillMastery[7]--;
	}
	//archery
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[6]) {
		m_pClientList[sTargetH]->m_cSkillMastery[6]--;
	}
	//staff
	while ((m_pClientList[sTargetH]->m_iMag * 2) < m_pClientList[sTargetH]->m_cSkillMastery[21]) {
		m_pClientList[sTargetH]->m_cSkillMastery[21]--;
	}
	//alc
	while ((m_pClientList[sTargetH]->m_iInt * 2) < m_pClientList[sTargetH]->m_cSkillMastery[12]) {
		m_pClientList[sTargetH]->m_cSkillMastery[12]--;
	}
	//manu
	while ((m_pClientList[sTargetH]->m_iStr * 2) < m_pClientList[sTargetH]->m_cSkillMastery[13]) {
		m_pClientList[sTargetH]->m_cSkillMastery[13]--;
	}
	while ((m_pClientList[sTargetH]->m_iVit * 2) < m_pClientList[sTargetH]->m_cSkillMastery[23]) {
		m_pClientList[sTargetH]->m_cSkillMastery[23]--;
	}
	while ((m_pClientList[sTargetH]->m_iInt * 2) < m_pClientList[sTargetH]->m_cSkillMastery[19]) {
		m_pClientList[sTargetH]->m_cSkillMastery[19]--;
	}
	//farming
	while ((m_pClientList[sTargetH]->m_iInt * 2) < m_pClientList[sTargetH]->m_cSkillMastery[2]) {
		m_pClientList[sTargetH]->m_cSkillMastery[2]--;
	}
	//fishing
	while ((m_pClientList[sTargetH]->m_iDex * 2) < m_pClientList[sTargetH]->m_cSkillMastery[1]) {
		m_pClientList[sTargetH]->m_cSkillMastery[1]--;
	}
	//mining
	while ((m_pClientList[sTargetH]->m_iStr * 2) < m_pClientList[sTargetH]->m_cSkillMastery[0]) {
		m_pClientList[sTargetH]->m_cSkillMastery[0]--;
	}
}

bool CGame::IsEnemyZone(int i) {
	if (memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) {
		if ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresdend1") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "areuni") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone2") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone4") == 0)) {
			return true;
		}
	}
	else if (memcmp(m_pClientList[i]->m_cLocation, "are", 3) == 0) {
		if ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvined1") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvuni") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone1") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "huntzone3") == 0)) {
			return true;
		}
	}
	return false;
}

void CGame::LoteryHandler(int iClientH)
{
	CItem* pItem;
	int     iItemID;
	if (m_pClientList[iClientH] == 0) return;
	switch (iDice(1, 22)) {
	case 1:iItemID = 656; break; // XelimaStone
	case 2:iItemID = 657; break; // MerienStone
	case 3:iItemID = 650; break; // ZemstoneOfSacrifice
	case 4:iItemID = 652; break; // RedBall
	case 5:iItemID = 654; break; // BlueBall
	case 6:iItemID = 881; break; // ArmorDye(Indigo)
	case 7:iItemID = 882; break; // ArmorDye(CrimsonRed)
	case 8:iItemID = 883; break; // ArmorDye(Gold)
	case 9:iItemID = 884; break; // ArmorDye(Aqua)
	case 10:iItemID = 885; break; // ArmorDye(Pink)
	case 11:iItemID = 886; break; // ArmorDye(Violet)
	case 12:iItemID = 887; break; // ArmorDye(Blue) 
	case 13:iItemID = 888; break; // ArmorDye(Khaki) 
	case 14:iItemID = 889; break; // ArmorDye(Yellow) 
	case 15:iItemID = 890; break; // ArmorDye(Red) 
	case 16:iItemID = 971; break; // ArmorDye(Green)
	case 17:iItemID = 972; break; // ArmorDye(Black) 
	case 18:iItemID = 973; break; // ArmorDye(Knight) 
	case 19:iItemID = 970; break; // CritCandy
	case 20:iItemID = 651; break; // GreenBall
	case 21:iItemID = 653; break; // YellowBall
	case 22:iItemID = 655; break; // PearlBall
	}

	//chance
	if (iDice(1, 120) <= 3) iItemID = 650;//ZemstoneOfSacrifice
	//chance

	pItem = new CItem;
	if (_bInitItemAttr(pItem, iItemID) == false) {
		delete pItem;
	}
	else {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX,
			m_pClientList[iClientH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			pItem->m_sIDnum, 0, pItem->m_cItemColor, pItem->m_dwAttribute);
	}


}

void CGame::SetSkillAll(int iClientH, char* pData, size_t dwMsgSize)
//SetSkillAll Acidx Command,  Added July 04, 2005 INDEPENDENCE BABY Fuck YEA
{
	if (m_pClientList[iClientH] == 0) return;
	//Magic
	if (m_pClientList[iClientH]->m_cSkillMastery[4] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[4] = m_pClientList[iClientH]->m_iMag * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[4] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[4] = 100;
		}
		if (m_pClientList[iClientH]->m_iMag > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[4] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], 0, 0);

	}
	//LongSword
	if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[8] = m_pClientList[iClientH]->m_iDex * 2;

		if (m_pClientList[iClientH]->m_cSkillMastery[8] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[8] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[8] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 8, m_pClientList[iClientH]->m_cSkillMastery[8], 0, 0);

	}
	//Hammer
	if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[14] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[14] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[14] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[14] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 14, m_pClientList[iClientH]->m_cSkillMastery[14], 0, 0);

	}
	//Axes
	if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[10] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[10] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[10] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 10, m_pClientList[iClientH]->m_cSkillMastery[10], 0, 0);

	}
	//hand attack
	if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[5] = m_pClientList[iClientH]->m_iStr * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[5] = 100;
		}
		if (m_pClientList[iClientH]->m_iStr > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[5] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 5, m_pClientList[iClientH]->m_cSkillMastery[5], 0, 0);

	}
	//ShortSword
	if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[7] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[7] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[7] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 7, m_pClientList[iClientH]->m_cSkillMastery[7], 0, 0);

	}
	//archery
	if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[6] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[6] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[6] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 6, m_pClientList[iClientH]->m_cSkillMastery[6], 0, 0);

	}
	//Fencing
	if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[9] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[9] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[9] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 9, m_pClientList[iClientH]->m_cSkillMastery[9], 0, 0);

	}
	//Staff Attack
	if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[21] = m_pClientList[iClientH]->m_iInt * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[21] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[21] = 100;
		}
		if (m_pClientList[iClientH]->m_iInt > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[21] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 21, m_pClientList[iClientH]->m_cSkillMastery[21], 0, 0);

	}
	//shield
	if (m_pClientList[iClientH]->m_cSkillMastery[11] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[11] = m_pClientList[iClientH]->m_iDex * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[11] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[11] = 100;
		}
		if (m_pClientList[iClientH]->m_iDex > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[11] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 11, m_pClientList[iClientH]->m_cSkillMastery[11], 0, 0);

	}
	//mining
	if (m_pClientList[iClientH]->m_cSkillMastery[0] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[0] = 100;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 0, m_pClientList[iClientH]->m_cSkillMastery[0], 0, 0);

	}
	//fishing
	if (m_pClientList[iClientH]->m_cSkillMastery[1] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[1] = 100;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 1, m_pClientList[iClientH]->m_cSkillMastery[1], 0, 0);

	}
	//farming
	if (m_pClientList[iClientH]->m_cSkillMastery[2] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[2] = 100;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 2, m_pClientList[iClientH]->m_cSkillMastery[2], 0, 0);

	}
	//alchemy
	if (m_pClientList[iClientH]->m_cSkillMastery[12] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[12] = 100;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 12, m_pClientList[iClientH]->m_cSkillMastery[12], 0, 0);

	}
	//manufacturing
	if (m_pClientList[iClientH]->m_cSkillMastery[13] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[13] = 100;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 13, m_pClientList[iClientH]->m_cSkillMastery[13], 0, 0);

	}
	//poison resistance
	if (m_pClientList[iClientH]->m_cSkillMastery[23] < 20)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[23] = 20;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 23, m_pClientList[iClientH]->m_cSkillMastery[23], 0, 0);

	}
	//pretend corpse
	if (m_pClientList[iClientH]->m_cSkillMastery[19] < 100)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[19] = m_pClientList[iClientH]->m_iInt * 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[19] > 100)
		{
			m_pClientList[iClientH]->m_cSkillMastery[19] = 100;
		}
		if (m_pClientList[iClientH]->m_iInt > 50)
		{
			m_pClientList[iClientH]->m_cSkillMastery[19] = 100;
		}
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 19, m_pClientList[iClientH]->m_cSkillMastery[19], 0, 0);

	}
	//magic resistance
	if (m_pClientList[iClientH]->m_cSkillMastery[3] < 20)
	{
		// now we add skills
		m_pClientList[iClientH]->m_cSkillMastery[3] = 20;
		//Send a notify to update the client
		SendNotifyMsg(0, iClientH, DEF_NOTIFY_SKILL, 3, m_pClientList[iClientH]->m_cSkillMastery[3], 0, 0);

	}
}

//Angel Code By SlammeR(I dont know if it works)
/*void CGame::GetAngelMantleHandler(int iClientH,int iItemID,char * pString)
{
 int   i, iNum, iRet, iEraseReq;
 char  * cp, cData[256], cItemName[DEF_ITEMNAME];
 CItem * pItem;
 uint32_t * dwp;
 short * sp;
 uint16_t  * wp;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 5) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
		return;
	}

	//Prevents a crash if item dosent exist
	if (m_pItemConfigList[iItemID] == 0)  return;

	switch(iItemID) {
	//Angels
	case 908: //AngelicPandent(STR)
	case 909: //AngelicPandent(DEX)
		case 910: //AngelicPandent(INT)
		case 911: //AngelicPandent(MAG)
		if(m_pClientList[iClientH]->m_iGizonItemUpgradeLeft<5) return;
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 5;
		break;


  default:
	 return;
	 break;
  }

  std::memset(cItemName, 0, sizeof(cItemName));
  memcpy(cItemName,m_pItemConfigList[iItemID]->m_cName, DEF_ITEMNAME - 1);

  iNum = 1;
  for(int i = 1; i <= iNum; i++)
  {
	 pItem = new CItem;
	 if (_bInitItemAttr(pItem, cItemName) == false)
	 {
		delete pItem;
	 }
	 else {

		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) ) {
		   if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

		   std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get Angel : Char(%s) Player-Majestic-Points(%d) Angel Obtained(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, cItemName);
		   PutLogFileList(G_cTxt);

		   pItem->SetTouchEffectType(TouchEffectType::UniqueOwner);
		   pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		   pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		   pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

		   iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

		   if (iEraseReq == 1) delete pItem;

		   iCalcTotalWeight(iClientH);

		   switch (iRet) {
		   case DEF_XSOCKEVENT_QUENEFULL:
		   case DEF_XSOCKEVENT_SOCKETERROR:
		   case DEF_XSOCKEVENT_CRITICALERROR:
		   case DEF_XSOCKEVENT_SOCKETCLOSED:
			  DeleteClient(iClientH, true, true);
			  return;
		   }

		   SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);
		}
		else
		{
		   delete pItem;

		   iCalcTotalWeight(iClientH);

	   iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);


		   switch (iRet) {
		   case DEF_XSOCKEVENT_QUENEFULL:
		   case DEF_XSOCKEVENT_SOCKETERROR:
		   case DEF_XSOCKEVENT_CRITICALERROR:
		   case DEF_XSOCKEVENT_SOCKETCLOSED:

			  DeleteClient(iClientH, true, true);
			  return;
		   }
		}
	 }
   }
}*/

/*int CGame::iAngelEquip(int iClientH)
{
 int iTemp;
 CItem * cAngelTemp;
	iTemp = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::LeftFinger)];
	cAngelTemp = m_pClientList[iClientH]->m_pItemList[iTemp];
	if ((iTemp != -1) && (cAngelTemp != 0)) {
		if(cAngelTemp->m_sIDnum >= 908){ //AngelicPandent(STR)
				if(cAngelTemp->m_sIDnum >= 909){ //AngelicPandent(DEX)
				if(cAngelTemp->m_sIDnum >= 910){ //AngelicPandent(INT)
				if(cAngelTemp->m_sIDnum >= 911){ //AngelicPandent(MAG)

				return cAngelTemp->m_sIDnum;
			} else {
				return 0;
				}
				}
				}
		}
	}
}*/

/*void CGame::CheckAngelUnequip(int iClientH,int iAngelID)
{
 int iTemp;
 CItem * cAngelTemp;

	iTemp = m_pClientList[iClientH]->m_sItemEquipmentStatus[ToInt(EquipPos::LeftFinger)];
	cAngelTemp = m_pClientList[iClientH]->m_pItemList[iTemp];
	if ((iTemp != -1) && (cAngelTemp->m_sIDnum != iAngelID)) {
		cAngelTemp->m_sIDnum = iAngelID;
	}

}*/

/*********************************************************************************************************************
**  bool CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, iTemp)		Snoopy			**
** description	  :: Sets the staus to send or not Angels to every client							**
*********************************************************************************************************************/
void CGame::SetAngelFlag(short sOwnerH, char cOwnerType, int iStatus, int iTemp)
{
	if (cOwnerType != DEF_OWNERTYPE_PLAYER) return;
	if (m_pClientList[sOwnerH] == 0) return;
	switch (iStatus) {
	case 1: // STR Angel
		m_pClientList[sOwnerH]->m_status.bAngelSTR = true;
		break;
	case 2: // DEX Angel
		m_pClientList[sOwnerH]->m_status.bAngelDEX = true;
		break;
	case 3: // INT Angel
		m_pClientList[sOwnerH]->m_status.bAngelINT = true;
		break;
	case 4: // MAG Angel
		m_pClientList[sOwnerH]->m_status.bAngelMAG = true;
		break;
	default:
	case 0: // Remove all Angels
		m_pClientList[sOwnerH]->m_status.iAngelPercent = 0;
		m_pClientList[sOwnerH]->m_status.bAngelSTR = false;
		m_pClientList[sOwnerH]->m_status.bAngelDEX = false;
		m_pClientList[sOwnerH]->m_status.bAngelINT = false;
		m_pClientList[sOwnerH]->m_status.bAngelMAG = false;
		break;
	}
	if (iTemp > 4)
	{
		int iAngelicStars = (iTemp / 3) * (iTemp / 5);
		m_pClientList[sOwnerH]->m_status.iAngelPercent = static_cast<uint8_t>(iAngelicStars);
	}
	SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, 0, 0, 0);
}

/*********************************************************************************************************************
**  bool CGame::GetAngelHandler(int iClientH, char * pData, size_t dwMsgSize)										**
** description	  :: Reversed and coded by Snoopy																	**
*********************************************************************************************************************/
void CGame::GetAngelHandler(int iClientH, char* pData, size_t dwMsgSize)
{
	int   iAngel, iItemID;
	CItem* pItem;
	int   iRet, iEraseReq;
	if (m_pClientList[iClientH] == 0)					 return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (_iGetItemSpaceLeft(iClientH) == 0)
	{
		SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);
		return;
	}
	const auto* req = hb::net::PacketCast<hb::net::PacketRequestAngel>(pData, sizeof(hb::net::PacketRequestAngel));
	if (!req) return;
	iAngel = req->angel_id;

	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft < 5) return;

	switch (iAngel) {
	case 1: iItemID = hb::item::ItemId::AngelicPandentSTR; break;
	case 2: iItemID = hb::item::ItemId::AngelicPandentDEX; break;
	case 3: iItemID = hb::item::ItemId::AngelicPandentINT; break;
	case 4: iItemID = hb::item::ItemId::AngelicPandentMAG; break;
	default:
		PutLogList("Gail asked to create a wrong item!");
		return;
	}

	std::snprintf(G_cTxt, sizeof(G_cTxt), "PC(%s) requesting Angel (%d, ItemID:%d).   %s(%d %d)"
		, m_pClientList[iClientH]->m_cCharName
		, iAngel
		, iItemID
		, m_pClientList[iClientH]->m_cMapName
		, m_pClientList[iClientH]->m_sX
		, m_pClientList[iClientH]->m_sY);
	PutLogList(G_cTxt);

	pItem = new CItem;
	if ((_bInitItemAttr(pItem, iItemID)))
	{
		m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= 5;

		pItem->SetTouchEffectType(TouchEffectType::UniqueOwner);
		pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
		pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
		pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq))
		{
			if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;

			std::snprintf(G_cTxt, sizeof(G_cTxt), "(*) Get Angel : Char(%s) Player-Majestic-Points(%d) Angel Obtained(ID:%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, iItemID);
			PutLogFileList(G_cTxt);

			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, 0);

			iCalcTotalWeight(iClientH);

			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return;
			}

			SendNotifyMsg(0, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, 0, 0, 0);
		}
		else
		{
			delete pItem;

			iCalcTotalWeight(iClientH);

			iRet = SendItemNotifyMsg(iClientH, DEF_NOTIFY_CANNOTCARRYMOREITEM, 0, 0);

			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, true, true);
				return;
			}
		}
	}
	else
	{
		std::snprintf(G_cTxt, sizeof(G_cTxt), "(!) GetAngelHandler: _bInitItemAttr failed for ItemID %d. Item not found in config.", iItemID);
		PutLogList(G_cTxt);
		delete pItem;
	}
}

//50Cent - Repair All
void CGame::RequestRepairAllItemsHandler(int iClientH)
{
	int price;
	double d1, d2, d3;
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	m_pClientList[iClientH]->totalItemRepair = 0;

	for(int i = 0; i < hb::limits::MaxItems; i++) {
		if (m_pClientList[iClientH]->m_pItemList[i] != 0) {

			if (((m_pClientList[iClientH]->m_pItemList[i]->m_cCategory >= 1) && (m_pClientList[iClientH]->m_pItemList[i]->m_cCategory <= 12)) ||
				((m_pClientList[iClientH]->m_pItemList[i]->m_cCategory >= 43) && (m_pClientList[iClientH]->m_pItemList[i]->m_cCategory <= 50)))
			{
				if (m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan == m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan)
					continue;
				if (m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan <= 0)
					price = (m_pClientList[iClientH]->m_pItemList[i]->m_wPrice / 2);
				else
				{
					d1 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan);
					if (m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan != 0)
						d2 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wMaxLifeSpan);
					else
						d2 = (double)1.0f;
					d3 = (double)((d1 / d2) * 0.5f);
					d2 = (double)(m_pClientList[iClientH]->m_pItemList[i]->m_wPrice);
					d3 = (d3 * d2);
					price = ((m_pClientList[iClientH]->m_pItemList[i]->m_wPrice / 2) - (short)(d3));
				}
				m_pClientList[iClientH]->m_stRepairAll[m_pClientList[iClientH]->totalItemRepair].index = i;
				m_pClientList[iClientH]->m_stRepairAll[m_pClientList[iClientH]->totalItemRepair].price = price;
				m_pClientList[iClientH]->totalItemRepair++;
			}
		}
	}
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRALLPRICES, 0, 0, 0, 0);
}

void CGame::RequestRepairAllItemsDeleteHandler(int iClientH, int index)
{
	
	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;

	for(int i = index; i < m_pClientList[iClientH]->totalItemRepair; i++) {
		m_pClientList[iClientH]->m_stRepairAll[i] = m_pClientList[iClientH]->m_stRepairAll[i + 1];
	}
	m_pClientList[iClientH]->totalItemRepair--;
	SendNotifyMsg(0, iClientH, DEF_NOTIFY_REPAIRALLPRICES, 0, 0, 0, 0);
}

void CGame::RequestRepairAllItemsConfirmHandler(int iClientH)
{
	int      iRet, totalPrice = 0;

	if (m_pClientList[iClientH] == 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == false) return;
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == false) return;

	for(int i = 0; i < m_pClientList[iClientH]->totalItemRepair; i++) {
		totalPrice += m_pClientList[iClientH]->m_stRepairAll[i].price;
	}

	if (dwGetItemCountByID(iClientH, hb::item::ItemId::Gold) < (uint32_t)totalPrice)
	{
		{
			hb::net::PacketNotifyNotEnoughGold pkt{};
			pkt.header.msg_id = MSGID_NOTIFY;
			pkt.header.msg_type = DEF_NOTIFY_NOTENOUGHGOLD;
			pkt.item_index = 0;
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(reinterpret_cast<char*>(&pkt), sizeof(pkt));
		}
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, true, true);
			break;
		}

	}
	else
	{
		for(int i = 0; i < m_pClientList[iClientH]->totalItemRepair; i++)
		{
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index] != 0) {
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wMaxLifeSpan;
				SendNotifyMsg(0, iClientH, DEF_NOTIFY_ITEMREPAIRED, m_pClientList[iClientH]->m_stRepairAll[i].index, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_stRepairAll[i].index]->m_wCurLifeSpan, 0, 0);
			}
		}
		iCalcTotalWeight(SetItemCountByID(iClientH, hb::item::ItemId::Gold, dwGetItemCountByID(iClientH, hb::item::ItemId::Gold) - totalPrice));
	}
}