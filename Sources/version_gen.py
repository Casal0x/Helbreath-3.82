#!/usr/bin/env python3
"""Pre-build version header generator.

Reads Sources/version.cfg (INI-style with Wire/Server/Client sections),
manages per-project build counters (build_counter_client.txt, build_counter_server.txt),
and writes Sources/Dependencies/Shared/version_info.h.
"""

import argparse
import os
import re
import sys
from datetime import datetime

SOURCES_DIR = os.path.dirname(os.path.abspath(__file__))
VERSION_CFG = os.path.join(SOURCES_DIR, "version.cfg")
BUILD_COUNTER_CLIENT = os.path.join(SOURCES_DIR, "build_counter_client.txt")
BUILD_COUNTER_SERVER = os.path.join(SOURCES_DIR, "build_counter_server.txt")
OUTPUT_HEADER = os.path.join(SOURCES_DIR, "Dependencies", "Shared", "version_info.h")
OUTPUT_RC_HEADER = os.path.join(SOURCES_DIR, "Dependencies", "Shared", "version_rc.h")
OUTPUT_CMAKE = os.path.join(SOURCES_DIR, "version.cmake")

SECTION_MAP = {
    "Compatibility": "compatibility",
    "Server Version": "server",
    "Client Version": "client",
}


def read_version_cfg():
    """Parse INI-style version.cfg into {section_key: {field: value}}."""
    sections = {}
    current = None
    with open(VERSION_CFG, "r") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            m = re.match(r"^\[(.+)\]$", line)
            if m:
                section_name = m.group(1).strip()
                ns = SECTION_MAP.get(section_name)
                if ns:
                    current = {}
                    sections[ns] = current
                else:
                    current = None
                continue
            if current is not None and "=" in line:
                key, _, value = line.partition("=")
                current[key.strip()] = value.strip()
    return sections


def read_build_counter(path, increment=False):
    try:
        with open(path, "r") as f:
            count = int(f.read().strip())
    except (FileNotFoundError, ValueError):
        count = 0
    if increment:
        count += 1
        with open(path, "w") as f:
            f.write(f"{count}\n")
    return count


def make_display_version(major, minor, patch, stage):
    """Omits patch when 0, omits stage when empty (release)."""
    ver = f"{major}.{minor}"
    if patch != 0:
        ver += f".{patch}"
    if stage:
        ver += f"-{stage}"
    return ver


def make_full_version(major, minor, patch, stage, build_number):
    """Always full detail: major.minor.patch[-stage]+build.N"""
    ver = f"{major}.{minor}.{patch}"
    if stage:
        ver += f"-{stage}"
    ver += f"+build.{build_number}"
    return ver


def gen_namespace_block(ns, fields, build_number, indent=""):
    major = int(fields.get("major", 0))
    minor = int(fields.get("minor", 0))
    patch = int(fields.get("patch", 0))
    stage = fields.get("stage", "")
    display = make_display_version(major, minor, patch, stage)
    full = make_full_version(major, minor, patch, stage, build_number)
    return (
        f"{indent}namespace {ns}\n"
        f"{indent}{{\n"
        f"{indent}constexpr int major = {major};\n"
        f"{indent}constexpr int minor = {minor};\n"
        f"{indent}constexpr int patch = {patch};\n"
        f"{indent}constexpr int build_number = {build_number};\n"
        f"{indent}constexpr const char* stage = \"{stage}\";\n"
        f"{indent}constexpr const char* display_version = \"{display}\";\n"
        f"{indent}constexpr const char* full_version = \"{full}\";\n"
        f"{indent}}} // namespace {ns}\n"
    )


def gen_rc_header(sections, build_numbers):
    """Generate version_rc.h with #define values for Windows RC VERSIONINFO."""
    lines = ["// Auto-generated by version_gen.py — do not edit manually", "#pragma once", ""]

    for label, ns in [("CLIENT", "client"), ("SERVER", "server")]:
        fields = sections[ns]
        bn = build_numbers[ns]
        major = int(fields.get("major", 0))
        minor = int(fields.get("minor", 0))
        patch = int(fields.get("patch", 0))
        display = make_display_version(major, minor, patch, fields.get("stage", ""))
        full = make_full_version(major, minor, patch, fields.get("stage", ""), bn)

        lines.append(f"// {label.title()} version")
        lines.append(f"#define VER_{label}_MAJOR         {major}")
        lines.append(f"#define VER_{label}_MINOR         {minor}")
        lines.append(f"#define VER_{label}_PATCH         {patch}")
        lines.append(f"#define VER_{label}_BUILD         {bn}")
        lines.append(f"#define VER_{label}_FILEVERSION   {major},{minor},{patch},{bn}")
        lines.append(f'#define VER_{label}_DISPLAY       "{display}"')
        lines.append(f'#define VER_{label}_FULL          "{full}"')
        lines.append("")

    return "\n".join(lines)


def gen_cmake_version(sections, build_numbers):
    """Generate version.cmake with set() commands for Linux CMake builds."""
    lines = ["# Auto-generated by version_gen.py — do not edit manually", ""]

    for label, ns in [("CLIENT", "client"), ("SERVER", "server")]:
        fields = sections[ns]
        bn = build_numbers[ns]
        major = int(fields.get("major", 0))
        minor = int(fields.get("minor", 0))
        patch = int(fields.get("patch", 0))
        lines.append(f"set(HB_{label}_VERSION_MAJOR {major})")
        lines.append(f"set(HB_{label}_VERSION_MINOR {minor})")
        lines.append(f"set(HB_{label}_VERSION_PATCH {patch})")
        lines.append(f"set(HB_{label}_BUILD_NUMBER {bn})")
        lines.append(f'set(HB_{label}_VERSION "{major}.{minor}.{patch}")')
        lines.append("")

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(description="Generate version headers from version.cfg")
    parser.add_argument("--increment-version", action="store_true",
                        help="Increment build counter(s) (default: read-only)")
    parser.add_argument("--target", choices=["client", "server", "all"], default="all",
                        help="Which build counter(s) to increment (default: all)")
    args = parser.parse_args()

    try:
        sections = read_version_cfg()
        for required in ("compatibility", "server", "client"):
            if required not in sections:
                print(f"version_gen.py: ERROR: missing [{required}] section in version.cfg", file=sys.stderr)
                return 1

        increment_client = args.increment_version and args.target in ("client", "all")
        increment_server = args.increment_version and args.target in ("server", "all")

        build_numbers = {
            "client": read_build_counter(BUILD_COUNTER_CLIENT, increment=increment_client),
            "server": read_build_counter(BUILD_COUNTER_SERVER, increment=increment_server),
        }
        timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")

        # Generate C++ constexpr header (version_info.h)
        header = "// Auto-generated by version_gen.py — do not edit manually\n"
        header += "#pragma once\n\n"
        header += "namespace hb::version\n{\n\n"
        header += gen_namespace_block("compatibility", sections["compatibility"], 0)
        header += "\n"
        header += gen_namespace_block("server", sections["server"], build_numbers["server"])
        header += "\n"
        header += gen_namespace_block("client", sections["client"], build_numbers["client"])
        header += f"\nconstexpr const char* build_timestamp = \"{timestamp}\";\n"
        header += "\n} // namespace hb::version\n"

        os.makedirs(os.path.dirname(OUTPUT_HEADER), exist_ok=True)
        with open(OUTPUT_HEADER, "w", newline="\n") as f:
            f.write(header)

        # Generate RC header for Windows VERSIONINFO (version_rc.h)
        with open(OUTPUT_RC_HEADER, "w", newline="\n") as f:
            f.write(gen_rc_header(sections, build_numbers))

        # Generate CMake version file for Linux builds (version.cmake)
        with open(OUTPUT_CMAKE, "w", newline="\n") as f:
            f.write(gen_cmake_version(sections, build_numbers))

        client_display = make_display_version(
            int(sections["client"].get("major", 0)),
            int(sections["client"].get("minor", 0)),
            int(sections["client"].get("patch", 0)),
            sections["client"].get("stage", ""),
        )
        print(f"version_gen.py: compat={sections['compatibility'].get('major')}.{sections['compatibility'].get('minor')} "
              f"server={make_display_version(int(sections['server'].get('major',0)), int(sections['server'].get('minor',0)), int(sections['server'].get('patch',0)), sections['server'].get('stage',''))} "
              f"client={client_display} "
              f"build(client={build_numbers['client']}, server={build_numbers['server']}) -> {OUTPUT_HEADER}")
        return 0

    except Exception as e:
        print(f"version_gen.py: ERROR: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
